using System;
using System.Collections.Generic;
using System.Text;
using System.Runtime.InteropServices;
using System.Threading;
#pragma warning disable 0108
namespace SprCs {
    public partial class PHConstraintEngineDesc : CsObject {
	public PHConstraintEngineDesc() { _thisArray[0] = SprExport.Spr_new_PHConstraintEngineDesc(); _flag = true; }
	public PHConstraintEngineDesc(IntPtr ptr) : base(ptr) {}
	public PHConstraintEngineDesc(IntPtr ptr, bool flag) : base(ptr, flag) {}
	~PHConstraintEngineDesc() { if (_flag) { SprExport.Spr_delete_PHConstraintEngineDesc(_thisArray[0]); _flag = false; } }
	public int method {
	    get { return SprExport.Spr_PHConstraintEngineDesc_get_method(_thisArray[0]); }
	    set { SprExport.Spr_PHConstraintEngineDesc_set_method(_thisArray[0], value); }
	}
	public int numIter {
	    get { return SprExport.Spr_PHConstraintEngineDesc_get_numIter(_thisArray[0]); }
	    set { SprExport.Spr_PHConstraintEngineDesc_set_numIter(_thisArray[0], value); }
	}
	public int numIterCorrection {
	    get { return SprExport.Spr_PHConstraintEngineDesc_get_numIterCorrection(_thisArray[0]); }
	    set { SprExport.Spr_PHConstraintEngineDesc_set_numIterCorrection(_thisArray[0], value); }
	}
	public int numIterContactCorrection {
	    get { return SprExport.Spr_PHConstraintEngineDesc_get_numIterContactCorrection(_thisArray[0]); }
	    set { SprExport.Spr_PHConstraintEngineDesc_set_numIterContactCorrection(_thisArray[0], value); }
	}
	public double velCorrectionRate {
	    get { return SprExport.Spr_PHConstraintEngineDesc_get_velCorrectionRate(_thisArray[0]); }
	    set { SprExport.Spr_PHConstraintEngineDesc_set_velCorrectionRate(_thisArray[0], value); }
	}
	public double posCorrectionRate {
	    get { return SprExport.Spr_PHConstraintEngineDesc_get_posCorrectionRate(_thisArray[0]); }
	    set { SprExport.Spr_PHConstraintEngineDesc_set_posCorrectionRate(_thisArray[0], value); }
	}
	public double contactCorrectionRate {
	    get { return SprExport.Spr_PHConstraintEngineDesc_get_contactCorrectionRate(_thisArray[0]); }
	    set { SprExport.Spr_PHConstraintEngineDesc_set_contactCorrectionRate(_thisArray[0], value); }
	}
	public double shrinkRate {
	    get { return SprExport.Spr_PHConstraintEngineDesc_get_shrinkRate(_thisArray[0]); }
	    set { SprExport.Spr_PHConstraintEngineDesc_set_shrinkRate(_thisArray[0], value); }
	}
	public double shrinkRateCorrection {
	    get { return SprExport.Spr_PHConstraintEngineDesc_get_shrinkRateCorrection(_thisArray[0]); }
	    set { SprExport.Spr_PHConstraintEngineDesc_set_shrinkRateCorrection(_thisArray[0], value); }
	}
	public double freezeThreshold {
	    get { return SprExport.Spr_PHConstraintEngineDesc_get_freezeThreshold(_thisArray[0]); }
	    set { SprExport.Spr_PHConstraintEngineDesc_set_freezeThreshold(_thisArray[0], value); }
	}
	public double accelSOR {
	    get { return SprExport.Spr_PHConstraintEngineDesc_get_accelSOR(_thisArray[0]); }
	    set { SprExport.Spr_PHConstraintEngineDesc_set_accelSOR(_thisArray[0], value); }
	}
	public double dfEps {
	    get { return SprExport.Spr_PHConstraintEngineDesc_get_dfEps(_thisArray[0]); }
	    set { SprExport.Spr_PHConstraintEngineDesc_set_dfEps(_thisArray[0], value); }
	}
	public double regularization {
	    get { return SprExport.Spr_PHConstraintEngineDesc_get_regularization(_thisArray[0]); }
	    set { SprExport.Spr_PHConstraintEngineDesc_set_regularization(_thisArray[0], value); }
	}
	public bool bSaveConstraints {
	    get {
	        byte ret = (byte) SprExport.Spr_PHConstraintEngineDesc_get_bSaveConstraints(_thisArray[0]);
	        return (ret == 0) ? false : true;
	    }
	    set {
	        byte val = (byte) (value ? 1 : 0);
	        SprExport.Spr_PHConstraintEngineDesc_set_bSaveConstraints(_thisArray[0], (char) val);
	    }
	}
	public bool bUpdateAllState {
	    get {
	        byte ret = (byte) SprExport.Spr_PHConstraintEngineDesc_get_bUpdateAllState(_thisArray[0]);
	        return (ret == 0) ? false : true;
	    }
	    set {
	        byte val = (byte) (value ? 1 : 0);
	        SprExport.Spr_PHConstraintEngineDesc_set_bUpdateAllState(_thisArray[0], (char) val);
	    }
	}
	public bool bUseContactSurface {
	    get {
	        byte ret = (byte) SprExport.Spr_PHConstraintEngineDesc_get_bUseContactSurface(_thisArray[0]);
	        return (ret == 0) ? false : true;
	    }
	    set {
	        byte val = (byte) (value ? 1 : 0);
	        SprExport.Spr_PHConstraintEngineDesc_set_bUseContactSurface(_thisArray[0], (char) val);
	    }
	}
	public bool bReport {
	    get {
	        byte ret = (byte) SprExport.Spr_PHConstraintEngineDesc_get_bReport(_thisArray[0]);
	        return (ret == 0) ? false : true;
	    }
	    set {
	        byte val = (byte) (value ? 1 : 0);
	        SprExport.Spr_PHConstraintEngineDesc_set_bReport(_thisArray[0], (char) val);
	    }
	}
    }
    [System.Serializable]
    public class PHConstraintEngineDescStruct : CsObject {
        public PHConstraintEngineDescStruct() {
            PHConstraintEngineDesc desc = new PHConstraintEngineDesc();
            ApplyFrom(desc, false);
        }
	public int method;
	public int numIter;
	public int numIterCorrection;
	public int numIterContactCorrection;
	public double velCorrectionRate;
	public double posCorrectionRate;
	public double contactCorrectionRate;
	public double shrinkRate;
	public double shrinkRateCorrection;
	public double freezeThreshold;
	public double accelSOR;
	public double dfEps;
	public double regularization;
	public bool bSaveConstraints;
	public bool bUpdateAllState;
	public bool bUseContactSurface;
	public bool bReport;
	public void ApplyTo(PHConstraintEngineDesc r, bool apply_to_base_class = false) {
		r.method = method;
		r.numIter = numIter;
		r.numIterCorrection = numIterCorrection;
		r.numIterContactCorrection = numIterContactCorrection;
		r.velCorrectionRate = velCorrectionRate;
		r.posCorrectionRate = posCorrectionRate;
		r.contactCorrectionRate = contactCorrectionRate;
		r.shrinkRate = shrinkRate;
		r.shrinkRateCorrection = shrinkRateCorrection;
		r.freezeThreshold = freezeThreshold;
		r.accelSOR = accelSOR;
		r.dfEps = dfEps;
		r.regularization = regularization;
		r.bSaveConstraints = bSaveConstraints;
		r.bUpdateAllState = bUpdateAllState;
		r.bUseContactSurface = bUseContactSurface;
		r.bReport = bReport;
	}
	public void ApplyFrom(PHConstraintEngineDesc r, bool apply_to_base_class = false) {
		method = r.method;
		numIter = r.numIter;
		numIterCorrection = r.numIterCorrection;
		numIterContactCorrection = r.numIterContactCorrection;
		velCorrectionRate = r.velCorrectionRate;
		posCorrectionRate = r.posCorrectionRate;
		contactCorrectionRate = r.contactCorrectionRate;
		shrinkRate = r.shrinkRate;
		shrinkRateCorrection = r.shrinkRateCorrection;
		freezeThreshold = r.freezeThreshold;
		accelSOR = r.accelSOR;
		dfEps = r.dfEps;
		regularization = r.regularization;
		bSaveConstraints = r.bSaveConstraints;
		bUpdateAllState = r.bUpdateAllState;
		bUseContactSurface = r.bUseContactSurface;
		bReport = r.bReport;
	}
	public static implicit operator PHConstraintEngineDesc(PHConstraintEngineDescStruct m) {
	    PHConstraintEngineDesc r = new PHConstraintEngineDesc();
	    m.ApplyTo(r, true);
	    return r;
	}
	public static implicit operator PHConstraintEngineDescStruct(PHConstraintEngineDesc r) {
	    PHConstraintEngineDescStruct m = new PHConstraintEngineDescStruct();
	    m.ApplyFrom(r, true);
	    return m;
	}
    }
    public partial class PHIKEngineDesc : CsObject {
	public PHIKEngineDesc() { _thisArray[0] = SprExport.Spr_new_PHIKEngineDesc(); _flag = true; }
	public PHIKEngineDesc(IntPtr ptr) : base(ptr) {}
	public PHIKEngineDesc(IntPtr ptr, bool flag) : base(ptr, flag) {}
	~PHIKEngineDesc() { if (_flag) { SprExport.Spr_delete_PHIKEngineDesc(_thisArray[0]); _flag = false; } }
	public ulong numIter {
	    get { return SprExport.Spr_PHIKEngineDesc_get_numIter(_thisArray[0]); }
	    set { SprExport.Spr_PHIKEngineDesc_set_numIter(_thisArray[0], value); }
	}
	public double maxVel {
	    get { return SprExport.Spr_PHIKEngineDesc_get_maxVel(_thisArray[0]); }
	    set { SprExport.Spr_PHIKEngineDesc_set_maxVel(_thisArray[0], value); }
	}
	public double maxAngVel {
	    get { return SprExport.Spr_PHIKEngineDesc_get_maxAngVel(_thisArray[0]); }
	    set { SprExport.Spr_PHIKEngineDesc_set_maxAngVel(_thisArray[0], value); }
	}
	public double maxActVel {
	    get { return SprExport.Spr_PHIKEngineDesc_get_maxActVel(_thisArray[0]); }
	    set { SprExport.Spr_PHIKEngineDesc_set_maxActVel(_thisArray[0], value); }
	}
	public double regularizeParam {
	    get { return SprExport.Spr_PHIKEngineDesc_get_regularizeParam(_thisArray[0]); }
	    set { SprExport.Spr_PHIKEngineDesc_set_regularizeParam(_thisArray[0], value); }
	}
	public double regularizeParam2 {
	    get { return SprExport.Spr_PHIKEngineDesc_get_regularizeParam2(_thisArray[0]); }
	    set { SprExport.Spr_PHIKEngineDesc_set_regularizeParam2(_thisArray[0], value); }
	}
	public int regularizeMode {
	    get { return SprExport.Spr_PHIKEngineDesc_get_regularizeMode(_thisArray[0]); }
	    set { SprExport.Spr_PHIKEngineDesc_set_regularizeMode(_thisArray[0], value); }
	}
	public int iterGaussSeidel {
	    get { return SprExport.Spr_PHIKEngineDesc_get_iterGaussSeidel(_thisArray[0]); }
	    set { SprExport.Spr_PHIKEngineDesc_set_iterGaussSeidel(_thisArray[0], value); }
	}
	public Mode solverMode {
	    get { return (Mode) SprExport.Spr_PHIKEngineDesc_get_solverMode(_thisArray[0]); }
	    set { SprExport.Spr_PHIKEngineDesc_set_solverMode(_thisArray[0], (int) value); }
	}
	public enum Mode : int {
	    SVD = 0, QR = SVD + 1, LM = QR + 1
	}
    }
    [System.Serializable]
    public class PHIKEngineDescStruct : CsObject {
        public PHIKEngineDescStruct() {
            PHIKEngineDesc desc = new PHIKEngineDesc();
            ApplyFrom(desc, false);
        }
	public ulong numIter;
	public double maxVel;
	public double maxAngVel;
	public double maxActVel;
	public double regularizeParam;
	public double regularizeParam2;
	public int regularizeMode;
	public int iterGaussSeidel;
	public PHIKEngineDesc.Mode solverMode;
	public void ApplyTo(PHIKEngineDesc r, bool apply_to_base_class = false) {
		r.numIter = numIter;
		r.maxVel = maxVel;
		r.maxAngVel = maxAngVel;
		r.maxActVel = maxActVel;
		r.regularizeParam = regularizeParam;
		r.regularizeParam2 = regularizeParam2;
		r.regularizeMode = regularizeMode;
		r.iterGaussSeidel = iterGaussSeidel;
		r.solverMode = solverMode;
	}
	public void ApplyFrom(PHIKEngineDesc r, bool apply_to_base_class = false) {
		numIter = r.numIter;
		maxVel = r.maxVel;
		maxAngVel = r.maxAngVel;
		maxActVel = r.maxActVel;
		regularizeParam = r.regularizeParam;
		regularizeParam2 = r.regularizeParam2;
		regularizeMode = r.regularizeMode;
		iterGaussSeidel = r.iterGaussSeidel;
		solverMode = r.solverMode;
	}
	public static implicit operator PHIKEngineDesc(PHIKEngineDescStruct m) {
	    PHIKEngineDesc r = new PHIKEngineDesc();
	    m.ApplyTo(r, true);
	    return r;
	}
	public static implicit operator PHIKEngineDescStruct(PHIKEngineDesc r) {
	    PHIKEngineDescStruct m = new PHIKEngineDescStruct();
	    m.ApplyFrom(r, true);
	    return m;
	}
    }
    public partial class PHFemMeshState : CsObject {
	public PHFemMeshState() { _thisArray[0] = SprExport.Spr_new_PHFemMeshState(); _flag = true; }
	public PHFemMeshState(IntPtr ptr) : base(ptr) {}
	public PHFemMeshState(IntPtr ptr, bool flag) : base(ptr, flag) {}
	~PHFemMeshState() { if (_flag) { SprExport.Spr_delete_PHFemMeshState(_thisArray[0]); _flag = false; } }
    }
    [System.Serializable]
    public class PHFemMeshStateStruct : CsObject {
        public PHFemMeshStateStruct() {
            PHFemMeshState desc = new PHFemMeshState();
            ApplyFrom(desc, false);
        }
	public void ApplyTo(PHFemMeshState r, bool apply_to_base_class = false) {
	}
	public void ApplyFrom(PHFemMeshState r, bool apply_to_base_class = false) {
	}
	public static implicit operator PHFemMeshState(PHFemMeshStateStruct m) {
	    PHFemMeshState r = new PHFemMeshState();
	    m.ApplyTo(r, true);
	    return r;
	}
	public static implicit operator PHFemMeshStateStruct(PHFemMeshState r) {
	    PHFemMeshStateStruct m = new PHFemMeshStateStruct();
	    m.ApplyFrom(r, true);
	    return m;
	}
    }
    public partial class PHFemMeshDesc : PHFemMeshState {
	public PHFemMeshDesc() { _thisArray[0] = SprExport.Spr_new_PHFemMeshDesc(); _flag = true; }
	public PHFemMeshDesc(IntPtr ptr) : base(ptr) {}
	public PHFemMeshDesc(IntPtr ptr, bool flag) : base(ptr, flag) {}
	~PHFemMeshDesc() { if (_flag) { SprExport.Spr_delete_PHFemMeshDesc(_thisArray[0]); _flag = false; } }
        public vectorwrapper_Vec3d vertices {
            get { return new vectorwrapper_Vec3d(SprExport.Spr_PHFemMeshDesc_addr_vertices(_thisArray[0])); }
            set { SprExport.Spr_PHFemMeshDesc_set_vertices(_thisArray[0], value); }
        }
        public vectorwrapper_int tets {
            get { return new vectorwrapper_int(SprExport.Spr_PHFemMeshDesc_addr_tets(_thisArray[0])); }
            set { SprExport.Spr_PHFemMeshDesc_set_tets(_thisArray[0], value); }
        }
        public vectorwrapper_int faces {
            get { return new vectorwrapper_int(SprExport.Spr_PHFemMeshDesc_addr_faces(_thisArray[0])); }
            set { SprExport.Spr_PHFemMeshDesc_set_faces(_thisArray[0], value); }
        }
	public void Init() {
	    SprExport.Spr_PHFemMeshDesc_Init((IntPtr) _thisArray[0]);
	}
    }
    [System.Serializable]
    public class PHFemMeshDescStruct : PHFemMeshStateStruct {
        public PHFemMeshDescStruct() {
            PHFemMeshDesc desc = new PHFemMeshDesc();
            ApplyFrom(desc, false);
        }
	public vectorwrapper_Vec3d vertices;
	public vectorwrapper_int tets;
	public vectorwrapper_int faces;
	public void ApplyTo(PHFemMeshDesc r, bool apply_to_base_class = false) {
		r.vertices = vertices;
		r.tets = tets;
		r.faces = faces;
	}
	public void ApplyFrom(PHFemMeshDesc r, bool apply_to_base_class = false) {
		vertices = r.vertices;
		tets = r.tets;
		faces = r.faces;
	}
	public static implicit operator PHFemMeshDesc(PHFemMeshDescStruct m) {
	    PHFemMeshDesc r = new PHFemMeshDesc();
	    m.ApplyTo(r, true);
	    return r;
	}
	public static implicit operator PHFemMeshDescStruct(PHFemMeshDesc r) {
	    PHFemMeshDescStruct m = new PHFemMeshDescStruct();
	    m.ApplyFrom(r, true);
	    return m;
	}
    }
    public partial class PHFemMeshThermoDesc : PHFemMeshDesc {
	public PHFemMeshThermoDesc() { _thisArray[0] = SprExport.Spr_new_PHFemMeshThermoDesc(); _flag = true; }
	public PHFemMeshThermoDesc(IntPtr ptr) : base(ptr) {}
	public PHFemMeshThermoDesc(IntPtr ptr, bool flag) : base(ptr, flag) {}
	~PHFemMeshThermoDesc() { if (_flag) { SprExport.Spr_delete_PHFemMeshThermoDesc(_thisArray[0]); _flag = false; } }
	public double rho {
	    get { return SprExport.Spr_PHFemMeshThermoDesc_get_rho(_thisArray[0]); }
	    set { SprExport.Spr_PHFemMeshThermoDesc_set_rho(_thisArray[0], value); }
	}
	public double thConduct {
	    get { return SprExport.Spr_PHFemMeshThermoDesc_get_thConduct(_thisArray[0]); }
	    set { SprExport.Spr_PHFemMeshThermoDesc_set_thConduct(_thisArray[0], value); }
	}
	public double thConduct_x {
	    get { return SprExport.Spr_PHFemMeshThermoDesc_get_thConduct_x(_thisArray[0]); }
	    set { SprExport.Spr_PHFemMeshThermoDesc_set_thConduct_x(_thisArray[0], value); }
	}
	public double thConduct_y {
	    get { return SprExport.Spr_PHFemMeshThermoDesc_get_thConduct_y(_thisArray[0]); }
	    set { SprExport.Spr_PHFemMeshThermoDesc_set_thConduct_y(_thisArray[0], value); }
	}
	public double thConduct_z {
	    get { return SprExport.Spr_PHFemMeshThermoDesc_get_thConduct_z(_thisArray[0]); }
	    set { SprExport.Spr_PHFemMeshThermoDesc_set_thConduct_z(_thisArray[0], value); }
	}
	public double heatTrans {
	    get { return SprExport.Spr_PHFemMeshThermoDesc_get_heatTrans(_thisArray[0]); }
	    set { SprExport.Spr_PHFemMeshThermoDesc_set_heatTrans(_thisArray[0], value); }
	}
	public double specificHeat {
	    get { return SprExport.Spr_PHFemMeshThermoDesc_get_specificHeat(_thisArray[0]); }
	    set { SprExport.Spr_PHFemMeshThermoDesc_set_specificHeat(_thisArray[0], value); }
	}
	public double radiantHeat {
	    get { return SprExport.Spr_PHFemMeshThermoDesc_get_radiantHeat(_thisArray[0]); }
	    set { SprExport.Spr_PHFemMeshThermoDesc_set_radiantHeat(_thisArray[0], value); }
	}
	public double initial_temp {
	    get { return SprExport.Spr_PHFemMeshThermoDesc_get_initial_temp(_thisArray[0]); }
	    set { SprExport.Spr_PHFemMeshThermoDesc_set_initial_temp(_thisArray[0], value); }
	}
	public void Init() {
	    SprExport.Spr_PHFemMeshThermoDesc_Init((IntPtr) _thisArray[0]);
	}
    }
    [System.Serializable]
    public class PHFemMeshThermoDescStruct : PHFemMeshDescStruct {
        public PHFemMeshThermoDescStruct() {
            PHFemMeshThermoDesc desc = new PHFemMeshThermoDesc();
            ApplyFrom(desc, true);
        }
	public double rho;
	public double thConduct;
	public double thConduct_x;
	public double thConduct_y;
	public double thConduct_z;
	public double heatTrans;
	public double specificHeat;
	public double radiantHeat;
	public double initial_temp;
	public void ApplyTo(PHFemMeshThermoDesc r, bool apply_to_base_class = false) {
		r.rho = rho;
		r.thConduct = thConduct;
		r.thConduct_x = thConduct_x;
		r.thConduct_y = thConduct_y;
		r.thConduct_z = thConduct_z;
		r.heatTrans = heatTrans;
		r.specificHeat = specificHeat;
		r.radiantHeat = radiantHeat;
		r.initial_temp = initial_temp;
		if (apply_to_base_class) {
		    base.ApplyTo(r, apply_to_base_class);
		}
	}
	public void ApplyFrom(PHFemMeshThermoDesc r, bool apply_to_base_class = false) {
		rho = r.rho;
		thConduct = r.thConduct;
		thConduct_x = r.thConduct_x;
		thConduct_y = r.thConduct_y;
		thConduct_z = r.thConduct_z;
		heatTrans = r.heatTrans;
		specificHeat = r.specificHeat;
		radiantHeat = r.radiantHeat;
		initial_temp = r.initial_temp;
		if (apply_to_base_class) {
		    base.ApplyFrom(r, apply_to_base_class);
		}
	}
	public static implicit operator PHFemMeshThermoDesc(PHFemMeshThermoDescStruct m) {
	    PHFemMeshThermoDesc r = new PHFemMeshThermoDesc();
	    m.ApplyTo(r, true);
	    return r;
	}
	public static implicit operator PHFemMeshThermoDescStruct(PHFemMeshThermoDesc r) {
	    PHFemMeshThermoDescStruct m = new PHFemMeshThermoDescStruct();
	    m.ApplyFrom(r, true);
	    return m;
	}
    }
    public partial class PHFemMeshNewState : CsObject {
	public PHFemMeshNewState() { _thisArray[0] = SprExport.Spr_new_PHFemMeshNewState(); _flag = true; }
	public PHFemMeshNewState(IntPtr ptr) : base(ptr) {}
	public PHFemMeshNewState(IntPtr ptr, bool flag) : base(ptr, flag) {}
	~PHFemMeshNewState() { if (_flag) { SprExport.Spr_delete_PHFemMeshNewState(_thisArray[0]); _flag = false; } }
    }
    [System.Serializable]
    public class PHFemMeshNewStateStruct : CsObject {
        public PHFemMeshNewStateStruct() {
            PHFemMeshNewState desc = new PHFemMeshNewState();
            ApplyFrom(desc, false);
        }
	public void ApplyTo(PHFemMeshNewState r, bool apply_to_base_class = false) {
	}
	public void ApplyFrom(PHFemMeshNewState r, bool apply_to_base_class = false) {
	}
	public static implicit operator PHFemMeshNewState(PHFemMeshNewStateStruct m) {
	    PHFemMeshNewState r = new PHFemMeshNewState();
	    m.ApplyTo(r, true);
	    return r;
	}
	public static implicit operator PHFemMeshNewStateStruct(PHFemMeshNewState r) {
	    PHFemMeshNewStateStruct m = new PHFemMeshNewStateStruct();
	    m.ApplyFrom(r, true);
	    return m;
	}
    }
    public partial class PHFemMeshNewDesc : PHFemMeshNewState {
	public PHFemMeshNewDesc() { _thisArray[0] = SprExport.Spr_new_PHFemMeshNewDesc(); _flag = true; }
	public PHFemMeshNewDesc(IntPtr ptr) : base(ptr) {}
	public PHFemMeshNewDesc(IntPtr ptr, bool flag) : base(ptr, flag) {}
	~PHFemMeshNewDesc() { if (_flag) { SprExport.Spr_delete_PHFemMeshNewDesc(_thisArray[0]); _flag = false; } }
        public vectorwrapper_Vec3d vertices {
            get { return new vectorwrapper_Vec3d(SprExport.Spr_PHFemMeshNewDesc_addr_vertices(_thisArray[0])); }
            set { SprExport.Spr_PHFemMeshNewDesc_set_vertices(_thisArray[0], value); }
        }
        public vectorwrapper_int tets {
            get { return new vectorwrapper_int(SprExport.Spr_PHFemMeshNewDesc_addr_tets(_thisArray[0])); }
            set { SprExport.Spr_PHFemMeshNewDesc_set_tets(_thisArray[0], value); }
        }
        public vectorwrapper_int faces {
            get { return new vectorwrapper_int(SprExport.Spr_PHFemMeshNewDesc_addr_faces(_thisArray[0])); }
            set { SprExport.Spr_PHFemMeshNewDesc_set_faces(_thisArray[0], value); }
        }
	public bool spheric {
	    get {
	        byte ret = (byte) SprExport.Spr_PHFemMeshNewDesc_get_spheric(_thisArray[0]);
	        return (ret == 0) ? false : true;
	    }
	    set {
	        byte val = (byte) (value ? 1 : 0);
	        SprExport.Spr_PHFemMeshNewDesc_set_spheric(_thisArray[0], (char) val);
	    }
	}
    }
    [System.Serializable]
    public class PHFemMeshNewDescStruct : PHFemMeshNewStateStruct {
        public PHFemMeshNewDescStruct() {
            PHFemMeshNewDesc desc = new PHFemMeshNewDesc();
            ApplyFrom(desc, false);
        }
	public vectorwrapper_Vec3d vertices;
	public vectorwrapper_int tets;
	public vectorwrapper_int faces;
	public bool spheric;
	public void ApplyTo(PHFemMeshNewDesc r, bool apply_to_base_class = false) {
		r.vertices = vertices;
		r.tets = tets;
		r.faces = faces;
		r.spheric = spheric;
	}
	public void ApplyFrom(PHFemMeshNewDesc r, bool apply_to_base_class = false) {
		vertices = r.vertices;
		tets = r.tets;
		faces = r.faces;
		spheric = r.spheric;
	}
	public static implicit operator PHFemMeshNewDesc(PHFemMeshNewDescStruct m) {
	    PHFemMeshNewDesc r = new PHFemMeshNewDesc();
	    m.ApplyTo(r, true);
	    return r;
	}
	public static implicit operator PHFemMeshNewDescStruct(PHFemMeshNewDesc r) {
	    PHFemMeshNewDescStruct m = new PHFemMeshNewDescStruct();
	    m.ApplyFrom(r, true);
	    return m;
	}
    }
    public partial class PHFemBaseDesc : CsObject {
	public PHFemBaseDesc() { _thisArray[0] = SprExport.Spr_new_PHFemBaseDesc(); _flag = true; }
	public PHFemBaseDesc(IntPtr ptr) : base(ptr) {}
	public PHFemBaseDesc(IntPtr ptr, bool flag) : base(ptr, flag) {}
	~PHFemBaseDesc() { if (_flag) { SprExport.Spr_delete_PHFemBaseDesc(_thisArray[0]); _flag = false; } }
    }
    [System.Serializable]
    public class PHFemBaseDescStruct : CsObject {
        public PHFemBaseDescStruct() {
            PHFemBaseDesc desc = new PHFemBaseDesc();
            ApplyFrom(desc, false);
        }
	public void ApplyTo(PHFemBaseDesc r, bool apply_to_base_class = false) {
	}
	public void ApplyFrom(PHFemBaseDesc r, bool apply_to_base_class = false) {
	}
	public static implicit operator PHFemBaseDesc(PHFemBaseDescStruct m) {
	    PHFemBaseDesc r = new PHFemBaseDesc();
	    m.ApplyTo(r, true);
	    return r;
	}
	public static implicit operator PHFemBaseDescStruct(PHFemBaseDesc r) {
	    PHFemBaseDescStruct m = new PHFemBaseDescStruct();
	    m.ApplyFrom(r, true);
	    return m;
	}
    }
    public partial class PHFemVibrationDesc : PHFemBaseDesc {
	public PHFemVibrationDesc() { _thisArray[0] = SprExport.Spr_new_PHFemVibrationDesc(); _flag = true; }
	public PHFemVibrationDesc(IntPtr ptr) : base(ptr) {}
	public PHFemVibrationDesc(IntPtr ptr, bool flag) : base(ptr, flag) {}
	~PHFemVibrationDesc() { if (_flag) { SprExport.Spr_delete_PHFemVibrationDesc(_thisArray[0]); _flag = false; } }
	public double young {
	    get { return SprExport.Spr_PHFemVibrationDesc_get_young(_thisArray[0]); }
	    set { SprExport.Spr_PHFemVibrationDesc_set_young(_thisArray[0], value); }
	}
	public double poisson {
	    get { return SprExport.Spr_PHFemVibrationDesc_get_poisson(_thisArray[0]); }
	    set { SprExport.Spr_PHFemVibrationDesc_set_poisson(_thisArray[0], value); }
	}
	public double density {
	    get { return SprExport.Spr_PHFemVibrationDesc_get_density(_thisArray[0]); }
	    set { SprExport.Spr_PHFemVibrationDesc_set_density(_thisArray[0], value); }
	}
	public double alpha {
	    get { return SprExport.Spr_PHFemVibrationDesc_get_alpha(_thisArray[0]); }
	    set { SprExport.Spr_PHFemVibrationDesc_set_alpha(_thisArray[0], value); }
	}
	public double beta {
	    get { return SprExport.Spr_PHFemVibrationDesc_get_beta(_thisArray[0]); }
	    set { SprExport.Spr_PHFemVibrationDesc_set_beta(_thisArray[0], value); }
	}
        public vectorwrapper_int fixedVertices {
            get { return new vectorwrapper_int(SprExport.Spr_PHFemVibrationDesc_addr_fixedVertices(_thisArray[0])); }
            set { SprExport.Spr_PHFemVibrationDesc_set_fixedVertices(_thisArray[0], value); }
        }
	public enum ANALYSIS_MODE : int {
	    ANALYSIS_DIRECT = 0, ANALYSIS_MODAL = ANALYSIS_DIRECT + 1
	}
	public enum INTEGRATION_MODE : int {
	    INT_EXPLICIT_EULER = 0, INT_IMPLICIT_EULER = INT_EXPLICIT_EULER + 1, INT_SIMPLECTIC = INT_IMPLICIT_EULER + 1, INT_NEWMARK_BETA = INT_SIMPLECTIC + 1
	}
    }
    [System.Serializable]
    public class PHFemVibrationDescStruct : PHFemBaseDescStruct {
        public PHFemVibrationDescStruct() {
            PHFemVibrationDesc desc = new PHFemVibrationDesc();
            ApplyFrom(desc, true);
        }
	public double young;
	public double poisson;
	public double density;
	public double alpha;
	public double beta;
	public vectorwrapper_int fixedVertices;
	public void ApplyTo(PHFemVibrationDesc r, bool apply_to_base_class = false) {
		r.young = young;
		r.poisson = poisson;
		r.density = density;
		r.alpha = alpha;
		r.beta = beta;
		r.fixedVertices = fixedVertices;
		if (apply_to_base_class) {
		    base.ApplyTo(r, apply_to_base_class);
		}
	}
	public void ApplyFrom(PHFemVibrationDesc r, bool apply_to_base_class = false) {
		young = r.young;
		poisson = r.poisson;
		density = r.density;
		alpha = r.alpha;
		beta = r.beta;
		fixedVertices = r.fixedVertices;
		if (apply_to_base_class) {
		    base.ApplyFrom(r, apply_to_base_class);
		}
	}
	public static implicit operator PHFemVibrationDesc(PHFemVibrationDescStruct m) {
	    PHFemVibrationDesc r = new PHFemVibrationDesc();
	    m.ApplyTo(r, true);
	    return r;
	}
	public static implicit operator PHFemVibrationDescStruct(PHFemVibrationDesc r) {
	    PHFemVibrationDescStruct m = new PHFemVibrationDescStruct();
	    m.ApplyFrom(r, true);
	    return m;
	}
    }
    public partial class PHFemThermoDesc : PHFemBaseDesc {
	public PHFemThermoDesc() { _thisArray[0] = SprExport.Spr_new_PHFemThermoDesc(); _flag = true; }
	public PHFemThermoDesc(IntPtr ptr) : base(ptr) {}
	public PHFemThermoDesc(IntPtr ptr, bool flag) : base(ptr, flag) {}
	~PHFemThermoDesc() { if (_flag) { SprExport.Spr_delete_PHFemThermoDesc(_thisArray[0]); _flag = false; } }
	public double rho {
	    get { return SprExport.Spr_PHFemThermoDesc_get_rho(_thisArray[0]); }
	    set { SprExport.Spr_PHFemThermoDesc_set_rho(_thisArray[0], value); }
	}
	public double heatTrans {
	    get { return SprExport.Spr_PHFemThermoDesc_get_heatTrans(_thisArray[0]); }
	    set { SprExport.Spr_PHFemThermoDesc_set_heatTrans(_thisArray[0], value); }
	}
	public double specificHeat {
	    get { return SprExport.Spr_PHFemThermoDesc_get_specificHeat(_thisArray[0]); }
	    set { SprExport.Spr_PHFemThermoDesc_set_specificHeat(_thisArray[0], value); }
	}
	public double radiantHeat {
	    get { return SprExport.Spr_PHFemThermoDesc_get_radiantHeat(_thisArray[0]); }
	    set { SprExport.Spr_PHFemThermoDesc_set_radiantHeat(_thisArray[0], value); }
	}
	public double initial_temp {
	    get { return SprExport.Spr_PHFemThermoDesc_get_initial_temp(_thisArray[0]); }
	    set { SprExport.Spr_PHFemThermoDesc_set_initial_temp(_thisArray[0], value); }
	}
	public double weekPow_full {
	    get { return SprExport.Spr_PHFemThermoDesc_get_weekPow_full(_thisArray[0]); }
	    set { SprExport.Spr_PHFemThermoDesc_set_weekPow_full(_thisArray[0], value); }
	}
	public void Init() {
	    SprExport.Spr_PHFemThermoDesc_Init((IntPtr) _thisArray[0]);
	}
    }
    [System.Serializable]
    public class PHFemThermoDescStruct : PHFemBaseDescStruct {
        public PHFemThermoDescStruct() {
            PHFemThermoDesc desc = new PHFemThermoDesc();
            ApplyFrom(desc, true);
        }
	public double rho;
	public double heatTrans;
	public double specificHeat;
	public double radiantHeat;
	public double initial_temp;
	public double weekPow_full;
	public void ApplyTo(PHFemThermoDesc r, bool apply_to_base_class = false) {
		r.rho = rho;
		r.heatTrans = heatTrans;
		r.specificHeat = specificHeat;
		r.radiantHeat = radiantHeat;
		r.initial_temp = initial_temp;
		r.weekPow_full = weekPow_full;
		if (apply_to_base_class) {
		    base.ApplyTo(r, apply_to_base_class);
		}
	}
	public void ApplyFrom(PHFemThermoDesc r, bool apply_to_base_class = false) {
		rho = r.rho;
		heatTrans = r.heatTrans;
		specificHeat = r.specificHeat;
		radiantHeat = r.radiantHeat;
		initial_temp = r.initial_temp;
		weekPow_full = r.weekPow_full;
		if (apply_to_base_class) {
		    base.ApplyFrom(r, apply_to_base_class);
		}
	}
	public static implicit operator PHFemThermoDesc(PHFemThermoDescStruct m) {
	    PHFemThermoDesc r = new PHFemThermoDesc();
	    m.ApplyTo(r, true);
	    return r;
	}
	public static implicit operator PHFemThermoDescStruct(PHFemThermoDesc r) {
	    PHFemThermoDescStruct m = new PHFemThermoDescStruct();
	    m.ApplyFrom(r, true);
	    return m;
	}
    }
    public partial class PHFemPorousWOMoveDesc : PHFemBaseDesc {
	public PHFemPorousWOMoveDesc() { _thisArray[0] = SprExport.Spr_new_PHFemPorousWOMoveDesc(); _flag = true; }
	public PHFemPorousWOMoveDesc(IntPtr ptr) : base(ptr) {}
	public PHFemPorousWOMoveDesc(IntPtr ptr, bool flag) : base(ptr, flag) {}
	~PHFemPorousWOMoveDesc() { if (_flag) { SprExport.Spr_delete_PHFemPorousWOMoveDesc(_thisArray[0]); _flag = false; } }
	public double wDiffAir {
	    get { return SprExport.Spr_PHFemPorousWOMoveDesc_get_wDiffAir(_thisArray[0]); }
	    set { SprExport.Spr_PHFemPorousWOMoveDesc_set_wDiffAir(_thisArray[0], value); }
	}
	public double K {
	    get { return SprExport.Spr_PHFemPorousWOMoveDesc_get_K(_thisArray[0]); }
	    set { SprExport.Spr_PHFemPorousWOMoveDesc_set_K(_thisArray[0], value); }
	}
	public double kc {
	    get { return SprExport.Spr_PHFemPorousWOMoveDesc_get_kc(_thisArray[0]); }
	    set { SprExport.Spr_PHFemPorousWOMoveDesc_set_kc(_thisArray[0], value); }
	}
	public double kp {
	    get { return SprExport.Spr_PHFemPorousWOMoveDesc_get_kp(_thisArray[0]); }
	    set { SprExport.Spr_PHFemPorousWOMoveDesc_set_kp(_thisArray[0], value); }
	}
	public double alpha {
	    get { return SprExport.Spr_PHFemPorousWOMoveDesc_get_alpha(_thisArray[0]); }
	    set { SprExport.Spr_PHFemPorousWOMoveDesc_set_alpha(_thisArray[0], value); }
	}
	public double gamma {
	    get { return SprExport.Spr_PHFemPorousWOMoveDesc_get_gamma(_thisArray[0]); }
	    set { SprExport.Spr_PHFemPorousWOMoveDesc_set_gamma(_thisArray[0], value); }
	}
	public double rhoWater {
	    get { return SprExport.Spr_PHFemPorousWOMoveDesc_get_rhoWater(_thisArray[0]); }
	    set { SprExport.Spr_PHFemPorousWOMoveDesc_set_rhoWater(_thisArray[0], value); }
	}
	public double rhoOil {
	    get { return SprExport.Spr_PHFemPorousWOMoveDesc_get_rhoOil(_thisArray[0]); }
	    set { SprExport.Spr_PHFemPorousWOMoveDesc_set_rhoOil(_thisArray[0], value); }
	}
	public double rhowInit {
	    get { return SprExport.Spr_PHFemPorousWOMoveDesc_get_rhowInit(_thisArray[0]); }
	    set { SprExport.Spr_PHFemPorousWOMoveDesc_set_rhowInit(_thisArray[0], value); }
	}
	public double rhooInit {
	    get { return SprExport.Spr_PHFemPorousWOMoveDesc_get_rhooInit(_thisArray[0]); }
	    set { SprExport.Spr_PHFemPorousWOMoveDesc_set_rhooInit(_thisArray[0], value); }
	}
	public double evapoRate {
	    get { return SprExport.Spr_PHFemPorousWOMoveDesc_get_evapoRate(_thisArray[0]); }
	    set { SprExport.Spr_PHFemPorousWOMoveDesc_set_evapoRate(_thisArray[0], value); }
	}
	public double denatTemp {
	    get { return SprExport.Spr_PHFemPorousWOMoveDesc_get_denatTemp(_thisArray[0]); }
	    set { SprExport.Spr_PHFemPorousWOMoveDesc_set_denatTemp(_thisArray[0], value); }
	}
	public double boundWaterRatio {
	    get { return SprExport.Spr_PHFemPorousWOMoveDesc_get_boundWaterRatio(_thisArray[0]); }
	    set { SprExport.Spr_PHFemPorousWOMoveDesc_set_boundWaterRatio(_thisArray[0], value); }
	}
	public double equilWaterCont {
	    get { return SprExport.Spr_PHFemPorousWOMoveDesc_get_equilWaterCont(_thisArray[0]); }
	    set { SprExport.Spr_PHFemPorousWOMoveDesc_set_equilWaterCont(_thisArray[0], value); }
	}
	public double limitWaterCont {
	    get { return SprExport.Spr_PHFemPorousWOMoveDesc_get_limitWaterCont(_thisArray[0]); }
	    set { SprExport.Spr_PHFemPorousWOMoveDesc_set_limitWaterCont(_thisArray[0], value); }
	}
	public double boundaryThick {
	    get { return SprExport.Spr_PHFemPorousWOMoveDesc_get_boundaryThick(_thisArray[0]); }
	    set { SprExport.Spr_PHFemPorousWOMoveDesc_set_boundaryThick(_thisArray[0], value); }
	}
	public double initMassAll {
	    get { return SprExport.Spr_PHFemPorousWOMoveDesc_get_initMassAll(_thisArray[0]); }
	    set { SprExport.Spr_PHFemPorousWOMoveDesc_set_initMassAll(_thisArray[0], value); }
	}
	public double initWaterRatio {
	    get { return SprExport.Spr_PHFemPorousWOMoveDesc_get_initWaterRatio(_thisArray[0]); }
	    set { SprExport.Spr_PHFemPorousWOMoveDesc_set_initWaterRatio(_thisArray[0], value); }
	}
	public double initOilRatio {
	    get { return SprExport.Spr_PHFemPorousWOMoveDesc_get_initOilRatio(_thisArray[0]); }
	    set { SprExport.Spr_PHFemPorousWOMoveDesc_set_initOilRatio(_thisArray[0], value); }
	}
	public double shrinkageRatio {
	    get { return SprExport.Spr_PHFemPorousWOMoveDesc_get_shrinkageRatio(_thisArray[0]); }
	    set { SprExport.Spr_PHFemPorousWOMoveDesc_set_shrinkageRatio(_thisArray[0], value); }
	}
	public Vec3d top {
	    get { return new Vec3d(SprExport.Spr_PHFemPorousWOMoveDesc_addr_top(_thisArray[0])); }
	    set { SprExport.Spr_PHFemPorousWOMoveDesc_set_top(_thisArray[0], value); }
	}
	public Vec3d center {
	    get { return new Vec3d(SprExport.Spr_PHFemPorousWOMoveDesc_addr_center(_thisArray[0])); }
	    set { SprExport.Spr_PHFemPorousWOMoveDesc_set_center(_thisArray[0], value); }
	}
	public Vec3d bottom {
	    get { return new Vec3d(SprExport.Spr_PHFemPorousWOMoveDesc_addr_bottom(_thisArray[0])); }
	    set { SprExport.Spr_PHFemPorousWOMoveDesc_set_bottom(_thisArray[0], value); }
	}
	public void Init() {
	    SprExport.Spr_PHFemPorousWOMoveDesc_Init((IntPtr) _thisArray[0]);
	}
    }
    [System.Serializable]
    public class PHFemPorousWOMoveDescStruct : PHFemBaseDescStruct {
        public PHFemPorousWOMoveDescStruct() {
            PHFemPorousWOMoveDesc desc = new PHFemPorousWOMoveDesc();
            ApplyFrom(desc, true);
        }
	public double wDiffAir;
	public double K;
	public double kc;
	public double kp;
	public double alpha;
	public double gamma;
	public double rhoWater;
	public double rhoOil;
	public double rhowInit;
	public double rhooInit;
	public double evapoRate;
	public double denatTemp;
	public double boundWaterRatio;
	public double equilWaterCont;
	public double limitWaterCont;
	public double boundaryThick;
	public double initMassAll;
	public double initWaterRatio;
	public double initOilRatio;
	public double shrinkageRatio;
	public Vec3dStruct top;
	public Vec3dStruct center;
	public Vec3dStruct bottom;
	public void ApplyTo(PHFemPorousWOMoveDesc r, bool apply_to_base_class = false) {
		r.wDiffAir = wDiffAir;
		r.K = K;
		r.kc = kc;
		r.kp = kp;
		r.alpha = alpha;
		r.gamma = gamma;
		r.rhoWater = rhoWater;
		r.rhoOil = rhoOil;
		r.rhowInit = rhowInit;
		r.rhooInit = rhooInit;
		r.evapoRate = evapoRate;
		r.denatTemp = denatTemp;
		r.boundWaterRatio = boundWaterRatio;
		r.equilWaterCont = equilWaterCont;
		r.limitWaterCont = limitWaterCont;
		r.boundaryThick = boundaryThick;
		r.initMassAll = initMassAll;
		r.initWaterRatio = initWaterRatio;
		r.initOilRatio = initOilRatio;
		r.shrinkageRatio = shrinkageRatio;
		r.top = top;
		r.center = center;
		r.bottom = bottom;
		if (apply_to_base_class) {
		    base.ApplyTo(r, apply_to_base_class);
		}
	}
	public void ApplyFrom(PHFemPorousWOMoveDesc r, bool apply_to_base_class = false) {
		wDiffAir = r.wDiffAir;
		K = r.K;
		kc = r.kc;
		kp = r.kp;
		alpha = r.alpha;
		gamma = r.gamma;
		rhoWater = r.rhoWater;
		rhoOil = r.rhoOil;
		rhowInit = r.rhowInit;
		rhooInit = r.rhooInit;
		evapoRate = r.evapoRate;
		denatTemp = r.denatTemp;
		boundWaterRatio = r.boundWaterRatio;
		equilWaterCont = r.equilWaterCont;
		limitWaterCont = r.limitWaterCont;
		boundaryThick = r.boundaryThick;
		initMassAll = r.initMassAll;
		initWaterRatio = r.initWaterRatio;
		initOilRatio = r.initOilRatio;
		shrinkageRatio = r.shrinkageRatio;
		top = r.top;
		center = r.center;
		bottom = r.bottom;
		if (apply_to_base_class) {
		    base.ApplyFrom(r, apply_to_base_class);
		}
	}
	public static implicit operator PHFemPorousWOMoveDesc(PHFemPorousWOMoveDescStruct m) {
	    PHFemPorousWOMoveDesc r = new PHFemPorousWOMoveDesc();
	    m.ApplyTo(r, true);
	    return r;
	}
	public static implicit operator PHFemPorousWOMoveDescStruct(PHFemPorousWOMoveDesc r) {
	    PHFemPorousWOMoveDescStruct m = new PHFemPorousWOMoveDescStruct();
	    m.ApplyFrom(r, true);
	    return m;
	}
    }
    public partial class PHFrameDesc : CsObject {
	public PHFrameDesc() { _thisArray[0] = SprExport.Spr_new_PHFrameDesc(); _flag = true; }
	public PHFrameDesc(IntPtr ptr) : base(ptr) {}
	public PHFrameDesc(IntPtr ptr, bool flag) : base(ptr, flag) {}
	~PHFrameDesc() { if (_flag) { SprExport.Spr_delete_PHFrameDesc(_thisArray[0]); _flag = false; } }
	public Posed pose {
	    get { return new Posed(SprExport.Spr_PHFrameDesc_addr_pose(_thisArray[0])); }
	    set { SprExport.Spr_PHFrameDesc_set_pose(_thisArray[0], value); }
	}
    }
    [System.Serializable]
    public class PHFrameDescStruct : CsObject {
        public PHFrameDescStruct() {
            PHFrameDesc desc = new PHFrameDesc();
            ApplyFrom(desc, false);
        }
	public PosedStruct pose;
	public void ApplyTo(PHFrameDesc r, bool apply_to_base_class = false) {
		r.pose = pose;
	}
	public void ApplyFrom(PHFrameDesc r, bool apply_to_base_class = false) {
		pose = r.pose;
	}
	public static implicit operator PHFrameDesc(PHFrameDescStruct m) {
	    PHFrameDesc r = new PHFrameDesc();
	    m.ApplyTo(r, true);
	    return r;
	}
	public static implicit operator PHFrameDescStruct(PHFrameDesc r) {
	    PHFrameDescStruct m = new PHFrameDescStruct();
	    m.ApplyFrom(r, true);
	    return m;
	}
    }
    public partial class PHSolidState : CsObject {
	public PHSolidState() { _thisArray[0] = SprExport.Spr_new_PHSolidState(); _flag = true; }
	public PHSolidState(IntPtr ptr) : base(ptr) {}
	public PHSolidState(IntPtr ptr, bool flag) : base(ptr, flag) {}
	~PHSolidState() { if (_flag) { SprExport.Spr_delete_PHSolidState(_thisArray[0]); _flag = false; } }
	public Vec3d velocity {
	    get { return new Vec3d(SprExport.Spr_PHSolidState_addr_velocity(_thisArray[0])); }
	    set { SprExport.Spr_PHSolidState_set_velocity(_thisArray[0], value); }
	}
	public Vec3d angVelocity {
	    get { return new Vec3d(SprExport.Spr_PHSolidState_addr_angVelocity(_thisArray[0])); }
	    set { SprExport.Spr_PHSolidState_set_angVelocity(_thisArray[0], value); }
	}
	public Posed pose {
	    get { return new Posed(SprExport.Spr_PHSolidState_addr_pose(_thisArray[0])); }
	    set { SprExport.Spr_PHSolidState_set_pose(_thisArray[0], value); }
	}
    }
    [System.Serializable]
    public class PHSolidStateStruct : CsObject {
        public PHSolidStateStruct() {
            PHSolidState desc = new PHSolidState();
            ApplyFrom(desc, false);
        }
	public Vec3dStruct velocity;
	public Vec3dStruct angVelocity;
	public PosedStruct pose;
	public void ApplyTo(PHSolidState r, bool apply_to_base_class = false) {
		r.velocity = velocity;
		r.angVelocity = angVelocity;
		r.pose = pose;
	}
	public void ApplyFrom(PHSolidState r, bool apply_to_base_class = false) {
		velocity = r.velocity;
		angVelocity = r.angVelocity;
		pose = r.pose;
	}
	public static implicit operator PHSolidState(PHSolidStateStruct m) {
	    PHSolidState r = new PHSolidState();
	    m.ApplyTo(r, true);
	    return r;
	}
	public static implicit operator PHSolidStateStruct(PHSolidState r) {
	    PHSolidStateStruct m = new PHSolidStateStruct();
	    m.ApplyFrom(r, true);
	    return m;
	}
    }
    public partial class PHSolidDesc : PHSolidState {
	public PHSolidDesc() { _thisArray[0] = SprExport.Spr_new_PHSolidDesc(); _flag = true; }
	public PHSolidDesc(IntPtr ptr) : base(ptr) {}
	public PHSolidDesc(IntPtr ptr, bool flag) : base(ptr, flag) {}
	~PHSolidDesc() { if (_flag) { SprExport.Spr_delete_PHSolidDesc(_thisArray[0]); _flag = false; } }
	public double mass {
	    get { return SprExport.Spr_PHSolidDesc_get_mass(_thisArray[0]); }
	    set { SprExport.Spr_PHSolidDesc_set_mass(_thisArray[0], value); }
	}
	public Matrix3d inertia {
	    get { return new Matrix3d(SprExport.Spr_PHSolidDesc_addr_inertia(_thisArray[0])); }
	    set { SprExport.Spr_PHSolidDesc_set_inertia(_thisArray[0], value); }
	}
	public Vec3d center {
	    get { return new Vec3d(SprExport.Spr_PHSolidDesc_addr_center(_thisArray[0])); }
	    set { SprExport.Spr_PHSolidDesc_set_center(_thisArray[0], value); }
	}
	public bool dynamical {
	    get {
	        byte ret = (byte) SprExport.Spr_PHSolidDesc_get_dynamical(_thisArray[0]);
	        return (ret == 0) ? false : true;
	    }
	    set {
	        byte val = (byte) (value ? 1 : 0);
	        SprExport.Spr_PHSolidDesc_set_dynamical(_thisArray[0], (char) val);
	    }
	}
	public bool stationary {
	    get {
	        byte ret = (byte) SprExport.Spr_PHSolidDesc_get_stationary(_thisArray[0]);
	        return (ret == 0) ? false : true;
	    }
	    set {
	        byte val = (byte) (value ? 1 : 0);
	        SprExport.Spr_PHSolidDesc_set_stationary(_thisArray[0], (char) val);
	    }
	}
	public void Init() {
	    SprExport.Spr_PHSolidDesc_Init((IntPtr) _thisArray[0]);
	}
    }
    [System.Serializable]
    public class PHSolidDescStruct : PHSolidStateStruct {
        public PHSolidDescStruct() {
            PHSolidDesc desc = new PHSolidDesc();
            ApplyFrom(desc, false);
        }
	public double mass;
	public Matrix3dStruct inertia;
	public Vec3dStruct center;
	public bool dynamical;
	public bool stationary;
	public void ApplyTo(PHSolidDesc r, bool apply_to_base_class = false) {
		r.mass = mass;
		r.inertia = inertia;
		r.center = center;
		r.dynamical = dynamical;
		r.stationary = stationary;
	}
	public void ApplyFrom(PHSolidDesc r, bool apply_to_base_class = false) {
		mass = r.mass;
		inertia = r.inertia;
		center = r.center;
		dynamical = r.dynamical;
		stationary = r.stationary;
	}
	public static implicit operator PHSolidDesc(PHSolidDescStruct m) {
	    PHSolidDesc r = new PHSolidDesc();
	    m.ApplyTo(r, true);
	    return r;
	}
	public static implicit operator PHSolidDescStruct(PHSolidDesc r) {
	    PHSolidDescStruct m = new PHSolidDescStruct();
	    m.ApplyFrom(r, true);
	    return m;
	}
    }
    public partial class PHCollisionListener : CsObject {
	public PHCollisionListener() { _thisArray[0] = SprExport.Spr_new_PHCollisionListener(); _flag = true; }
	public PHCollisionListener(IntPtr ptr) : base(ptr) {}
	public PHCollisionListener(IntPtr ptr, bool flag) : base(ptr, flag) {}
	~PHCollisionListener() { if (_flag) { SprExport.Spr_delete_PHCollisionListener(_thisArray[0]); _flag = false; } }
	public void OnDetect(PHSolidPairIf sop, CDShapePairIf shp, uint ct, double dt) {
	    SprExport.Spr_PHCollisionListener_OnDetect((IntPtr) _thisArray[0], (IntPtr) sop, (IntPtr) shp, (uint) ct, (double) dt);
	}
	public void OnContDetect(PHSolidPairIf sop, CDShapePairIf shp, uint ct, double dt) {
	    SprExport.Spr_PHCollisionListener_OnContDetect((IntPtr) _thisArray[0], (IntPtr) sop, (IntPtr) shp, (uint) ct, (double) dt);
	}
    }
    public partial class PHHapticPointerDesc : CsObject {
	public PHHapticPointerDesc() { _thisArray[0] = SprExport.Spr_new_PHHapticPointerDesc(); _flag = true; }
	public PHHapticPointerDesc(IntPtr ptr) : base(ptr) {}
	public PHHapticPointerDesc(IntPtr ptr, bool flag) : base(ptr, flag) {}
	~PHHapticPointerDesc() { if (_flag) { SprExport.Spr_delete_PHHapticPointerDesc(_thisArray[0]); _flag = false; } }
	public HapticRenderMode renderMode {
	    get { return (HapticRenderMode) SprExport.Spr_PHHapticPointerDesc_get_renderMode(_thisArray[0]); }
	    set { SprExport.Spr_PHHapticPointerDesc_set_renderMode(_thisArray[0], (int) value); }
	}
	public enum HapticRenderMode : int {
	    PENALTY = 0, CONSTRAINT = PENALTY + 1, DYNAMIC_PROXY = CONSTRAINT + 1
	}
    }
    [System.Serializable]
    public class PHHapticPointerDescStruct : CsObject {
        public PHHapticPointerDescStruct() {
            PHHapticPointerDesc desc = new PHHapticPointerDesc();
            ApplyFrom(desc, false);
        }
	public PHHapticPointerDesc.HapticRenderMode renderMode;
	public void ApplyTo(PHHapticPointerDesc r, bool apply_to_base_class = false) {
		r.renderMode = renderMode;
	}
	public void ApplyFrom(PHHapticPointerDesc r, bool apply_to_base_class = false) {
		renderMode = r.renderMode;
	}
	public static implicit operator PHHapticPointerDesc(PHHapticPointerDescStruct m) {
	    PHHapticPointerDesc r = new PHHapticPointerDesc();
	    m.ApplyTo(r, true);
	    return r;
	}
	public static implicit operator PHHapticPointerDescStruct(PHHapticPointerDesc r) {
	    PHHapticPointerDescStruct m = new PHHapticPointerDescStruct();
	    m.ApplyFrom(r, true);
	    return m;
	}
    }
    public partial class PHHapticEngineDesc : CsObject {
	public PHHapticEngineDesc() { _thisArray[0] = SprExport.Spr_new_PHHapticEngineDesc(); _flag = true; }
	public PHHapticEngineDesc(IntPtr ptr) : base(ptr) {}
	public PHHapticEngineDesc(IntPtr ptr, bool flag) : base(ptr, flag) {}
	~PHHapticEngineDesc() { if (_flag) { SprExport.Spr_delete_PHHapticEngineDesc(_thisArray[0]); _flag = false; } }
	public enum HapticStepMode : int {
	    SINGLE_THREAD, MULTI_THREAD = SINGLE_THREAD + 1, LOCAL_DYNAMICS = MULTI_THREAD + 1
	}
    }
    [System.Serializable]
    public class PHHapticEngineDescStruct : CsObject {
        public PHHapticEngineDescStruct() {
            PHHapticEngineDesc desc = new PHHapticEngineDesc();
            ApplyFrom(desc, false);
        }
	public void ApplyTo(PHHapticEngineDesc r, bool apply_to_base_class = false) {
	}
	public void ApplyFrom(PHHapticEngineDesc r, bool apply_to_base_class = false) {
	}
	public static implicit operator PHHapticEngineDesc(PHHapticEngineDescStruct m) {
	    PHHapticEngineDesc r = new PHHapticEngineDesc();
	    m.ApplyTo(r, true);
	    return r;
	}
	public static implicit operator PHHapticEngineDescStruct(PHHapticEngineDesc r) {
	    PHHapticEngineDescStruct m = new PHHapticEngineDescStruct();
	    m.ApplyFrom(r, true);
	    return m;
	}
    }
    public partial class PHIKEndEffectorState : CsObject {
	public PHIKEndEffectorState() { _thisArray[0] = SprExport.Spr_new_PHIKEndEffectorState(); _flag = true; }
	public PHIKEndEffectorState(IntPtr ptr) : base(ptr) {}
	public PHIKEndEffectorState(IntPtr ptr, bool flag) : base(ptr, flag) {}
	~PHIKEndEffectorState() { if (_flag) { SprExport.Spr_delete_PHIKEndEffectorState(_thisArray[0]); _flag = false; } }
	public Posed solidTempPose {
	    get { return new Posed(SprExport.Spr_PHIKEndEffectorState_addr_solidTempPose(_thisArray[0])); }
	    set { SprExport.Spr_PHIKEndEffectorState_set_solidTempPose(_thisArray[0], value); }
	}
    }
    [System.Serializable]
    public class PHIKEndEffectorStateStruct : CsObject {
        public PHIKEndEffectorStateStruct() {
            PHIKEndEffectorState desc = new PHIKEndEffectorState();
            ApplyFrom(desc, false);
        }
	public PosedStruct solidTempPose;
	public void ApplyTo(PHIKEndEffectorState r, bool apply_to_base_class = false) {
		r.solidTempPose = solidTempPose;
	}
	public void ApplyFrom(PHIKEndEffectorState r, bool apply_to_base_class = false) {
		solidTempPose = r.solidTempPose;
	}
	public static implicit operator PHIKEndEffectorState(PHIKEndEffectorStateStruct m) {
	    PHIKEndEffectorState r = new PHIKEndEffectorState();
	    m.ApplyTo(r, true);
	    return r;
	}
	public static implicit operator PHIKEndEffectorStateStruct(PHIKEndEffectorState r) {
	    PHIKEndEffectorStateStruct m = new PHIKEndEffectorStateStruct();
	    m.ApplyFrom(r, true);
	    return m;
	}
    }
    public partial class PHIKEndEffectorDesc : PHIKEndEffectorState {
	public PHIKEndEffectorDesc() { _thisArray[0] = SprExport.Spr_new_PHIKEndEffectorDesc(); _flag = true; }
	public PHIKEndEffectorDesc(IntPtr ptr) : base(ptr) {}
	public PHIKEndEffectorDesc(IntPtr ptr, bool flag) : base(ptr, flag) {}
	~PHIKEndEffectorDesc() { if (_flag) { SprExport.Spr_delete_PHIKEndEffectorDesc(_thisArray[0]); _flag = false; } }
	public bool bEnabled {
	    get {
	        byte ret = (byte) SprExport.Spr_PHIKEndEffectorDesc_get_bEnabled(_thisArray[0]);
	        return (ret == 0) ? false : true;
	    }
	    set {
	        byte val = (byte) (value ? 1 : 0);
	        SprExport.Spr_PHIKEndEffectorDesc_set_bEnabled(_thisArray[0], (char) val);
	    }
	}
	public bool bPosition {
	    get {
	        byte ret = (byte) SprExport.Spr_PHIKEndEffectorDesc_get_bPosition(_thisArray[0]);
	        return (ret == 0) ? false : true;
	    }
	    set {
	        byte val = (byte) (value ? 1 : 0);
	        SprExport.Spr_PHIKEndEffectorDesc_set_bPosition(_thisArray[0], (char) val);
	    }
	}
	public bool bOrientation {
	    get {
	        byte ret = (byte) SprExport.Spr_PHIKEndEffectorDesc_get_bOrientation(_thisArray[0]);
	        return (ret == 0) ? false : true;
	    }
	    set {
	        byte val = (byte) (value ? 1 : 0);
	        SprExport.Spr_PHIKEndEffectorDesc_set_bOrientation(_thisArray[0], (char) val);
	    }
	}
	public int oriCtlMode {
	    get { return SprExport.Spr_PHIKEndEffectorDesc_get_oriCtlMode(_thisArray[0]); }
	    set { SprExport.Spr_PHIKEndEffectorDesc_set_oriCtlMode(_thisArray[0], value); }
	}
	public bool bForce {
	    get {
	        byte ret = (byte) SprExport.Spr_PHIKEndEffectorDesc_get_bForce(_thisArray[0]);
	        return (ret == 0) ? false : true;
	    }
	    set {
	        byte val = (byte) (value ? 1 : 0);
	        SprExport.Spr_PHIKEndEffectorDesc_set_bForce(_thisArray[0], (char) val);
	    }
	}
	public bool bTorque {
	    get {
	        byte ret = (byte) SprExport.Spr_PHIKEndEffectorDesc_get_bTorque(_thisArray[0]);
	        return (ret == 0) ? false : true;
	    }
	    set {
	        byte val = (byte) (value ? 1 : 0);
	        SprExport.Spr_PHIKEndEffectorDesc_set_bTorque(_thisArray[0], (char) val);
	    }
	}
	public double positionPriority {
	    get { return SprExport.Spr_PHIKEndEffectorDesc_get_positionPriority(_thisArray[0]); }
	    set { SprExport.Spr_PHIKEndEffectorDesc_set_positionPriority(_thisArray[0], value); }
	}
	public double orientationPriority {
	    get { return SprExport.Spr_PHIKEndEffectorDesc_get_orientationPriority(_thisArray[0]); }
	    set { SprExport.Spr_PHIKEndEffectorDesc_set_orientationPriority(_thisArray[0], value); }
	}
	public double forcePriority {
	    get { return SprExport.Spr_PHIKEndEffectorDesc_get_forcePriority(_thisArray[0]); }
	    set { SprExport.Spr_PHIKEndEffectorDesc_set_forcePriority(_thisArray[0], value); }
	}
	public double torquePriority {
	    get { return SprExport.Spr_PHIKEndEffectorDesc_get_torquePriority(_thisArray[0]); }
	    set { SprExport.Spr_PHIKEndEffectorDesc_set_torquePriority(_thisArray[0], value); }
	}
	public Vec3d targetPosition {
	    get { return new Vec3d(SprExport.Spr_PHIKEndEffectorDesc_addr_targetPosition(_thisArray[0])); }
	    set { SprExport.Spr_PHIKEndEffectorDesc_set_targetPosition(_thisArray[0], value); }
	}
	public Vec3d targetVelocity {
	    get { return new Vec3d(SprExport.Spr_PHIKEndEffectorDesc_addr_targetVelocity(_thisArray[0])); }
	    set { SprExport.Spr_PHIKEndEffectorDesc_set_targetVelocity(_thisArray[0], value); }
	}
	public Vec3d targetLocalPosition {
	    get { return new Vec3d(SprExport.Spr_PHIKEndEffectorDesc_addr_targetLocalPosition(_thisArray[0])); }
	    set { SprExport.Spr_PHIKEndEffectorDesc_set_targetLocalPosition(_thisArray[0], value); }
	}
	public Vec3d targetLocalDirection {
	    get { return new Vec3d(SprExport.Spr_PHIKEndEffectorDesc_addr_targetLocalDirection(_thisArray[0])); }
	    set { SprExport.Spr_PHIKEndEffectorDesc_set_targetLocalDirection(_thisArray[0], value); }
	}
	public Quaterniond targetOrientation {
	    get { return new Quaterniond(SprExport.Spr_PHIKEndEffectorDesc_addr_targetOrientation(_thisArray[0])); }
	    set { SprExport.Spr_PHIKEndEffectorDesc_set_targetOrientation(_thisArray[0], value); }
	}
	public Vec3d targetDirection {
	    get { return new Vec3d(SprExport.Spr_PHIKEndEffectorDesc_addr_targetDirection(_thisArray[0])); }
	    set { SprExport.Spr_PHIKEndEffectorDesc_set_targetDirection(_thisArray[0], value); }
	}
	public Vec3d targetLookat {
	    get { return new Vec3d(SprExport.Spr_PHIKEndEffectorDesc_addr_targetLookat(_thisArray[0])); }
	    set { SprExport.Spr_PHIKEndEffectorDesc_set_targetLookat(_thisArray[0], value); }
	}
	public Vec3d targetAngVel {
	    get { return new Vec3d(SprExport.Spr_PHIKEndEffectorDesc_addr_targetAngVel(_thisArray[0])); }
	    set { SprExport.Spr_PHIKEndEffectorDesc_set_targetAngVel(_thisArray[0], value); }
	}
	public Vec3d targetForce {
	    get { return new Vec3d(SprExport.Spr_PHIKEndEffectorDesc_addr_targetForce(_thisArray[0])); }
	    set { SprExport.Spr_PHIKEndEffectorDesc_set_targetForce(_thisArray[0], value); }
	}
	public Vec3d targetForceWorkingPoint {
	    get { return new Vec3d(SprExport.Spr_PHIKEndEffectorDesc_addr_targetForceWorkingPoint(_thisArray[0])); }
	    set { SprExport.Spr_PHIKEndEffectorDesc_set_targetForceWorkingPoint(_thisArray[0], value); }
	}
	public Vec3d targetTorque {
	    get { return new Vec3d(SprExport.Spr_PHIKEndEffectorDesc_addr_targetTorque(_thisArray[0])); }
	    set { SprExport.Spr_PHIKEndEffectorDesc_set_targetTorque(_thisArray[0], value); }
	}
	public enum OriCtlMode : int {
	    MODE_QUATERNION = 0, MODE_DIRECTION = MODE_QUATERNION + 1, MODE_LOOKAT = MODE_DIRECTION + 1
	}
    }
    [System.Serializable]
    public class PHIKEndEffectorDescStruct : PHIKEndEffectorStateStruct {
        public PHIKEndEffectorDescStruct() {
            PHIKEndEffectorDesc desc = new PHIKEndEffectorDesc();
            ApplyFrom(desc, false);
        }
	public bool bEnabled;
	public bool bPosition;
	public bool bOrientation;
	public int oriCtlMode;
	public bool bForce;
	public bool bTorque;
	public double positionPriority;
	public double orientationPriority;
	public double forcePriority;
	public double torquePriority;
	public Vec3dStruct targetPosition;
	public Vec3dStruct targetVelocity;
	public Vec3dStruct targetLocalPosition;
	public Vec3dStruct targetLocalDirection;
	public QuaterniondStruct targetOrientation;
	public Vec3dStruct targetDirection;
	public Vec3dStruct targetLookat;
	public Vec3dStruct targetAngVel;
	public Vec3dStruct targetForce;
	public Vec3dStruct targetForceWorkingPoint;
	public Vec3dStruct targetTorque;
	public void ApplyTo(PHIKEndEffectorDesc r, bool apply_to_base_class = false) {
		r.bEnabled = bEnabled;
		r.bPosition = bPosition;
		r.bOrientation = bOrientation;
		r.oriCtlMode = oriCtlMode;
		r.bForce = bForce;
		r.bTorque = bTorque;
		r.positionPriority = positionPriority;
		r.orientationPriority = orientationPriority;
		r.forcePriority = forcePriority;
		r.torquePriority = torquePriority;
		r.targetPosition = targetPosition;
		r.targetVelocity = targetVelocity;
		r.targetLocalPosition = targetLocalPosition;
		r.targetLocalDirection = targetLocalDirection;
		r.targetOrientation = targetOrientation;
		r.targetDirection = targetDirection;
		r.targetLookat = targetLookat;
		r.targetAngVel = targetAngVel;
		r.targetForce = targetForce;
		r.targetForceWorkingPoint = targetForceWorkingPoint;
		r.targetTorque = targetTorque;
	}
	public void ApplyFrom(PHIKEndEffectorDesc r, bool apply_to_base_class = false) {
		bEnabled = r.bEnabled;
		bPosition = r.bPosition;
		bOrientation = r.bOrientation;
		oriCtlMode = r.oriCtlMode;
		bForce = r.bForce;
		bTorque = r.bTorque;
		positionPriority = r.positionPriority;
		orientationPriority = r.orientationPriority;
		forcePriority = r.forcePriority;
		torquePriority = r.torquePriority;
		targetPosition = r.targetPosition;
		targetVelocity = r.targetVelocity;
		targetLocalPosition = r.targetLocalPosition;
		targetLocalDirection = r.targetLocalDirection;
		targetOrientation = r.targetOrientation;
		targetDirection = r.targetDirection;
		targetLookat = r.targetLookat;
		targetAngVel = r.targetAngVel;
		targetForce = r.targetForce;
		targetForceWorkingPoint = r.targetForceWorkingPoint;
		targetTorque = r.targetTorque;
	}
	public static implicit operator PHIKEndEffectorDesc(PHIKEndEffectorDescStruct m) {
	    PHIKEndEffectorDesc r = new PHIKEndEffectorDesc();
	    m.ApplyTo(r, true);
	    return r;
	}
	public static implicit operator PHIKEndEffectorDescStruct(PHIKEndEffectorDesc r) {
	    PHIKEndEffectorDescStruct m = new PHIKEndEffectorDescStruct();
	    m.ApplyFrom(r, true);
	    return m;
	}
    }
    public partial class PHIKActuatorState : CsObject {
	public PHIKActuatorState() { _thisArray[0] = SprExport.Spr_new_PHIKActuatorState(); _flag = true; }
	public PHIKActuatorState(IntPtr ptr) : base(ptr) {}
	public PHIKActuatorState(IntPtr ptr, bool flag) : base(ptr, flag) {}
	~PHIKActuatorState() { if (_flag) { SprExport.Spr_delete_PHIKActuatorState(_thisArray[0]); _flag = false; } }
	public Posed solidTempPose {
	    get { return new Posed(SprExport.Spr_PHIKActuatorState_addr_solidTempPose(_thisArray[0])); }
	    set { SprExport.Spr_PHIKActuatorState_set_solidTempPose(_thisArray[0], value); }
	}
	public Quaterniond jointTempOri {
	    get { return new Quaterniond(SprExport.Spr_PHIKActuatorState_addr_jointTempOri(_thisArray[0])); }
	    set { SprExport.Spr_PHIKActuatorState_set_jointTempOri(_thisArray[0], value); }
	}
	public Vec3d jointTempOriIntp {
	    get { return new Vec3d(SprExport.Spr_PHIKActuatorState_addr_jointTempOriIntp(_thisArray[0])); }
	    set { SprExport.Spr_PHIKActuatorState_set_jointTempOriIntp(_thisArray[0], value); }
	}
	public double jointTempAngle {
	    get { return SprExport.Spr_PHIKActuatorState_get_jointTempAngle(_thisArray[0]); }
	    set { SprExport.Spr_PHIKActuatorState_set_jointTempAngle(_thisArray[0], value); }
	}
	public double jointTempAngleIntp {
	    get { return SprExport.Spr_PHIKActuatorState_get_jointTempAngleIntp(_thisArray[0]); }
	    set { SprExport.Spr_PHIKActuatorState_set_jointTempAngleIntp(_thisArray[0], value); }
	}
	public Posed solidPullbackPose {
	    get { return new Posed(SprExport.Spr_PHIKActuatorState_addr_solidPullbackPose(_thisArray[0])); }
	    set { SprExport.Spr_PHIKActuatorState_set_solidPullbackPose(_thisArray[0], value); }
	}
	public Posed jointTempPose {
	    get { return new Posed(SprExport.Spr_PHIKActuatorState_addr_jointTempPose(_thisArray[0])); }
	    set { SprExport.Spr_PHIKActuatorState_set_jointTempPose(_thisArray[0], value); }
	}
    }
    [System.Serializable]
    public class PHIKActuatorStateStruct : CsObject {
        public PHIKActuatorStateStruct() {
            PHIKActuatorState desc = new PHIKActuatorState();
            ApplyFrom(desc, false);
        }
	public PosedStruct solidTempPose;
	public QuaterniondStruct jointTempOri;
	public Vec3dStruct jointTempOriIntp;
	public double jointTempAngle;
	public double jointTempAngleIntp;
	public PosedStruct solidPullbackPose;
	public PosedStruct jointTempPose;
	public void ApplyTo(PHIKActuatorState r, bool apply_to_base_class = false) {
		r.solidTempPose = solidTempPose;
		r.jointTempOri = jointTempOri;
		r.jointTempOriIntp = jointTempOriIntp;
		r.jointTempAngle = jointTempAngle;
		r.jointTempAngleIntp = jointTempAngleIntp;
		r.solidPullbackPose = solidPullbackPose;
		r.jointTempPose = jointTempPose;
	}
	public void ApplyFrom(PHIKActuatorState r, bool apply_to_base_class = false) {
		solidTempPose = r.solidTempPose;
		jointTempOri = r.jointTempOri;
		jointTempOriIntp = r.jointTempOriIntp;
		jointTempAngle = r.jointTempAngle;
		jointTempAngleIntp = r.jointTempAngleIntp;
		solidPullbackPose = r.solidPullbackPose;
		jointTempPose = r.jointTempPose;
	}
	public static implicit operator PHIKActuatorState(PHIKActuatorStateStruct m) {
	    PHIKActuatorState r = new PHIKActuatorState();
	    m.ApplyTo(r, true);
	    return r;
	}
	public static implicit operator PHIKActuatorStateStruct(PHIKActuatorState r) {
	    PHIKActuatorStateStruct m = new PHIKActuatorStateStruct();
	    m.ApplyFrom(r, true);
	    return m;
	}
    }
    public partial class PHIKActuatorDesc : PHIKActuatorState {
	public PHIKActuatorDesc() { _thisArray[0] = SprExport.Spr_new_PHIKActuatorDesc(); _flag = true; }
	public PHIKActuatorDesc(IntPtr ptr) : base(ptr) {}
	public PHIKActuatorDesc(IntPtr ptr, bool flag) : base(ptr, flag) {}
	~PHIKActuatorDesc() { if (_flag) { SprExport.Spr_delete_PHIKActuatorDesc(_thisArray[0]); _flag = false; } }
	public bool bEnabled {
	    get {
	        byte ret = (byte) SprExport.Spr_PHIKActuatorDesc_get_bEnabled(_thisArray[0]);
	        return (ret == 0) ? false : true;
	    }
	    set {
	        byte val = (byte) (value ? 1 : 0);
	        SprExport.Spr_PHIKActuatorDesc_set_bEnabled(_thisArray[0], (char) val);
	    }
	}
	public float bias {
	    get { return SprExport.Spr_PHIKActuatorDesc_get_bias(_thisArray[0]); }
	    set { SprExport.Spr_PHIKActuatorDesc_set_bias(_thisArray[0], value); }
	}
	public double pullbackRate {
	    get { return SprExport.Spr_PHIKActuatorDesc_get_pullbackRate(_thisArray[0]); }
	    set { SprExport.Spr_PHIKActuatorDesc_set_pullbackRate(_thisArray[0], value); }
	}
    }
    [System.Serializable]
    public class PHIKActuatorDescStruct : PHIKActuatorStateStruct {
        public PHIKActuatorDescStruct() {
            PHIKActuatorDesc desc = new PHIKActuatorDesc();
            ApplyFrom(desc, false);
        }
	public bool bEnabled;
	public float bias;
	public double pullbackRate;
	public void ApplyTo(PHIKActuatorDesc r, bool apply_to_base_class = false) {
		r.bEnabled = bEnabled;
		r.bias = bias;
		r.pullbackRate = pullbackRate;
	}
	public void ApplyFrom(PHIKActuatorDesc r, bool apply_to_base_class = false) {
		bEnabled = r.bEnabled;
		bias = r.bias;
		pullbackRate = r.pullbackRate;
	}
	public static implicit operator PHIKActuatorDesc(PHIKActuatorDescStruct m) {
	    PHIKActuatorDesc r = new PHIKActuatorDesc();
	    m.ApplyTo(r, true);
	    return r;
	}
	public static implicit operator PHIKActuatorDescStruct(PHIKActuatorDesc r) {
	    PHIKActuatorDescStruct m = new PHIKActuatorDescStruct();
	    m.ApplyFrom(r, true);
	    return m;
	}
    }
    public partial class PHIKBallActuatorDesc : PHIKActuatorDesc {
	public PHIKBallActuatorDesc() { _thisArray[0] = SprExport.Spr_new_PHIKBallActuatorDesc(); _flag = true; }
	public PHIKBallActuatorDesc(IntPtr ptr) : base(ptr) {}
	public PHIKBallActuatorDesc(IntPtr ptr, bool flag) : base(ptr, flag) {}
	~PHIKBallActuatorDesc() { if (_flag) { SprExport.Spr_delete_PHIKBallActuatorDesc(_thisArray[0]); _flag = false; } }
	public Quaterniond pullbackTarget {
	    get { return new Quaterniond(SprExport.Spr_PHIKBallActuatorDesc_addr_pullbackTarget(_thisArray[0])); }
	    set { SprExport.Spr_PHIKBallActuatorDesc_set_pullbackTarget(_thisArray[0], value); }
	}
    }
    [System.Serializable]
    public class PHIKBallActuatorDescStruct : PHIKActuatorDescStruct {
        public PHIKBallActuatorDescStruct() {
            PHIKBallActuatorDesc desc = new PHIKBallActuatorDesc();
            ApplyFrom(desc, true);
        }
	public QuaterniondStruct pullbackTarget;
	public void ApplyTo(PHIKBallActuatorDesc r, bool apply_to_base_class = false) {
		r.pullbackTarget = pullbackTarget;
		if (apply_to_base_class) {
		    base.ApplyTo(r, apply_to_base_class);
		}
	}
	public void ApplyFrom(PHIKBallActuatorDesc r, bool apply_to_base_class = false) {
		pullbackTarget = r.pullbackTarget;
		if (apply_to_base_class) {
		    base.ApplyFrom(r, apply_to_base_class);
		}
	}
	public static implicit operator PHIKBallActuatorDesc(PHIKBallActuatorDescStruct m) {
	    PHIKBallActuatorDesc r = new PHIKBallActuatorDesc();
	    m.ApplyTo(r, true);
	    return r;
	}
	public static implicit operator PHIKBallActuatorDescStruct(PHIKBallActuatorDesc r) {
	    PHIKBallActuatorDescStruct m = new PHIKBallActuatorDescStruct();
	    m.ApplyFrom(r, true);
	    return m;
	}
    }
    public partial class PHIKHingeActuatorDesc : PHIKActuatorDesc {
	public PHIKHingeActuatorDesc() { _thisArray[0] = SprExport.Spr_new_PHIKHingeActuatorDesc(); _flag = true; }
	public PHIKHingeActuatorDesc(IntPtr ptr) : base(ptr) {}
	public PHIKHingeActuatorDesc(IntPtr ptr, bool flag) : base(ptr, flag) {}
	~PHIKHingeActuatorDesc() { if (_flag) { SprExport.Spr_delete_PHIKHingeActuatorDesc(_thisArray[0]); _flag = false; } }
	public double pullbackTarget {
	    get { return SprExport.Spr_PHIKHingeActuatorDesc_get_pullbackTarget(_thisArray[0]); }
	    set { SprExport.Spr_PHIKHingeActuatorDesc_set_pullbackTarget(_thisArray[0], value); }
	}
    }
    [System.Serializable]
    public class PHIKHingeActuatorDescStruct : PHIKActuatorDescStruct {
        public PHIKHingeActuatorDescStruct() {
            PHIKHingeActuatorDesc desc = new PHIKHingeActuatorDesc();
            ApplyFrom(desc, true);
        }
	public double pullbackTarget;
	public void ApplyTo(PHIKHingeActuatorDesc r, bool apply_to_base_class = false) {
		r.pullbackTarget = pullbackTarget;
		if (apply_to_base_class) {
		    base.ApplyTo(r, apply_to_base_class);
		}
	}
	public void ApplyFrom(PHIKHingeActuatorDesc r, bool apply_to_base_class = false) {
		pullbackTarget = r.pullbackTarget;
		if (apply_to_base_class) {
		    base.ApplyFrom(r, apply_to_base_class);
		}
	}
	public static implicit operator PHIKHingeActuatorDesc(PHIKHingeActuatorDescStruct m) {
	    PHIKHingeActuatorDesc r = new PHIKHingeActuatorDesc();
	    m.ApplyTo(r, true);
	    return r;
	}
	public static implicit operator PHIKHingeActuatorDescStruct(PHIKHingeActuatorDesc r) {
	    PHIKHingeActuatorDescStruct m = new PHIKHingeActuatorDescStruct();
	    m.ApplyFrom(r, true);
	    return m;
	}
    }
    public partial class PHIKSpringActuatorDesc : PHIKActuatorDesc {
	public PHIKSpringActuatorDesc() { _thisArray[0] = SprExport.Spr_new_PHIKSpringActuatorDesc(); _flag = true; }
	public PHIKSpringActuatorDesc(IntPtr ptr) : base(ptr) {}
	public PHIKSpringActuatorDesc(IntPtr ptr, bool flag) : base(ptr, flag) {}
	~PHIKSpringActuatorDesc() { if (_flag) { SprExport.Spr_delete_PHIKSpringActuatorDesc(_thisArray[0]); _flag = false; } }
	public Posed pullbackTarget {
	    get { return new Posed(SprExport.Spr_PHIKSpringActuatorDesc_addr_pullbackTarget(_thisArray[0])); }
	    set { SprExport.Spr_PHIKSpringActuatorDesc_set_pullbackTarget(_thisArray[0], value); }
	}
    }
    [System.Serializable]
    public class PHIKSpringActuatorDescStruct : PHIKActuatorDescStruct {
        public PHIKSpringActuatorDescStruct() {
            PHIKSpringActuatorDesc desc = new PHIKSpringActuatorDesc();
            ApplyFrom(desc, true);
        }
	public PosedStruct pullbackTarget;
	public void ApplyTo(PHIKSpringActuatorDesc r, bool apply_to_base_class = false) {
		r.pullbackTarget = pullbackTarget;
		if (apply_to_base_class) {
		    base.ApplyTo(r, apply_to_base_class);
		}
	}
	public void ApplyFrom(PHIKSpringActuatorDesc r, bool apply_to_base_class = false) {
		pullbackTarget = r.pullbackTarget;
		if (apply_to_base_class) {
		    base.ApplyFrom(r, apply_to_base_class);
		}
	}
	public static implicit operator PHIKSpringActuatorDesc(PHIKSpringActuatorDescStruct m) {
	    PHIKSpringActuatorDesc r = new PHIKSpringActuatorDesc();
	    m.ApplyTo(r, true);
	    return r;
	}
	public static implicit operator PHIKSpringActuatorDescStruct(PHIKSpringActuatorDesc r) {
	    PHIKSpringActuatorDescStruct m = new PHIKSpringActuatorDescStruct();
	    m.ApplyFrom(r, true);
	    return m;
	}
    }
    public partial class PHConstraintDesc : CsObject {
	public PHConstraintDesc() { _thisArray[0] = SprExport.Spr_new_PHConstraintDesc(); _flag = true; }
	public PHConstraintDesc(IntPtr ptr) : base(ptr) {}
	public PHConstraintDesc(IntPtr ptr, bool flag) : base(ptr, flag) {}
	~PHConstraintDesc() { if (_flag) { SprExport.Spr_delete_PHConstraintDesc(_thisArray[0]); _flag = false; } }
	public bool bEnabled {
	    get {
	        byte ret = (byte) SprExport.Spr_PHConstraintDesc_get_bEnabled(_thisArray[0]);
	        return (ret == 0) ? false : true;
	    }
	    set {
	        byte val = (byte) (value ? 1 : 0);
	        SprExport.Spr_PHConstraintDesc_set_bEnabled(_thisArray[0], (char) val);
	    }
	}
	public Posed poseSocket {
	    get { return new Posed(SprExport.Spr_PHConstraintDesc_addr_poseSocket(_thisArray[0])); }
	    set { SprExport.Spr_PHConstraintDesc_set_poseSocket(_thisArray[0], value); }
	}
	public Posed posePlug {
	    get { return new Posed(SprExport.Spr_PHConstraintDesc_addr_posePlug(_thisArray[0])); }
	    set { SprExport.Spr_PHConstraintDesc_set_posePlug(_thisArray[0], value); }
	}
    }
    [System.Serializable]
    public class PHConstraintDescStruct : CsObject {
        public PHConstraintDescStruct() {
            PHConstraintDesc desc = new PHConstraintDesc();
            ApplyFrom(desc, false);
        }
	public bool bEnabled;
	public PosedStruct poseSocket;
	public PosedStruct posePlug;
	public void ApplyTo(PHConstraintDesc r, bool apply_to_base_class = false) {
		r.bEnabled = bEnabled;
		r.poseSocket = poseSocket;
		r.posePlug = posePlug;
	}
	public void ApplyFrom(PHConstraintDesc r, bool apply_to_base_class = false) {
		bEnabled = r.bEnabled;
		poseSocket = r.poseSocket;
		posePlug = r.posePlug;
	}
	public static implicit operator PHConstraintDesc(PHConstraintDescStruct m) {
	    PHConstraintDesc r = new PHConstraintDesc();
	    m.ApplyTo(r, true);
	    return r;
	}
	public static implicit operator PHConstraintDescStruct(PHConstraintDesc r) {
	    PHConstraintDescStruct m = new PHConstraintDescStruct();
	    m.ApplyFrom(r, true);
	    return m;
	}
    }
    public partial class PHJointDesc : PHConstraintDesc {
	public PHJointDesc() { _thisArray[0] = SprExport.Spr_new_PHJointDesc(); _flag = true; }
	public PHJointDesc(IntPtr ptr) : base(ptr) {}
	public PHJointDesc(IntPtr ptr, bool flag) : base(ptr, flag) {}
	~PHJointDesc() { if (_flag) { SprExport.Spr_delete_PHJointDesc(_thisArray[0]); _flag = false; } }
	public double fMax {
	    get { return SprExport.Spr_PHJointDesc_get_fMax(_thisArray[0]); }
	    set { SprExport.Spr_PHJointDesc_set_fMax(_thisArray[0], value); }
	}
    }
    [System.Serializable]
    public class PHJointDescStruct : PHConstraintDescStruct {
        public PHJointDescStruct() {
            PHJointDesc desc = new PHJointDesc();
            ApplyFrom(desc, true);
        }
	public double fMax;
	public void ApplyTo(PHJointDesc r, bool apply_to_base_class = false) {
		r.fMax = fMax;
		if (apply_to_base_class) {
		    base.ApplyTo(r, apply_to_base_class);
		}
	}
	public void ApplyFrom(PHJointDesc r, bool apply_to_base_class = false) {
		fMax = r.fMax;
		if (apply_to_base_class) {
		    base.ApplyFrom(r, apply_to_base_class);
		}
	}
	public static implicit operator PHJointDesc(PHJointDescStruct m) {
	    PHJointDesc r = new PHJointDesc();
	    m.ApplyTo(r, true);
	    return r;
	}
	public static implicit operator PHJointDescStruct(PHJointDesc r) {
	    PHJointDescStruct m = new PHJointDescStruct();
	    m.ApplyFrom(r, true);
	    return m;
	}
    }
    public partial class PH1DJointDesc : PHJointDesc {
	public PH1DJointDesc() { _thisArray[0] = SprExport.Spr_new_PH1DJointDesc(); _flag = true; }
	public PH1DJointDesc(IntPtr ptr) : base(ptr) {}
	public PH1DJointDesc(IntPtr ptr, bool flag) : base(ptr, flag) {}
	~PH1DJointDesc() { if (_flag) { SprExport.Spr_delete_PH1DJointDesc(_thisArray[0]); _flag = false; } }
	public bool cyclic {
	    get {
	        byte ret = (byte) SprExport.Spr_PH1DJointDesc_get_cyclic(_thisArray[0]);
	        return (ret == 0) ? false : true;
	    }
	    set {
	        byte val = (byte) (value ? 1 : 0);
	        SprExport.Spr_PH1DJointDesc_set_cyclic(_thisArray[0], (char) val);
	    }
	}
	public double spring {
	    get { return SprExport.Spr_PH1DJointDesc_get_spring(_thisArray[0]); }
	    set { SprExport.Spr_PH1DJointDesc_set_spring(_thisArray[0], value); }
	}
	public double damper {
	    get { return SprExport.Spr_PH1DJointDesc_get_damper(_thisArray[0]); }
	    set { SprExport.Spr_PH1DJointDesc_set_damper(_thisArray[0], value); }
	}
	public double secondDamper {
	    get { return SprExport.Spr_PH1DJointDesc_get_secondDamper(_thisArray[0]); }
	    set { SprExport.Spr_PH1DJointDesc_set_secondDamper(_thisArray[0], value); }
	}
	public double targetPosition {
	    get { return SprExport.Spr_PH1DJointDesc_get_targetPosition(_thisArray[0]); }
	    set { SprExport.Spr_PH1DJointDesc_set_targetPosition(_thisArray[0], value); }
	}
	public double targetVelocity {
	    get { return SprExport.Spr_PH1DJointDesc_get_targetVelocity(_thisArray[0]); }
	    set { SprExport.Spr_PH1DJointDesc_set_targetVelocity(_thisArray[0], value); }
	}
	public double offsetForce {
	    get { return SprExport.Spr_PH1DJointDesc_get_offsetForce(_thisArray[0]); }
	    set { SprExport.Spr_PH1DJointDesc_set_offsetForce(_thisArray[0], value); }
	}
	public double yieldStress {
	    get { return SprExport.Spr_PH1DJointDesc_get_yieldStress(_thisArray[0]); }
	    set { SprExport.Spr_PH1DJointDesc_set_yieldStress(_thisArray[0], value); }
	}
	public double hardnessRate {
	    get { return SprExport.Spr_PH1DJointDesc_get_hardnessRate(_thisArray[0]); }
	    set { SprExport.Spr_PH1DJointDesc_set_hardnessRate(_thisArray[0], value); }
	}
	public double secondMoment {
	    get { return SprExport.Spr_PH1DJointDesc_get_secondMoment(_thisArray[0]); }
	    set { SprExport.Spr_PH1DJointDesc_set_secondMoment(_thisArray[0], value); }
	}
    }
    [System.Serializable]
    public class PH1DJointDescStruct : PHJointDescStruct {
        public PH1DJointDescStruct() {
            PH1DJointDesc desc = new PH1DJointDesc();
            ApplyFrom(desc, true);
        }
	public bool cyclic;
	public double spring;
	public double damper;
	public double secondDamper;
	public double targetPosition;
	public double targetVelocity;
	public double offsetForce;
	public double yieldStress;
	public double hardnessRate;
	public double secondMoment;
	public void ApplyTo(PH1DJointDesc r, bool apply_to_base_class = false) {
		r.cyclic = cyclic;
		r.spring = spring;
		r.damper = damper;
		r.secondDamper = secondDamper;
		r.targetPosition = targetPosition;
		r.targetVelocity = targetVelocity;
		r.offsetForce = offsetForce;
		r.yieldStress = yieldStress;
		r.hardnessRate = hardnessRate;
		r.secondMoment = secondMoment;
		if (apply_to_base_class) {
		    base.ApplyTo(r, apply_to_base_class);
		}
	}
	public void ApplyFrom(PH1DJointDesc r, bool apply_to_base_class = false) {
		cyclic = r.cyclic;
		spring = r.spring;
		damper = r.damper;
		secondDamper = r.secondDamper;
		targetPosition = r.targetPosition;
		targetVelocity = r.targetVelocity;
		offsetForce = r.offsetForce;
		yieldStress = r.yieldStress;
		hardnessRate = r.hardnessRate;
		secondMoment = r.secondMoment;
		if (apply_to_base_class) {
		    base.ApplyFrom(r, apply_to_base_class);
		}
	}
	public static implicit operator PH1DJointDesc(PH1DJointDescStruct m) {
	    PH1DJointDesc r = new PH1DJointDesc();
	    m.ApplyTo(r, true);
	    return r;
	}
	public static implicit operator PH1DJointDescStruct(PH1DJointDesc r) {
	    PH1DJointDescStruct m = new PH1DJointDescStruct();
	    m.ApplyFrom(r, true);
	    return m;
	}
    }
    public partial class PHHingeJointDesc : PH1DJointDesc {
	public PHHingeJointDesc() { _thisArray[0] = SprExport.Spr_new_PHHingeJointDesc(); _flag = true; }
	public PHHingeJointDesc(IntPtr ptr) : base(ptr) {}
	public PHHingeJointDesc(IntPtr ptr, bool flag) : base(ptr, flag) {}
	~PHHingeJointDesc() { if (_flag) { SprExport.Spr_delete_PHHingeJointDesc(_thisArray[0]); _flag = false; } }
    }
    [System.Serializable]
    public class PHHingeJointDescStruct : PH1DJointDescStruct {
        public PHHingeJointDescStruct() {
            PHHingeJointDesc desc = new PHHingeJointDesc();
            ApplyFrom(desc, true);
        }
	public void ApplyTo(PHHingeJointDesc r, bool apply_to_base_class = false) {
		if (apply_to_base_class) {
		    base.ApplyTo(r, apply_to_base_class);
		}
	}
	public void ApplyFrom(PHHingeJointDesc r, bool apply_to_base_class = false) {
		if (apply_to_base_class) {
		    base.ApplyFrom(r, apply_to_base_class);
		}
	}
	public static implicit operator PHHingeJointDesc(PHHingeJointDescStruct m) {
	    PHHingeJointDesc r = new PHHingeJointDesc();
	    m.ApplyTo(r, true);
	    return r;
	}
	public static implicit operator PHHingeJointDescStruct(PHHingeJointDesc r) {
	    PHHingeJointDescStruct m = new PHHingeJointDescStruct();
	    m.ApplyFrom(r, true);
	    return m;
	}
    }
    public partial class PHSliderJointDesc : PH1DJointDesc {
	public PHSliderJointDesc() { _thisArray[0] = SprExport.Spr_new_PHSliderJointDesc(); _flag = true; }
	public PHSliderJointDesc(IntPtr ptr) : base(ptr) {}
	public PHSliderJointDesc(IntPtr ptr, bool flag) : base(ptr, flag) {}
	~PHSliderJointDesc() { if (_flag) { SprExport.Spr_delete_PHSliderJointDesc(_thisArray[0]); _flag = false; } }
	public bool bConstraintY {
	    get {
	        byte ret = (byte) SprExport.Spr_PHSliderJointDesc_get_bConstraintY(_thisArray[0]);
	        return (ret == 0) ? false : true;
	    }
	    set {
	        byte val = (byte) (value ? 1 : 0);
	        SprExport.Spr_PHSliderJointDesc_set_bConstraintY(_thisArray[0], (char) val);
	    }
	}
	public bool bConstraintRollX {
	    get {
	        byte ret = (byte) SprExport.Spr_PHSliderJointDesc_get_bConstraintRollX(_thisArray[0]);
	        return (ret == 0) ? false : true;
	    }
	    set {
	        byte val = (byte) (value ? 1 : 0);
	        SprExport.Spr_PHSliderJointDesc_set_bConstraintRollX(_thisArray[0], (char) val);
	    }
	}
	public bool bConstraintRollZ {
	    get {
	        byte ret = (byte) SprExport.Spr_PHSliderJointDesc_get_bConstraintRollZ(_thisArray[0]);
	        return (ret == 0) ? false : true;
	    }
	    set {
	        byte val = (byte) (value ? 1 : 0);
	        SprExport.Spr_PHSliderJointDesc_set_bConstraintRollZ(_thisArray[0], (char) val);
	    }
	}
    }
    [System.Serializable]
    public class PHSliderJointDescStruct : PH1DJointDescStruct {
        public PHSliderJointDescStruct() {
            PHSliderJointDesc desc = new PHSliderJointDesc();
            ApplyFrom(desc, true);
        }
	public bool bConstraintY;
	public bool bConstraintRollX;
	public bool bConstraintRollZ;
	public void ApplyTo(PHSliderJointDesc r, bool apply_to_base_class = false) {
		r.bConstraintY = bConstraintY;
		r.bConstraintRollX = bConstraintRollX;
		r.bConstraintRollZ = bConstraintRollZ;
		if (apply_to_base_class) {
		    base.ApplyTo(r, apply_to_base_class);
		}
	}
	public void ApplyFrom(PHSliderJointDesc r, bool apply_to_base_class = false) {
		bConstraintY = r.bConstraintY;
		bConstraintRollX = r.bConstraintRollX;
		bConstraintRollZ = r.bConstraintRollZ;
		if (apply_to_base_class) {
		    base.ApplyFrom(r, apply_to_base_class);
		}
	}
	public static implicit operator PHSliderJointDesc(PHSliderJointDescStruct m) {
	    PHSliderJointDesc r = new PHSliderJointDesc();
	    m.ApplyTo(r, true);
	    return r;
	}
	public static implicit operator PHSliderJointDescStruct(PHSliderJointDesc r) {
	    PHSliderJointDescStruct m = new PHSliderJointDescStruct();
	    m.ApplyFrom(r, true);
	    return m;
	}
    }
    public partial class PHPathPoint : CsObject {
	public PHPathPoint() { _thisArray[0] = SprExport.Spr_new_PHPathPoint(); _flag = true; }
	public PHPathPoint(IntPtr ptr) : base(ptr) {}
	public PHPathPoint(IntPtr ptr, bool flag) : base(ptr, flag) {}
	public PHPathPoint(double _s, Posed _pose) { _thisArray[0] = SprExport.Spr_new_PHPathPoint_4(_s, _pose); _flag = true; }
	~PHPathPoint() { if (_flag) { SprExport.Spr_delete_PHPathPoint(_thisArray[0]); _flag = false; } }
	public double s {
	    get { return SprExport.Spr_PHPathPoint_get_s(_thisArray[0]); }
	    set { SprExport.Spr_PHPathPoint_set_s(_thisArray[0], value); }
	}
	public Posed pose {
	    get { return new Posed(SprExport.Spr_PHPathPoint_addr_pose(_thisArray[0])); }
	    set { SprExport.Spr_PHPathPoint_set_pose(_thisArray[0], value); }
	}
    }
    public partial class PHPathDesc : CsObject {
	public PHPathDesc() { _thisArray[0] = SprExport.Spr_new_PHPathDesc(); _flag = true; }
	public PHPathDesc(IntPtr ptr) : base(ptr) {}
	public PHPathDesc(IntPtr ptr, bool flag) : base(ptr, flag) {}
	~PHPathDesc() { if (_flag) { SprExport.Spr_delete_PHPathDesc(_thisArray[0]); _flag = false; } }
        public vectorwrapper_PHPathPoint points {
            get { return new vectorwrapper_PHPathPoint(SprExport.Spr_PHPathDesc_addr_points(_thisArray[0])); }
            set { SprExport.Spr_PHPathDesc_set_points(_thisArray[0], value); }
        }
	public bool bLoop {
	    get {
	        byte ret = (byte) SprExport.Spr_PHPathDesc_get_bLoop(_thisArray[0]);
	        return (ret == 0) ? false : true;
	    }
	    set {
	        byte val = (byte) (value ? 1 : 0);
	        SprExport.Spr_PHPathDesc_set_bLoop(_thisArray[0], (char) val);
	    }
	}
    }
    [System.Serializable]
    public class PHPathDescStruct : CsObject {
        public PHPathDescStruct() {
            PHPathDesc desc = new PHPathDesc();
            ApplyFrom(desc, false);
        }
	public vectorwrapper_PHPathPoint points;
	public bool bLoop;
	public void ApplyTo(PHPathDesc r, bool apply_to_base_class = false) {
		r.points = points;
		r.bLoop = bLoop;
	}
	public void ApplyFrom(PHPathDesc r, bool apply_to_base_class = false) {
		points = r.points;
		bLoop = r.bLoop;
	}
	public static implicit operator PHPathDesc(PHPathDescStruct m) {
	    PHPathDesc r = new PHPathDesc();
	    m.ApplyTo(r, true);
	    return r;
	}
	public static implicit operator PHPathDescStruct(PHPathDesc r) {
	    PHPathDescStruct m = new PHPathDescStruct();
	    m.ApplyFrom(r, true);
	    return m;
	}
    }
    public partial class PHPathJointDesc : PH1DJointDesc {
	public PHPathJointDesc() { _thisArray[0] = SprExport.Spr_new_PHPathJointDesc(); _flag = true; }
	public PHPathJointDesc(IntPtr ptr) : base(ptr) {}
	public PHPathJointDesc(IntPtr ptr, bool flag) : base(ptr, flag) {}
	~PHPathJointDesc() { if (_flag) { SprExport.Spr_delete_PHPathJointDesc(_thisArray[0]); _flag = false; } }
    }
    [System.Serializable]
    public class PHPathJointDescStruct : PH1DJointDescStruct {
        public PHPathJointDescStruct() {
            PHPathJointDesc desc = new PHPathJointDesc();
            ApplyFrom(desc, true);
        }
	public void ApplyTo(PHPathJointDesc r, bool apply_to_base_class = false) {
		if (apply_to_base_class) {
		    base.ApplyTo(r, apply_to_base_class);
		}
	}
	public void ApplyFrom(PHPathJointDesc r, bool apply_to_base_class = false) {
		if (apply_to_base_class) {
		    base.ApplyFrom(r, apply_to_base_class);
		}
	}
	public static implicit operator PHPathJointDesc(PHPathJointDescStruct m) {
	    PHPathJointDesc r = new PHPathJointDesc();
	    m.ApplyTo(r, true);
	    return r;
	}
	public static implicit operator PHPathJointDescStruct(PHPathJointDesc r) {
	    PHPathJointDescStruct m = new PHPathJointDescStruct();
	    m.ApplyFrom(r, true);
	    return m;
	}
    }
    public partial class PHGenericJointCallback : CsObject {
	public PHGenericJointCallback() { _thisArray[0] = SprExport.Spr_new_PHGenericJointCallback(); _flag = true; }
	public PHGenericJointCallback(IntPtr ptr) : base(ptr) {}
	public PHGenericJointCallback(IntPtr ptr, bool flag) : base(ptr, flag) {}
	~PHGenericJointCallback() { if (_flag) { SprExport.Spr_delete_PHGenericJointCallback(_thisArray[0]); _flag = false; } }
	public void SetParam(PHGenericJointIf jnt, string name, double value) {
            IntPtr remote2 = Marshal.StringToBSTR(name);
	    SprExport.Spr_PHGenericJointCallback_SetParam((IntPtr) _thisArray[0], (IntPtr) jnt, (IntPtr) remote2, (double) value);
            Marshal.FreeBSTR(remote2);
	}
	public bool IsCyclic(PHGenericJointIf jnt) {
	    char ret = SprExport.Spr_PHGenericJointCallback_IsCyclic((IntPtr) _thisArray[0], (IntPtr) jnt);
	    return (ret == 0) ? false : true;
	}
	public void GetMovableAxes(PHGenericJointIf jnt, int n, int indices) {
	    SprExport.Spr_PHGenericJointCallback_GetMovableAxes((IntPtr) _thisArray[0], (IntPtr) jnt, (int) n, (int) indices);
	}
	public void CompBias(PHGenericJointIf jnt, Vec3d dbv, Vec3d dbw, Vec3d prel, Quaterniond qrel, Vec3d vrel, Vec3d wrel) {
	    SprExport.Spr_PHGenericJointCallback_CompBias((IntPtr) _thisArray[0], (IntPtr) jnt, (IntPtr) dbv, (IntPtr) dbw, (IntPtr) prel, (IntPtr) qrel, (IntPtr) vrel, (IntPtr) wrel);
	}
	public void CompError(PHGenericJointIf jnt, Vec3d Bv, Vec3d Bw, Vec3d prel, Quaterniond qrel) {
	    SprExport.Spr_PHGenericJointCallback_CompError((IntPtr) _thisArray[0], (IntPtr) jnt, (IntPtr) Bv, (IntPtr) Bw, (IntPtr) prel, (IntPtr) qrel);
	}
	public void UpdateJointState(PHGenericJointIf jnt, double pos, double vel, Vec3d prel, Quaterniond qrel, Vec3d vrel, Vec3d wrel) {
	    SprExport.Spr_PHGenericJointCallback_UpdateJointState((IntPtr) _thisArray[0], (IntPtr) jnt, (double) pos, (double) vel, (IntPtr) prel, (IntPtr) qrel, (IntPtr) vrel, (IntPtr) wrel);
	}
	public void CompJointJacobian(PHGenericJointIf jnt, Vec3d Jv, Vec3d Jw, double pos) {
	    SprExport.Spr_PHGenericJointCallback_CompJointJacobian((IntPtr) _thisArray[0], (IntPtr) jnt, (IntPtr) Jv, (IntPtr) Jw, (double) pos);
	}
	public void CompJointCoriolisAccel(PHGenericJointIf jnt, Vec3d cv, Vec3d cw, double pos, double vel) {
	    SprExport.Spr_PHGenericJointCallback_CompJointCoriolisAccel((IntPtr) _thisArray[0], (IntPtr) jnt, (IntPtr) cv, (IntPtr) cw, (double) pos, (double) vel);
	}
	public void CompRelativePosition(PHGenericJointIf jnt, Vec3d prel, Quaterniond qrel, double pos) {
	    SprExport.Spr_PHGenericJointCallback_CompRelativePosition((IntPtr) _thisArray[0], (IntPtr) jnt, (IntPtr) prel, (IntPtr) qrel, (double) pos);
	}
	public void CompRelativeVelocity(PHGenericJointIf jnt, Vec3d vrel, Vec3d wrel, double pos, double vel) {
	    SprExport.Spr_PHGenericJointCallback_CompRelativeVelocity((IntPtr) _thisArray[0], (IntPtr) jnt, (IntPtr) vrel, (IntPtr) wrel, (double) pos, (double) vel);
	}
    }
    public partial class PHGenericJointDesc : PH1DJointDesc {
	public PHGenericJointDesc() { _thisArray[0] = SprExport.Spr_new_PHGenericJointDesc(); _flag = true; }
	public PHGenericJointDesc(IntPtr ptr) : base(ptr) {}
	public PHGenericJointDesc(IntPtr ptr, bool flag) : base(ptr, flag) {}
	~PHGenericJointDesc() { if (_flag) { SprExport.Spr_delete_PHGenericJointDesc(_thisArray[0]); _flag = false; } }
    }
    [System.Serializable]
    public class PHGenericJointDescStruct : PH1DJointDescStruct {
        public PHGenericJointDescStruct() {
            PHGenericJointDesc desc = new PHGenericJointDesc();
            ApplyFrom(desc, true);
        }
	public void ApplyTo(PHGenericJointDesc r, bool apply_to_base_class = false) {
		if (apply_to_base_class) {
		    base.ApplyTo(r, apply_to_base_class);
		}
	}
	public void ApplyFrom(PHGenericJointDesc r, bool apply_to_base_class = false) {
		if (apply_to_base_class) {
		    base.ApplyFrom(r, apply_to_base_class);
		}
	}
	public static implicit operator PHGenericJointDesc(PHGenericJointDescStruct m) {
	    PHGenericJointDesc r = new PHGenericJointDesc();
	    m.ApplyTo(r, true);
	    return r;
	}
	public static implicit operator PHGenericJointDescStruct(PHGenericJointDesc r) {
	    PHGenericJointDescStruct m = new PHGenericJointDescStruct();
	    m.ApplyFrom(r, true);
	    return m;
	}
    }
    public partial class PHBallJointDesc : PHJointDesc {
	public PHBallJointDesc() { _thisArray[0] = SprExport.Spr_new_PHBallJointDesc(); _flag = true; }
	public PHBallJointDesc(IntPtr ptr) : base(ptr) {}
	public PHBallJointDesc(IntPtr ptr, bool flag) : base(ptr, flag) {}
	~PHBallJointDesc() { if (_flag) { SprExport.Spr_delete_PHBallJointDesc(_thisArray[0]); _flag = false; } }
	public double spring {
	    get { return SprExport.Spr_PHBallJointDesc_get_spring(_thisArray[0]); }
	    set { SprExport.Spr_PHBallJointDesc_set_spring(_thisArray[0], value); }
	}
	public double damper {
	    get { return SprExport.Spr_PHBallJointDesc_get_damper(_thisArray[0]); }
	    set { SprExport.Spr_PHBallJointDesc_set_damper(_thisArray[0], value); }
	}
	public Vec3d secondDamper {
	    get { return new Vec3d(SprExport.Spr_PHBallJointDesc_addr_secondDamper(_thisArray[0])); }
	    set { SprExport.Spr_PHBallJointDesc_set_secondDamper(_thisArray[0], value); }
	}
	public Quaterniond targetPosition {
	    get { return new Quaterniond(SprExport.Spr_PHBallJointDesc_addr_targetPosition(_thisArray[0])); }
	    set { SprExport.Spr_PHBallJointDesc_set_targetPosition(_thisArray[0], value); }
	}
	public Vec3d targetVelocity {
	    get { return new Vec3d(SprExport.Spr_PHBallJointDesc_addr_targetVelocity(_thisArray[0])); }
	    set { SprExport.Spr_PHBallJointDesc_set_targetVelocity(_thisArray[0], value); }
	}
	public Vec3d offsetForce {
	    get { return new Vec3d(SprExport.Spr_PHBallJointDesc_addr_offsetForce(_thisArray[0])); }
	    set { SprExport.Spr_PHBallJointDesc_set_offsetForce(_thisArray[0], value); }
	}
	public double yieldStress {
	    get { return SprExport.Spr_PHBallJointDesc_get_yieldStress(_thisArray[0]); }
	    set { SprExport.Spr_PHBallJointDesc_set_yieldStress(_thisArray[0], value); }
	}
	public double hardnessRate {
	    get { return SprExport.Spr_PHBallJointDesc_get_hardnessRate(_thisArray[0]); }
	    set { SprExport.Spr_PHBallJointDesc_set_hardnessRate(_thisArray[0], value); }
	}
	public Vec3d secondMoment {
	    get { return new Vec3d(SprExport.Spr_PHBallJointDesc_addr_secondMoment(_thisArray[0])); }
	    set { SprExport.Spr_PHBallJointDesc_set_secondMoment(_thisArray[0], value); }
	}
    }
    [System.Serializable]
    public class PHBallJointDescStruct : PHJointDescStruct {
        public PHBallJointDescStruct() {
            PHBallJointDesc desc = new PHBallJointDesc();
            ApplyFrom(desc, true);
        }
	public double spring;
	public double damper;
	public Vec3dStruct secondDamper;
	public QuaterniondStruct targetPosition;
	public Vec3dStruct targetVelocity;
	public Vec3dStruct offsetForce;
	public double yieldStress;
	public double hardnessRate;
	public Vec3dStruct secondMoment;
	public void ApplyTo(PHBallJointDesc r, bool apply_to_base_class = false) {
		r.spring = spring;
		r.damper = damper;
		r.secondDamper = secondDamper;
		r.targetPosition = targetPosition;
		r.targetVelocity = targetVelocity;
		r.offsetForce = offsetForce;
		r.yieldStress = yieldStress;
		r.hardnessRate = hardnessRate;
		r.secondMoment = secondMoment;
		if (apply_to_base_class) {
		    base.ApplyTo(r, apply_to_base_class);
		}
	}
	public void ApplyFrom(PHBallJointDesc r, bool apply_to_base_class = false) {
		spring = r.spring;
		damper = r.damper;
		secondDamper = r.secondDamper;
		targetPosition = r.targetPosition;
		targetVelocity = r.targetVelocity;
		offsetForce = r.offsetForce;
		yieldStress = r.yieldStress;
		hardnessRate = r.hardnessRate;
		secondMoment = r.secondMoment;
		if (apply_to_base_class) {
		    base.ApplyFrom(r, apply_to_base_class);
		}
	}
	public static implicit operator PHBallJointDesc(PHBallJointDescStruct m) {
	    PHBallJointDesc r = new PHBallJointDesc();
	    m.ApplyTo(r, true);
	    return r;
	}
	public static implicit operator PHBallJointDescStruct(PHBallJointDesc r) {
	    PHBallJointDescStruct m = new PHBallJointDescStruct();
	    m.ApplyFrom(r, true);
	    return m;
	}
    }
    public partial class PHFixJointDesc : PHJointDesc {
	public PHFixJointDesc() { _thisArray[0] = SprExport.Spr_new_PHFixJointDesc(); _flag = true; }
	public PHFixJointDesc(IntPtr ptr) : base(ptr) {}
	public PHFixJointDesc(IntPtr ptr, bool flag) : base(ptr, flag) {}
	~PHFixJointDesc() { if (_flag) { SprExport.Spr_delete_PHFixJointDesc(_thisArray[0]); _flag = false; } }
    }
    [System.Serializable]
    public class PHFixJointDescStruct : PHJointDescStruct {
        public PHFixJointDescStruct() {
            PHFixJointDesc desc = new PHFixJointDesc();
            ApplyFrom(desc, true);
        }
	public void ApplyTo(PHFixJointDesc r, bool apply_to_base_class = false) {
		if (apply_to_base_class) {
		    base.ApplyTo(r, apply_to_base_class);
		}
	}
	public void ApplyFrom(PHFixJointDesc r, bool apply_to_base_class = false) {
		if (apply_to_base_class) {
		    base.ApplyFrom(r, apply_to_base_class);
		}
	}
	public static implicit operator PHFixJointDesc(PHFixJointDescStruct m) {
	    PHFixJointDesc r = new PHFixJointDesc();
	    m.ApplyTo(r, true);
	    return r;
	}
	public static implicit operator PHFixJointDescStruct(PHFixJointDesc r) {
	    PHFixJointDescStruct m = new PHFixJointDescStruct();
	    m.ApplyFrom(r, true);
	    return m;
	}
    }
    public partial class PHSpringDesc : PHJointDesc {
	public PHSpringDesc() { _thisArray[0] = SprExport.Spr_new_PHSpringDesc(); _flag = true; }
	public PHSpringDesc(IntPtr ptr) : base(ptr) {}
	public PHSpringDesc(IntPtr ptr, bool flag) : base(ptr, flag) {}
	~PHSpringDesc() { if (_flag) { SprExport.Spr_delete_PHSpringDesc(_thisArray[0]); _flag = false; } }
	public Vec3d targetPosition {
	    get { return new Vec3d(SprExport.Spr_PHSpringDesc_addr_targetPosition(_thisArray[0])); }
	    set { SprExport.Spr_PHSpringDesc_set_targetPosition(_thisArray[0], value); }
	}
	public Quaterniond targetOrientation {
	    get { return new Quaterniond(SprExport.Spr_PHSpringDesc_addr_targetOrientation(_thisArray[0])); }
	    set { SprExport.Spr_PHSpringDesc_set_targetOrientation(_thisArray[0], value); }
	}
	public Vec3d spring {
	    get { return new Vec3d(SprExport.Spr_PHSpringDesc_addr_spring(_thisArray[0])); }
	    set { SprExport.Spr_PHSpringDesc_set_spring(_thisArray[0], value); }
	}
	public Vec3d damper {
	    get { return new Vec3d(SprExport.Spr_PHSpringDesc_addr_damper(_thisArray[0])); }
	    set { SprExport.Spr_PHSpringDesc_set_damper(_thisArray[0], value); }
	}
	public Vec3d secondDamper {
	    get { return new Vec3d(SprExport.Spr_PHSpringDesc_addr_secondDamper(_thisArray[0])); }
	    set { SprExport.Spr_PHSpringDesc_set_secondDamper(_thisArray[0], value); }
	}
	public double springOri {
	    get { return SprExport.Spr_PHSpringDesc_get_springOri(_thisArray[0]); }
	    set { SprExport.Spr_PHSpringDesc_set_springOri(_thisArray[0], value); }
	}
	public double damperOri {
	    get { return SprExport.Spr_PHSpringDesc_get_damperOri(_thisArray[0]); }
	    set { SprExport.Spr_PHSpringDesc_set_damperOri(_thisArray[0], value); }
	}
	public double secondDamperOri {
	    get { return SprExport.Spr_PHSpringDesc_get_secondDamperOri(_thisArray[0]); }
	    set { SprExport.Spr_PHSpringDesc_set_secondDamperOri(_thisArray[0], value); }
	}
	public double yieldStress {
	    get { return SprExport.Spr_PHSpringDesc_get_yieldStress(_thisArray[0]); }
	    set { SprExport.Spr_PHSpringDesc_set_yieldStress(_thisArray[0], value); }
	}
	public double hardnessRate {
	    get { return SprExport.Spr_PHSpringDesc_get_hardnessRate(_thisArray[0]); }
	    set { SprExport.Spr_PHSpringDesc_set_hardnessRate(_thisArray[0], value); }
	}
	public Vec3d secondMoment {
	    get { return new Vec3d(SprExport.Spr_PHSpringDesc_addr_secondMoment(_thisArray[0])); }
	    set { SprExport.Spr_PHSpringDesc_set_secondMoment(_thisArray[0], value); }
	}
	public Vec6d targetVelocity {
	    get { return new Vec6d(SprExport.Spr_PHSpringDesc_addr_targetVelocity(_thisArray[0])); }
	    set { SprExport.Spr_PHSpringDesc_set_targetVelocity(_thisArray[0], value); }
	}
	public Vec6d offsetForce {
	    get { return new Vec6d(SprExport.Spr_PHSpringDesc_addr_offsetForce(_thisArray[0])); }
	    set { SprExport.Spr_PHSpringDesc_set_offsetForce(_thisArray[0], value); }
	}
    }
    [System.Serializable]
    public class PHSpringDescStruct : PHJointDescStruct {
        public PHSpringDescStruct() {
            PHSpringDesc desc = new PHSpringDesc();
            ApplyFrom(desc, true);
        }
	public Vec3dStruct targetPosition;
	public QuaterniondStruct targetOrientation;
	public Vec3dStruct spring;
	public Vec3dStruct damper;
	public Vec3dStruct secondDamper;
	public double springOri;
	public double damperOri;
	public double secondDamperOri;
	public double yieldStress;
	public double hardnessRate;
	public Vec3dStruct secondMoment;
	public Vec6dStruct targetVelocity;
	public Vec6dStruct offsetForce;
	public void ApplyTo(PHSpringDesc r, bool apply_to_base_class = false) {
		r.targetPosition = targetPosition;
		r.targetOrientation = targetOrientation;
		r.spring = spring;
		r.damper = damper;
		r.secondDamper = secondDamper;
		r.springOri = springOri;
		r.damperOri = damperOri;
		r.secondDamperOri = secondDamperOri;
		r.yieldStress = yieldStress;
		r.hardnessRate = hardnessRate;
		r.secondMoment = secondMoment;
		r.targetVelocity = targetVelocity;
		r.offsetForce = offsetForce;
		if (apply_to_base_class) {
		    base.ApplyTo(r, apply_to_base_class);
		}
	}
	public void ApplyFrom(PHSpringDesc r, bool apply_to_base_class = false) {
		targetPosition = r.targetPosition;
		targetOrientation = r.targetOrientation;
		spring = r.spring;
		damper = r.damper;
		secondDamper = r.secondDamper;
		springOri = r.springOri;
		damperOri = r.damperOri;
		secondDamperOri = r.secondDamperOri;
		yieldStress = r.yieldStress;
		hardnessRate = r.hardnessRate;
		secondMoment = r.secondMoment;
		targetVelocity = r.targetVelocity;
		offsetForce = r.offsetForce;
		if (apply_to_base_class) {
		    base.ApplyFrom(r, apply_to_base_class);
		}
	}
	public static implicit operator PHSpringDesc(PHSpringDescStruct m) {
	    PHSpringDesc r = new PHSpringDesc();
	    m.ApplyTo(r, true);
	    return r;
	}
	public static implicit operator PHSpringDescStruct(PHSpringDesc r) {
	    PHSpringDescStruct m = new PHSpringDescStruct();
	    m.ApplyFrom(r, true);
	    return m;
	}
    }
    public partial class PHMateDesc : PHJointDesc {
	public PHMateDesc() { _thisArray[0] = SprExport.Spr_new_PHMateDesc(); _flag = true; }
	public PHMateDesc(IntPtr ptr) : base(ptr) {}
	public PHMateDesc(IntPtr ptr, bool flag) : base(ptr, flag) {}
	~PHMateDesc() { if (_flag) { SprExport.Spr_delete_PHMateDesc(_thisArray[0]); _flag = false; } }
    }
    [System.Serializable]
    public class PHMateDescStruct : PHJointDescStruct {
        public PHMateDescStruct() {
            PHMateDesc desc = new PHMateDesc();
            ApplyFrom(desc, true);
        }
	public void ApplyTo(PHMateDesc r, bool apply_to_base_class = false) {
		if (apply_to_base_class) {
		    base.ApplyTo(r, apply_to_base_class);
		}
	}
	public void ApplyFrom(PHMateDesc r, bool apply_to_base_class = false) {
		if (apply_to_base_class) {
		    base.ApplyFrom(r, apply_to_base_class);
		}
	}
	public static implicit operator PHMateDesc(PHMateDescStruct m) {
	    PHMateDesc r = new PHMateDesc();
	    m.ApplyTo(r, true);
	    return r;
	}
	public static implicit operator PHMateDescStruct(PHMateDesc r) {
	    PHMateDescStruct m = new PHMateDescStruct();
	    m.ApplyFrom(r, true);
	    return m;
	}
    }
    public partial class PHPointToPointMateDesc : PHMateDesc {
	public PHPointToPointMateDesc() { _thisArray[0] = SprExport.Spr_new_PHPointToPointMateDesc(); _flag = true; }
	public PHPointToPointMateDesc(IntPtr ptr) : base(ptr) {}
	public PHPointToPointMateDesc(IntPtr ptr, bool flag) : base(ptr, flag) {}
	~PHPointToPointMateDesc() { if (_flag) { SprExport.Spr_delete_PHPointToPointMateDesc(_thisArray[0]); _flag = false; } }
    }
    [System.Serializable]
    public class PHPointToPointMateDescStruct : PHMateDescStruct {
        public PHPointToPointMateDescStruct() {
            PHPointToPointMateDesc desc = new PHPointToPointMateDesc();
            ApplyFrom(desc, true);
        }
	public void ApplyTo(PHPointToPointMateDesc r, bool apply_to_base_class = false) {
		if (apply_to_base_class) {
		    base.ApplyTo(r, apply_to_base_class);
		}
	}
	public void ApplyFrom(PHPointToPointMateDesc r, bool apply_to_base_class = false) {
		if (apply_to_base_class) {
		    base.ApplyFrom(r, apply_to_base_class);
		}
	}
	public static implicit operator PHPointToPointMateDesc(PHPointToPointMateDescStruct m) {
	    PHPointToPointMateDesc r = new PHPointToPointMateDesc();
	    m.ApplyTo(r, true);
	    return r;
	}
	public static implicit operator PHPointToPointMateDescStruct(PHPointToPointMateDesc r) {
	    PHPointToPointMateDescStruct m = new PHPointToPointMateDescStruct();
	    m.ApplyFrom(r, true);
	    return m;
	}
    }
    public partial class PHPointToLineMateDesc : PHMateDesc {
	public PHPointToLineMateDesc() { _thisArray[0] = SprExport.Spr_new_PHPointToLineMateDesc(); _flag = true; }
	public PHPointToLineMateDesc(IntPtr ptr) : base(ptr) {}
	public PHPointToLineMateDesc(IntPtr ptr, bool flag) : base(ptr, flag) {}
	~PHPointToLineMateDesc() { if (_flag) { SprExport.Spr_delete_PHPointToLineMateDesc(_thisArray[0]); _flag = false; } }
    }
    [System.Serializable]
    public class PHPointToLineMateDescStruct : PHMateDescStruct {
        public PHPointToLineMateDescStruct() {
            PHPointToLineMateDesc desc = new PHPointToLineMateDesc();
            ApplyFrom(desc, true);
        }
	public void ApplyTo(PHPointToLineMateDesc r, bool apply_to_base_class = false) {
		if (apply_to_base_class) {
		    base.ApplyTo(r, apply_to_base_class);
		}
	}
	public void ApplyFrom(PHPointToLineMateDesc r, bool apply_to_base_class = false) {
		if (apply_to_base_class) {
		    base.ApplyFrom(r, apply_to_base_class);
		}
	}
	public static implicit operator PHPointToLineMateDesc(PHPointToLineMateDescStruct m) {
	    PHPointToLineMateDesc r = new PHPointToLineMateDesc();
	    m.ApplyTo(r, true);
	    return r;
	}
	public static implicit operator PHPointToLineMateDescStruct(PHPointToLineMateDesc r) {
	    PHPointToLineMateDescStruct m = new PHPointToLineMateDescStruct();
	    m.ApplyFrom(r, true);
	    return m;
	}
    }
    public partial class PHPointToPlaneMateDesc : PHMateDesc {
	public PHPointToPlaneMateDesc() { _thisArray[0] = SprExport.Spr_new_PHPointToPlaneMateDesc(); _flag = true; }
	public PHPointToPlaneMateDesc(IntPtr ptr) : base(ptr) {}
	public PHPointToPlaneMateDesc(IntPtr ptr, bool flag) : base(ptr, flag) {}
	~PHPointToPlaneMateDesc() { if (_flag) { SprExport.Spr_delete_PHPointToPlaneMateDesc(_thisArray[0]); _flag = false; } }
	public Vec2d range {
	    get { return new Vec2d(SprExport.Spr_PHPointToPlaneMateDesc_addr_range(_thisArray[0])); }
	    set { SprExport.Spr_PHPointToPlaneMateDesc_set_range(_thisArray[0], value); }
	}
    }
    [System.Serializable]
    public class PHPointToPlaneMateDescStruct : PHMateDescStruct {
        public PHPointToPlaneMateDescStruct() {
            PHPointToPlaneMateDesc desc = new PHPointToPlaneMateDesc();
            ApplyFrom(desc, true);
        }
	public Vec2dStruct range;
	public void ApplyTo(PHPointToPlaneMateDesc r, bool apply_to_base_class = false) {
		r.range = range;
		if (apply_to_base_class) {
		    base.ApplyTo(r, apply_to_base_class);
		}
	}
	public void ApplyFrom(PHPointToPlaneMateDesc r, bool apply_to_base_class = false) {
		range = r.range;
		if (apply_to_base_class) {
		    base.ApplyFrom(r, apply_to_base_class);
		}
	}
	public static implicit operator PHPointToPlaneMateDesc(PHPointToPlaneMateDescStruct m) {
	    PHPointToPlaneMateDesc r = new PHPointToPlaneMateDesc();
	    m.ApplyTo(r, true);
	    return r;
	}
	public static implicit operator PHPointToPlaneMateDescStruct(PHPointToPlaneMateDesc r) {
	    PHPointToPlaneMateDescStruct m = new PHPointToPlaneMateDescStruct();
	    m.ApplyFrom(r, true);
	    return m;
	}
    }
    public partial class PHLineToLineMateDesc : PHMateDesc {
	public PHLineToLineMateDesc() { _thisArray[0] = SprExport.Spr_new_PHLineToLineMateDesc(); _flag = true; }
	public PHLineToLineMateDesc(IntPtr ptr) : base(ptr) {}
	public PHLineToLineMateDesc(IntPtr ptr, bool flag) : base(ptr, flag) {}
	~PHLineToLineMateDesc() { if (_flag) { SprExport.Spr_delete_PHLineToLineMateDesc(_thisArray[0]); _flag = false; } }
    }
    [System.Serializable]
    public class PHLineToLineMateDescStruct : PHMateDescStruct {
        public PHLineToLineMateDescStruct() {
            PHLineToLineMateDesc desc = new PHLineToLineMateDesc();
            ApplyFrom(desc, true);
        }
	public void ApplyTo(PHLineToLineMateDesc r, bool apply_to_base_class = false) {
		if (apply_to_base_class) {
		    base.ApplyTo(r, apply_to_base_class);
		}
	}
	public void ApplyFrom(PHLineToLineMateDesc r, bool apply_to_base_class = false) {
		if (apply_to_base_class) {
		    base.ApplyFrom(r, apply_to_base_class);
		}
	}
	public static implicit operator PHLineToLineMateDesc(PHLineToLineMateDescStruct m) {
	    PHLineToLineMateDesc r = new PHLineToLineMateDesc();
	    m.ApplyTo(r, true);
	    return r;
	}
	public static implicit operator PHLineToLineMateDescStruct(PHLineToLineMateDesc r) {
	    PHLineToLineMateDescStruct m = new PHLineToLineMateDescStruct();
	    m.ApplyFrom(r, true);
	    return m;
	}
    }
    public partial class PHPlaneToPlaneMateDesc : PHMateDesc {
	public PHPlaneToPlaneMateDesc() { _thisArray[0] = SprExport.Spr_new_PHPlaneToPlaneMateDesc(); _flag = true; }
	public PHPlaneToPlaneMateDesc(IntPtr ptr) : base(ptr) {}
	public PHPlaneToPlaneMateDesc(IntPtr ptr, bool flag) : base(ptr, flag) {}
	~PHPlaneToPlaneMateDesc() { if (_flag) { SprExport.Spr_delete_PHPlaneToPlaneMateDesc(_thisArray[0]); _flag = false; } }
    }
    [System.Serializable]
    public class PHPlaneToPlaneMateDescStruct : PHMateDescStruct {
        public PHPlaneToPlaneMateDescStruct() {
            PHPlaneToPlaneMateDesc desc = new PHPlaneToPlaneMateDesc();
            ApplyFrom(desc, true);
        }
	public void ApplyTo(PHPlaneToPlaneMateDesc r, bool apply_to_base_class = false) {
		if (apply_to_base_class) {
		    base.ApplyTo(r, apply_to_base_class);
		}
	}
	public void ApplyFrom(PHPlaneToPlaneMateDesc r, bool apply_to_base_class = false) {
		if (apply_to_base_class) {
		    base.ApplyFrom(r, apply_to_base_class);
		}
	}
	public static implicit operator PHPlaneToPlaneMateDesc(PHPlaneToPlaneMateDescStruct m) {
	    PHPlaneToPlaneMateDesc r = new PHPlaneToPlaneMateDesc();
	    m.ApplyTo(r, true);
	    return r;
	}
	public static implicit operator PHPlaneToPlaneMateDescStruct(PHPlaneToPlaneMateDesc r) {
	    PHPlaneToPlaneMateDescStruct m = new PHPlaneToPlaneMateDescStruct();
	    m.ApplyFrom(r, true);
	    return m;
	}
    }
    public partial class PHTreeNodeDesc : CsObject {
	public PHTreeNodeDesc() { _thisArray[0] = SprExport.Spr_new_PHTreeNodeDesc(); _flag = true; }
	public PHTreeNodeDesc(IntPtr ptr) : base(ptr) {}
	public PHTreeNodeDesc(IntPtr ptr, bool flag) : base(ptr, flag) {}
	~PHTreeNodeDesc() { if (_flag) { SprExport.Spr_delete_PHTreeNodeDesc(_thisArray[0]); _flag = false; } }
	public bool bEnabled {
	    get {
	        byte ret = (byte) SprExport.Spr_PHTreeNodeDesc_get_bEnabled(_thisArray[0]);
	        return (ret == 0) ? false : true;
	    }
	    set {
	        byte val = (byte) (value ? 1 : 0);
	        SprExport.Spr_PHTreeNodeDesc_set_bEnabled(_thisArray[0], (char) val);
	    }
	}
    }
    [System.Serializable]
    public class PHTreeNodeDescStruct : CsObject {
        public PHTreeNodeDescStruct() {
            PHTreeNodeDesc desc = new PHTreeNodeDesc();
            ApplyFrom(desc, false);
        }
	public bool bEnabled;
	public void ApplyTo(PHTreeNodeDesc r, bool apply_to_base_class = false) {
		r.bEnabled = bEnabled;
	}
	public void ApplyFrom(PHTreeNodeDesc r, bool apply_to_base_class = false) {
		bEnabled = r.bEnabled;
	}
	public static implicit operator PHTreeNodeDesc(PHTreeNodeDescStruct m) {
	    PHTreeNodeDesc r = new PHTreeNodeDesc();
	    m.ApplyTo(r, true);
	    return r;
	}
	public static implicit operator PHTreeNodeDescStruct(PHTreeNodeDesc r) {
	    PHTreeNodeDescStruct m = new PHTreeNodeDescStruct();
	    m.ApplyFrom(r, true);
	    return m;
	}
    }
    public partial class PHRootNodeDesc : PHTreeNodeDesc {
	public PHRootNodeDesc() { _thisArray[0] = SprExport.Spr_new_PHRootNodeDesc(); _flag = true; }
	public PHRootNodeDesc(IntPtr ptr) : base(ptr) {}
	public PHRootNodeDesc(IntPtr ptr, bool flag) : base(ptr, flag) {}
	~PHRootNodeDesc() { if (_flag) { SprExport.Spr_delete_PHRootNodeDesc(_thisArray[0]); _flag = false; } }
    }
    [System.Serializable]
    public class PHRootNodeDescStruct : PHTreeNodeDescStruct {
        public PHRootNodeDescStruct() {
            PHRootNodeDesc desc = new PHRootNodeDesc();
            ApplyFrom(desc, true);
        }
	public void ApplyTo(PHRootNodeDesc r, bool apply_to_base_class = false) {
		if (apply_to_base_class) {
		    base.ApplyTo(r, apply_to_base_class);
		}
	}
	public void ApplyFrom(PHRootNodeDesc r, bool apply_to_base_class = false) {
		if (apply_to_base_class) {
		    base.ApplyFrom(r, apply_to_base_class);
		}
	}
	public static implicit operator PHRootNodeDesc(PHRootNodeDescStruct m) {
	    PHRootNodeDesc r = new PHRootNodeDesc();
	    m.ApplyTo(r, true);
	    return r;
	}
	public static implicit operator PHRootNodeDescStruct(PHRootNodeDesc r) {
	    PHRootNodeDescStruct m = new PHRootNodeDescStruct();
	    m.ApplyFrom(r, true);
	    return m;
	}
    }
    public partial class PHTreeNode1DDesc : PHTreeNodeDesc {
	public PHTreeNode1DDesc() { _thisArray[0] = SprExport.Spr_new_PHTreeNode1DDesc(); _flag = true; }
	public PHTreeNode1DDesc(IntPtr ptr) : base(ptr) {}
	public PHTreeNode1DDesc(IntPtr ptr, bool flag) : base(ptr, flag) {}
	~PHTreeNode1DDesc() { if (_flag) { SprExport.Spr_delete_PHTreeNode1DDesc(_thisArray[0]); _flag = false; } }
    }
    [System.Serializable]
    public class PHTreeNode1DDescStruct : PHTreeNodeDescStruct {
        public PHTreeNode1DDescStruct() {
            PHTreeNode1DDesc desc = new PHTreeNode1DDesc();
            ApplyFrom(desc, true);
        }
	public void ApplyTo(PHTreeNode1DDesc r, bool apply_to_base_class = false) {
		if (apply_to_base_class) {
		    base.ApplyTo(r, apply_to_base_class);
		}
	}
	public void ApplyFrom(PHTreeNode1DDesc r, bool apply_to_base_class = false) {
		if (apply_to_base_class) {
		    base.ApplyFrom(r, apply_to_base_class);
		}
	}
	public static implicit operator PHTreeNode1DDesc(PHTreeNode1DDescStruct m) {
	    PHTreeNode1DDesc r = new PHTreeNode1DDesc();
	    m.ApplyTo(r, true);
	    return r;
	}
	public static implicit operator PHTreeNode1DDescStruct(PHTreeNode1DDesc r) {
	    PHTreeNode1DDescStruct m = new PHTreeNode1DDescStruct();
	    m.ApplyFrom(r, true);
	    return m;
	}
    }
    public partial class PHHingeJointNodeDesc : PHTreeNode1DDesc {
	public PHHingeJointNodeDesc() { _thisArray[0] = SprExport.Spr_new_PHHingeJointNodeDesc(); _flag = true; }
	public PHHingeJointNodeDesc(IntPtr ptr) : base(ptr) {}
	public PHHingeJointNodeDesc(IntPtr ptr, bool flag) : base(ptr, flag) {}
	~PHHingeJointNodeDesc() { if (_flag) { SprExport.Spr_delete_PHHingeJointNodeDesc(_thisArray[0]); _flag = false; } }
    }
    [System.Serializable]
    public class PHHingeJointNodeDescStruct : PHTreeNode1DDescStruct {
        public PHHingeJointNodeDescStruct() {
            PHHingeJointNodeDesc desc = new PHHingeJointNodeDesc();
            ApplyFrom(desc, true);
        }
	public void ApplyTo(PHHingeJointNodeDesc r, bool apply_to_base_class = false) {
		if (apply_to_base_class) {
		    base.ApplyTo(r, apply_to_base_class);
		}
	}
	public void ApplyFrom(PHHingeJointNodeDesc r, bool apply_to_base_class = false) {
		if (apply_to_base_class) {
		    base.ApplyFrom(r, apply_to_base_class);
		}
	}
	public static implicit operator PHHingeJointNodeDesc(PHHingeJointNodeDescStruct m) {
	    PHHingeJointNodeDesc r = new PHHingeJointNodeDesc();
	    m.ApplyTo(r, true);
	    return r;
	}
	public static implicit operator PHHingeJointNodeDescStruct(PHHingeJointNodeDesc r) {
	    PHHingeJointNodeDescStruct m = new PHHingeJointNodeDescStruct();
	    m.ApplyFrom(r, true);
	    return m;
	}
    }
    public partial class PHSliderJointNodeDesc : PHTreeNode1DDesc {
	public PHSliderJointNodeDesc() { _thisArray[0] = SprExport.Spr_new_PHSliderJointNodeDesc(); _flag = true; }
	public PHSliderJointNodeDesc(IntPtr ptr) : base(ptr) {}
	public PHSliderJointNodeDesc(IntPtr ptr, bool flag) : base(ptr, flag) {}
	~PHSliderJointNodeDesc() { if (_flag) { SprExport.Spr_delete_PHSliderJointNodeDesc(_thisArray[0]); _flag = false; } }
    }
    [System.Serializable]
    public class PHSliderJointNodeDescStruct : PHTreeNode1DDescStruct {
        public PHSliderJointNodeDescStruct() {
            PHSliderJointNodeDesc desc = new PHSliderJointNodeDesc();
            ApplyFrom(desc, true);
        }
	public void ApplyTo(PHSliderJointNodeDesc r, bool apply_to_base_class = false) {
		if (apply_to_base_class) {
		    base.ApplyTo(r, apply_to_base_class);
		}
	}
	public void ApplyFrom(PHSliderJointNodeDesc r, bool apply_to_base_class = false) {
		if (apply_to_base_class) {
		    base.ApplyFrom(r, apply_to_base_class);
		}
	}
	public static implicit operator PHSliderJointNodeDesc(PHSliderJointNodeDescStruct m) {
	    PHSliderJointNodeDesc r = new PHSliderJointNodeDesc();
	    m.ApplyTo(r, true);
	    return r;
	}
	public static implicit operator PHSliderJointNodeDescStruct(PHSliderJointNodeDesc r) {
	    PHSliderJointNodeDescStruct m = new PHSliderJointNodeDescStruct();
	    m.ApplyFrom(r, true);
	    return m;
	}
    }
    public partial class PHPathJointNodeDesc : PHTreeNode1DDesc {
	public PHPathJointNodeDesc() { _thisArray[0] = SprExport.Spr_new_PHPathJointNodeDesc(); _flag = true; }
	public PHPathJointNodeDesc(IntPtr ptr) : base(ptr) {}
	public PHPathJointNodeDesc(IntPtr ptr, bool flag) : base(ptr, flag) {}
	~PHPathJointNodeDesc() { if (_flag) { SprExport.Spr_delete_PHPathJointNodeDesc(_thisArray[0]); _flag = false; } }
    }
    [System.Serializable]
    public class PHPathJointNodeDescStruct : PHTreeNode1DDescStruct {
        public PHPathJointNodeDescStruct() {
            PHPathJointNodeDesc desc = new PHPathJointNodeDesc();
            ApplyFrom(desc, true);
        }
	public void ApplyTo(PHPathJointNodeDesc r, bool apply_to_base_class = false) {
		if (apply_to_base_class) {
		    base.ApplyTo(r, apply_to_base_class);
		}
	}
	public void ApplyFrom(PHPathJointNodeDesc r, bool apply_to_base_class = false) {
		if (apply_to_base_class) {
		    base.ApplyFrom(r, apply_to_base_class);
		}
	}
	public static implicit operator PHPathJointNodeDesc(PHPathJointNodeDescStruct m) {
	    PHPathJointNodeDesc r = new PHPathJointNodeDesc();
	    m.ApplyTo(r, true);
	    return r;
	}
	public static implicit operator PHPathJointNodeDescStruct(PHPathJointNodeDesc r) {
	    PHPathJointNodeDescStruct m = new PHPathJointNodeDescStruct();
	    m.ApplyFrom(r, true);
	    return m;
	}
    }
    public partial class PHGenericJointNodeDesc : PHTreeNode1DDesc {
	public PHGenericJointNodeDesc() { _thisArray[0] = SprExport.Spr_new_PHGenericJointNodeDesc(); _flag = true; }
	public PHGenericJointNodeDesc(IntPtr ptr) : base(ptr) {}
	public PHGenericJointNodeDesc(IntPtr ptr, bool flag) : base(ptr, flag) {}
	~PHGenericJointNodeDesc() { if (_flag) { SprExport.Spr_delete_PHGenericJointNodeDesc(_thisArray[0]); _flag = false; } }
    }
    [System.Serializable]
    public class PHGenericJointNodeDescStruct : PHTreeNode1DDescStruct {
        public PHGenericJointNodeDescStruct() {
            PHGenericJointNodeDesc desc = new PHGenericJointNodeDesc();
            ApplyFrom(desc, true);
        }
	public void ApplyTo(PHGenericJointNodeDesc r, bool apply_to_base_class = false) {
		if (apply_to_base_class) {
		    base.ApplyTo(r, apply_to_base_class);
		}
	}
	public void ApplyFrom(PHGenericJointNodeDesc r, bool apply_to_base_class = false) {
		if (apply_to_base_class) {
		    base.ApplyFrom(r, apply_to_base_class);
		}
	}
	public static implicit operator PHGenericJointNodeDesc(PHGenericJointNodeDescStruct m) {
	    PHGenericJointNodeDesc r = new PHGenericJointNodeDesc();
	    m.ApplyTo(r, true);
	    return r;
	}
	public static implicit operator PHGenericJointNodeDescStruct(PHGenericJointNodeDesc r) {
	    PHGenericJointNodeDescStruct m = new PHGenericJointNodeDescStruct();
	    m.ApplyFrom(r, true);
	    return m;
	}
    }
    public partial class PHBallJointNodeDesc : PHTreeNodeDesc {
	public PHBallJointNodeDesc() { _thisArray[0] = SprExport.Spr_new_PHBallJointNodeDesc(); _flag = true; }
	public PHBallJointNodeDesc(IntPtr ptr) : base(ptr) {}
	public PHBallJointNodeDesc(IntPtr ptr, bool flag) : base(ptr, flag) {}
	~PHBallJointNodeDesc() { if (_flag) { SprExport.Spr_delete_PHBallJointNodeDesc(_thisArray[0]); _flag = false; } }
    }
    [System.Serializable]
    public class PHBallJointNodeDescStruct : PHTreeNodeDescStruct {
        public PHBallJointNodeDescStruct() {
            PHBallJointNodeDesc desc = new PHBallJointNodeDesc();
            ApplyFrom(desc, true);
        }
	public void ApplyTo(PHBallJointNodeDesc r, bool apply_to_base_class = false) {
		if (apply_to_base_class) {
		    base.ApplyTo(r, apply_to_base_class);
		}
	}
	public void ApplyFrom(PHBallJointNodeDesc r, bool apply_to_base_class = false) {
		if (apply_to_base_class) {
		    base.ApplyFrom(r, apply_to_base_class);
		}
	}
	public static implicit operator PHBallJointNodeDesc(PHBallJointNodeDescStruct m) {
	    PHBallJointNodeDesc r = new PHBallJointNodeDesc();
	    m.ApplyTo(r, true);
	    return r;
	}
	public static implicit operator PHBallJointNodeDescStruct(PHBallJointNodeDesc r) {
	    PHBallJointNodeDescStruct m = new PHBallJointNodeDescStruct();
	    m.ApplyFrom(r, true);
	    return m;
	}
    }
    public partial class PHFixJointNodeDesc : PHTreeNodeDesc {
	public PHFixJointNodeDesc() { _thisArray[0] = SprExport.Spr_new_PHFixJointNodeDesc(); _flag = true; }
	public PHFixJointNodeDesc(IntPtr ptr) : base(ptr) {}
	public PHFixJointNodeDesc(IntPtr ptr, bool flag) : base(ptr, flag) {}
	~PHFixJointNodeDesc() { if (_flag) { SprExport.Spr_delete_PHFixJointNodeDesc(_thisArray[0]); _flag = false; } }
    }
    [System.Serializable]
    public class PHFixJointNodeDescStruct : PHTreeNodeDescStruct {
        public PHFixJointNodeDescStruct() {
            PHFixJointNodeDesc desc = new PHFixJointNodeDesc();
            ApplyFrom(desc, true);
        }
	public void ApplyTo(PHFixJointNodeDesc r, bool apply_to_base_class = false) {
		if (apply_to_base_class) {
		    base.ApplyTo(r, apply_to_base_class);
		}
	}
	public void ApplyFrom(PHFixJointNodeDesc r, bool apply_to_base_class = false) {
		if (apply_to_base_class) {
		    base.ApplyFrom(r, apply_to_base_class);
		}
	}
	public static implicit operator PHFixJointNodeDesc(PHFixJointNodeDescStruct m) {
	    PHFixJointNodeDesc r = new PHFixJointNodeDesc();
	    m.ApplyTo(r, true);
	    return r;
	}
	public static implicit operator PHFixJointNodeDescStruct(PHFixJointNodeDesc r) {
	    PHFixJointNodeDescStruct m = new PHFixJointNodeDescStruct();
	    m.ApplyFrom(r, true);
	    return m;
	}
    }
    public partial class PHGearDesc : CsObject {
	public PHGearDesc() { _thisArray[0] = SprExport.Spr_new_PHGearDesc(); _flag = true; }
	public PHGearDesc(IntPtr ptr) : base(ptr) {}
	public PHGearDesc(IntPtr ptr, bool flag) : base(ptr, flag) {}
	~PHGearDesc() { if (_flag) { SprExport.Spr_delete_PHGearDesc(_thisArray[0]); _flag = false; } }
	public bool bEnabled {
	    get {
	        byte ret = (byte) SprExport.Spr_PHGearDesc_get_bEnabled(_thisArray[0]);
	        return (ret == 0) ? false : true;
	    }
	    set {
	        byte val = (byte) (value ? 1 : 0);
	        SprExport.Spr_PHGearDesc_set_bEnabled(_thisArray[0], (char) val);
	    }
	}
	public double ratio {
	    get { return SprExport.Spr_PHGearDesc_get_ratio(_thisArray[0]); }
	    set { SprExport.Spr_PHGearDesc_set_ratio(_thisArray[0], value); }
	}
	public double offset {
	    get { return SprExport.Spr_PHGearDesc_get_offset(_thisArray[0]); }
	    set { SprExport.Spr_PHGearDesc_set_offset(_thisArray[0], value); }
	}
	public int mode {
	    get { return SprExport.Spr_PHGearDesc_get_mode(_thisArray[0]); }
	    set { SprExport.Spr_PHGearDesc_set_mode(_thisArray[0], value); }
	}
    }
    [System.Serializable]
    public class PHGearDescStruct : CsObject {
        public PHGearDescStruct() {
            PHGearDesc desc = new PHGearDesc();
            ApplyFrom(desc, false);
        }
	public bool bEnabled;
	public double ratio;
	public double offset;
	public int mode;
	public void ApplyTo(PHGearDesc r, bool apply_to_base_class = false) {
		r.bEnabled = bEnabled;
		r.ratio = ratio;
		r.offset = offset;
		r.mode = mode;
	}
	public void ApplyFrom(PHGearDesc r, bool apply_to_base_class = false) {
		bEnabled = r.bEnabled;
		ratio = r.ratio;
		offset = r.offset;
		mode = r.mode;
	}
	public static implicit operator PHGearDesc(PHGearDescStruct m) {
	    PHGearDesc r = new PHGearDesc();
	    m.ApplyTo(r, true);
	    return r;
	}
	public static implicit operator PHGearDescStruct(PHGearDesc r) {
	    PHGearDescStruct m = new PHGearDescStruct();
	    m.ApplyFrom(r, true);
	    return m;
	}
    }
    public partial class PH1DJointLimitDesc : CsObject {
	public PH1DJointLimitDesc() { _thisArray[0] = SprExport.Spr_new_PH1DJointLimitDesc(); _flag = true; }
	public PH1DJointLimitDesc(IntPtr ptr) : base(ptr) {}
	public PH1DJointLimitDesc(IntPtr ptr, bool flag) : base(ptr, flag) {}
	~PH1DJointLimitDesc() { if (_flag) { SprExport.Spr_delete_PH1DJointLimitDesc(_thisArray[0]); _flag = false; } }
	public bool bEnabled {
	    get {
	        byte ret = (byte) SprExport.Spr_PH1DJointLimitDesc_get_bEnabled(_thisArray[0]);
	        return (ret == 0) ? false : true;
	    }
	    set {
	        byte val = (byte) (value ? 1 : 0);
	        SprExport.Spr_PH1DJointLimitDesc_set_bEnabled(_thisArray[0], (char) val);
	    }
	}
	public double spring {
	    get { return SprExport.Spr_PH1DJointLimitDesc_get_spring(_thisArray[0]); }
	    set { SprExport.Spr_PH1DJointLimitDesc_set_spring(_thisArray[0], value); }
	}
	public double damper {
	    get { return SprExport.Spr_PH1DJointLimitDesc_get_damper(_thisArray[0]); }
	    set { SprExport.Spr_PH1DJointLimitDesc_set_damper(_thisArray[0], value); }
	}
	public Vec2d range {
	    get { return new Vec2d(SprExport.Spr_PH1DJointLimitDesc_addr_range(_thisArray[0])); }
	    set { SprExport.Spr_PH1DJointLimitDesc_set_range(_thisArray[0], value); }
	}
    }
    [System.Serializable]
    public class PH1DJointLimitDescStruct : CsObject {
        public PH1DJointLimitDescStruct() {
            PH1DJointLimitDesc desc = new PH1DJointLimitDesc();
            ApplyFrom(desc, false);
        }
	public bool bEnabled;
	public double spring;
	public double damper;
	public Vec2dStruct range;
	public void ApplyTo(PH1DJointLimitDesc r, bool apply_to_base_class = false) {
		r.bEnabled = bEnabled;
		r.spring = spring;
		r.damper = damper;
		r.range = range;
	}
	public void ApplyFrom(PH1DJointLimitDesc r, bool apply_to_base_class = false) {
		bEnabled = r.bEnabled;
		spring = r.spring;
		damper = r.damper;
		range = r.range;
	}
	public static implicit operator PH1DJointLimitDesc(PH1DJointLimitDescStruct m) {
	    PH1DJointLimitDesc r = new PH1DJointLimitDesc();
	    m.ApplyTo(r, true);
	    return r;
	}
	public static implicit operator PH1DJointLimitDescStruct(PH1DJointLimitDesc r) {
	    PH1DJointLimitDescStruct m = new PH1DJointLimitDescStruct();
	    m.ApplyFrom(r, true);
	    return m;
	}
    }
    public partial class PHBallJointLimitDesc : CsObject {
	public PHBallJointLimitDesc() { _thisArray[0] = SprExport.Spr_new_PHBallJointLimitDesc(); _flag = true; }
	public PHBallJointLimitDesc(IntPtr ptr) : base(ptr) {}
	public PHBallJointLimitDesc(IntPtr ptr, bool flag) : base(ptr, flag) {}
	~PHBallJointLimitDesc() { if (_flag) { SprExport.Spr_delete_PHBallJointLimitDesc(_thisArray[0]); _flag = false; } }
	public bool bEnabled {
	    get {
	        byte ret = (byte) SprExport.Spr_PHBallJointLimitDesc_get_bEnabled(_thisArray[0]);
	        return (ret == 0) ? false : true;
	    }
	    set {
	        byte val = (byte) (value ? 1 : 0);
	        SprExport.Spr_PHBallJointLimitDesc_set_bEnabled(_thisArray[0], (char) val);
	    }
	}
	public double spring {
	    get { return SprExport.Spr_PHBallJointLimitDesc_get_spring(_thisArray[0]); }
	    set { SprExport.Spr_PHBallJointLimitDesc_set_spring(_thisArray[0], value); }
	}
	public double damper {
	    get { return SprExport.Spr_PHBallJointLimitDesc_get_damper(_thisArray[0]); }
	    set { SprExport.Spr_PHBallJointLimitDesc_set_damper(_thisArray[0], value); }
	}
	public Vec3d limitDir {
	    get { return new Vec3d(SprExport.Spr_PHBallJointLimitDesc_addr_limitDir(_thisArray[0])); }
	    set { SprExport.Spr_PHBallJointLimitDesc_set_limitDir(_thisArray[0], value); }
	}
    }
    [System.Serializable]
    public class PHBallJointLimitDescStruct : CsObject {
        public PHBallJointLimitDescStruct() {
            PHBallJointLimitDesc desc = new PHBallJointLimitDesc();
            ApplyFrom(desc, false);
        }
	public bool bEnabled;
	public double spring;
	public double damper;
	public Vec3dStruct limitDir;
	public void ApplyTo(PHBallJointLimitDesc r, bool apply_to_base_class = false) {
		r.bEnabled = bEnabled;
		r.spring = spring;
		r.damper = damper;
		r.limitDir = limitDir;
	}
	public void ApplyFrom(PHBallJointLimitDesc r, bool apply_to_base_class = false) {
		bEnabled = r.bEnabled;
		spring = r.spring;
		damper = r.damper;
		limitDir = r.limitDir;
	}
	public static implicit operator PHBallJointLimitDesc(PHBallJointLimitDescStruct m) {
	    PHBallJointLimitDesc r = new PHBallJointLimitDesc();
	    m.ApplyTo(r, true);
	    return r;
	}
	public static implicit operator PHBallJointLimitDescStruct(PHBallJointLimitDesc r) {
	    PHBallJointLimitDescStruct m = new PHBallJointLimitDescStruct();
	    m.ApplyFrom(r, true);
	    return m;
	}
    }
    public partial class PHBallJointConeLimitDesc : PHBallJointLimitDesc {
	public PHBallJointConeLimitDesc() { _thisArray[0] = SprExport.Spr_new_PHBallJointConeLimitDesc(); _flag = true; }
	public PHBallJointConeLimitDesc(IntPtr ptr) : base(ptr) {}
	public PHBallJointConeLimitDesc(IntPtr ptr, bool flag) : base(ptr, flag) {}
	~PHBallJointConeLimitDesc() { if (_flag) { SprExport.Spr_delete_PHBallJointConeLimitDesc(_thisArray[0]); _flag = false; } }
	public Vec2d limitSwing {
	    get { return new Vec2d(SprExport.Spr_PHBallJointConeLimitDesc_addr_limitSwing(_thisArray[0])); }
	    set { SprExport.Spr_PHBallJointConeLimitDesc_set_limitSwing(_thisArray[0], value); }
	}
	public Vec2d limitSwingDir {
	    get { return new Vec2d(SprExport.Spr_PHBallJointConeLimitDesc_addr_limitSwingDir(_thisArray[0])); }
	    set { SprExport.Spr_PHBallJointConeLimitDesc_set_limitSwingDir(_thisArray[0], value); }
	}
	public Vec2d limitTwist {
	    get { return new Vec2d(SprExport.Spr_PHBallJointConeLimitDesc_addr_limitTwist(_thisArray[0])); }
	    set { SprExport.Spr_PHBallJointConeLimitDesc_set_limitTwist(_thisArray[0], value); }
	}
    }
    [System.Serializable]
    public class PHBallJointConeLimitDescStruct : PHBallJointLimitDescStruct {
        public PHBallJointConeLimitDescStruct() {
            PHBallJointConeLimitDesc desc = new PHBallJointConeLimitDesc();
            ApplyFrom(desc, true);
        }
	public Vec2dStruct limitSwing;
	public Vec2dStruct limitSwingDir;
	public Vec2dStruct limitTwist;
	public void ApplyTo(PHBallJointConeLimitDesc r, bool apply_to_base_class = false) {
		r.limitSwing = limitSwing;
		r.limitSwingDir = limitSwingDir;
		r.limitTwist = limitTwist;
		if (apply_to_base_class) {
		    base.ApplyTo(r, apply_to_base_class);
		}
	}
	public void ApplyFrom(PHBallJointConeLimitDesc r, bool apply_to_base_class = false) {
		limitSwing = r.limitSwing;
		limitSwingDir = r.limitSwingDir;
		limitTwist = r.limitTwist;
		if (apply_to_base_class) {
		    base.ApplyFrom(r, apply_to_base_class);
		}
	}
	public static implicit operator PHBallJointConeLimitDesc(PHBallJointConeLimitDescStruct m) {
	    PHBallJointConeLimitDesc r = new PHBallJointConeLimitDesc();
	    m.ApplyTo(r, true);
	    return r;
	}
	public static implicit operator PHBallJointConeLimitDescStruct(PHBallJointConeLimitDesc r) {
	    PHBallJointConeLimitDescStruct m = new PHBallJointConeLimitDescStruct();
	    m.ApplyFrom(r, true);
	    return m;
	}
    }
    public partial class PHSplineLimitNode : CsObject {
	public PHSplineLimitNode() { _thisArray[0] = SprExport.Spr_new_PHSplineLimitNode(); _flag = true; }
	public PHSplineLimitNode(IntPtr ptr) : base(ptr) {}
	public PHSplineLimitNode(IntPtr ptr, bool flag) : base(ptr, flag) {}
	public PHSplineLimitNode(double s, double sd, double ds, double dsd, double tmn, double tmx) { _thisArray[0] = SprExport.Spr_new_PHSplineLimitNode_8(s, sd, ds, dsd, tmn, tmx); _flag = true; }
	~PHSplineLimitNode() { if (_flag) { SprExport.Spr_delete_PHSplineLimitNode(_thisArray[0]); _flag = false; } }
	public double swing {
	    get { return SprExport.Spr_PHSplineLimitNode_get_swing(_thisArray[0]); }
	    set { SprExport.Spr_PHSplineLimitNode_set_swing(_thisArray[0], value); }
	}
	public double swingDir {
	    get { return SprExport.Spr_PHSplineLimitNode_get_swingDir(_thisArray[0]); }
	    set { SprExport.Spr_PHSplineLimitNode_set_swingDir(_thisArray[0], value); }
	}
	public double dSwing {
	    get { return SprExport.Spr_PHSplineLimitNode_get_dSwing(_thisArray[0]); }
	    set { SprExport.Spr_PHSplineLimitNode_set_dSwing(_thisArray[0], value); }
	}
	public double dSwingDir {
	    get { return SprExport.Spr_PHSplineLimitNode_get_dSwingDir(_thisArray[0]); }
	    set { SprExport.Spr_PHSplineLimitNode_set_dSwingDir(_thisArray[0], value); }
	}
	public double twistMin {
	    get { return SprExport.Spr_PHSplineLimitNode_get_twistMin(_thisArray[0]); }
	    set { SprExport.Spr_PHSplineLimitNode_set_twistMin(_thisArray[0], value); }
	}
	public double twistMax {
	    get { return SprExport.Spr_PHSplineLimitNode_get_twistMax(_thisArray[0]); }
	    set { SprExport.Spr_PHSplineLimitNode_set_twistMax(_thisArray[0], value); }
	}
    }
    public partial class PHBallJointSplineLimitDesc : PHBallJointLimitDesc {
	public PHBallJointSplineLimitDesc() { _thisArray[0] = SprExport.Spr_new_PHBallJointSplineLimitDesc(); _flag = true; }
	public PHBallJointSplineLimitDesc(IntPtr ptr) : base(ptr) {}
	public PHBallJointSplineLimitDesc(IntPtr ptr, bool flag) : base(ptr, flag) {}
	~PHBallJointSplineLimitDesc() { if (_flag) { SprExport.Spr_delete_PHBallJointSplineLimitDesc(_thisArray[0]); _flag = false; } }
        public vectorwrapper_PHSplineLimitNode nodes {
            get { return new vectorwrapper_PHSplineLimitNode(SprExport.Spr_PHBallJointSplineLimitDesc_addr_nodes(_thisArray[0])); }
            set { SprExport.Spr_PHBallJointSplineLimitDesc_set_nodes(_thisArray[0], value); }
        }
	public Vec2d poleTwist {
	    get { return new Vec2d(SprExport.Spr_PHBallJointSplineLimitDesc_addr_poleTwist(_thisArray[0])); }
	    set { SprExport.Spr_PHBallJointSplineLimitDesc_set_poleTwist(_thisArray[0], value); }
	}
    }
    [System.Serializable]
    public class PHBallJointSplineLimitDescStruct : PHBallJointLimitDescStruct {
        public PHBallJointSplineLimitDescStruct() {
            PHBallJointSplineLimitDesc desc = new PHBallJointSplineLimitDesc();
            ApplyFrom(desc, true);
        }
	public vectorwrapper_PHSplineLimitNode nodes;
	public Vec2dStruct poleTwist;
	public void ApplyTo(PHBallJointSplineLimitDesc r, bool apply_to_base_class = false) {
		r.nodes = nodes;
		r.poleTwist = poleTwist;
		if (apply_to_base_class) {
		    base.ApplyTo(r, apply_to_base_class);
		}
	}
	public void ApplyFrom(PHBallJointSplineLimitDesc r, bool apply_to_base_class = false) {
		nodes = r.nodes;
		poleTwist = r.poleTwist;
		if (apply_to_base_class) {
		    base.ApplyFrom(r, apply_to_base_class);
		}
	}
	public static implicit operator PHBallJointSplineLimitDesc(PHBallJointSplineLimitDescStruct m) {
	    PHBallJointSplineLimitDesc r = new PHBallJointSplineLimitDesc();
	    m.ApplyTo(r, true);
	    return r;
	}
	public static implicit operator PHBallJointSplineLimitDescStruct(PHBallJointSplineLimitDesc r) {
	    PHBallJointSplineLimitDescStruct m = new PHBallJointSplineLimitDescStruct();
	    m.ApplyFrom(r, true);
	    return m;
	}
    }
    public partial class PHBallJointIndependentLimitDesc : PHBallJointLimitDesc {
	public PHBallJointIndependentLimitDesc() { _thisArray[0] = SprExport.Spr_new_PHBallJointIndependentLimitDesc(); _flag = true; }
	public PHBallJointIndependentLimitDesc(IntPtr ptr) : base(ptr) {}
	public PHBallJointIndependentLimitDesc(IntPtr ptr, bool flag) : base(ptr, flag) {}
	~PHBallJointIndependentLimitDesc() { if (_flag) { SprExport.Spr_delete_PHBallJointIndependentLimitDesc(_thisArray[0]); _flag = false; } }
	public Vec2d limitX {
	    get { return new Vec2d(SprExport.Spr_PHBallJointIndependentLimitDesc_addr_limitX(_thisArray[0])); }
	    set { SprExport.Spr_PHBallJointIndependentLimitDesc_set_limitX(_thisArray[0], value); }
	}
	public Vec2d limitY {
	    get { return new Vec2d(SprExport.Spr_PHBallJointIndependentLimitDesc_addr_limitY(_thisArray[0])); }
	    set { SprExport.Spr_PHBallJointIndependentLimitDesc_set_limitY(_thisArray[0], value); }
	}
	public Vec2d limitZ {
	    get { return new Vec2d(SprExport.Spr_PHBallJointIndependentLimitDesc_addr_limitZ(_thisArray[0])); }
	    set { SprExport.Spr_PHBallJointIndependentLimitDesc_set_limitZ(_thisArray[0], value); }
	}
    }
    [System.Serializable]
    public class PHBallJointIndependentLimitDescStruct : PHBallJointLimitDescStruct {
        public PHBallJointIndependentLimitDescStruct() {
            PHBallJointIndependentLimitDesc desc = new PHBallJointIndependentLimitDesc();
            ApplyFrom(desc, true);
        }
	public Vec2dStruct limitX;
	public Vec2dStruct limitY;
	public Vec2dStruct limitZ;
	public void ApplyTo(PHBallJointIndependentLimitDesc r, bool apply_to_base_class = false) {
		r.limitX = limitX;
		r.limitY = limitY;
		r.limitZ = limitZ;
		if (apply_to_base_class) {
		    base.ApplyTo(r, apply_to_base_class);
		}
	}
	public void ApplyFrom(PHBallJointIndependentLimitDesc r, bool apply_to_base_class = false) {
		limitX = r.limitX;
		limitY = r.limitY;
		limitZ = r.limitZ;
		if (apply_to_base_class) {
		    base.ApplyFrom(r, apply_to_base_class);
		}
	}
	public static implicit operator PHBallJointIndependentLimitDesc(PHBallJointIndependentLimitDescStruct m) {
	    PHBallJointIndependentLimitDesc r = new PHBallJointIndependentLimitDesc();
	    m.ApplyTo(r, true);
	    return r;
	}
	public static implicit operator PHBallJointIndependentLimitDescStruct(PHBallJointIndependentLimitDesc r) {
	    PHBallJointIndependentLimitDescStruct m = new PHBallJointIndependentLimitDescStruct();
	    m.ApplyFrom(r, true);
	    return m;
	}
    }
    public partial class PH1DJointMotorDesc : CsObject {
	public PH1DJointMotorDesc() { _thisArray[0] = SprExport.Spr_new_PH1DJointMotorDesc(); _flag = true; }
	public PH1DJointMotorDesc(IntPtr ptr) : base(ptr) {}
	public PH1DJointMotorDesc(IntPtr ptr, bool flag) : base(ptr, flag) {}
	~PH1DJointMotorDesc() { if (_flag) { SprExport.Spr_delete_PH1DJointMotorDesc(_thisArray[0]); _flag = false; } }
    }
    [System.Serializable]
    public class PH1DJointMotorDescStruct : CsObject {
        public PH1DJointMotorDescStruct() {
            PH1DJointMotorDesc desc = new PH1DJointMotorDesc();
            ApplyFrom(desc, false);
        }
	public void ApplyTo(PH1DJointMotorDesc r, bool apply_to_base_class = false) {
	}
	public void ApplyFrom(PH1DJointMotorDesc r, bool apply_to_base_class = false) {
	}
	public static implicit operator PH1DJointMotorDesc(PH1DJointMotorDescStruct m) {
	    PH1DJointMotorDesc r = new PH1DJointMotorDesc();
	    m.ApplyTo(r, true);
	    return r;
	}
	public static implicit operator PH1DJointMotorDescStruct(PH1DJointMotorDesc r) {
	    PH1DJointMotorDescStruct m = new PH1DJointMotorDescStruct();
	    m.ApplyFrom(r, true);
	    return m;
	}
    }
    public partial class PH1DJointNonLinearMotorDesc : PH1DJointMotorDesc {
	public PH1DJointNonLinearMotorDesc() { _thisArray[0] = SprExport.Spr_new_PH1DJointNonLinearMotorDesc(); _flag = true; }
	public PH1DJointNonLinearMotorDesc(IntPtr ptr) : base(ptr) {}
	public PH1DJointNonLinearMotorDesc(IntPtr ptr, bool flag) : base(ptr, flag) {}
	~PH1DJointNonLinearMotorDesc() { if (_flag) { SprExport.Spr_delete_PH1DJointNonLinearMotorDesc(_thisArray[0]); _flag = false; } }
	public enum FunctionMode : int {
	    LINEAR = 0, HUMANJOINTRESITANCE = LINEAR + 1
	}
    }
    [System.Serializable]
    public class PH1DJointNonLinearMotorDescStruct : PH1DJointMotorDescStruct {
        public PH1DJointNonLinearMotorDescStruct() {
            PH1DJointNonLinearMotorDesc desc = new PH1DJointNonLinearMotorDesc();
            ApplyFrom(desc, true);
        }
	public void ApplyTo(PH1DJointNonLinearMotorDesc r, bool apply_to_base_class = false) {
		if (apply_to_base_class) {
		    base.ApplyTo(r, apply_to_base_class);
		}
	}
	public void ApplyFrom(PH1DJointNonLinearMotorDesc r, bool apply_to_base_class = false) {
		if (apply_to_base_class) {
		    base.ApplyFrom(r, apply_to_base_class);
		}
	}
	public static implicit operator PH1DJointNonLinearMotorDesc(PH1DJointNonLinearMotorDescStruct m) {
	    PH1DJointNonLinearMotorDesc r = new PH1DJointNonLinearMotorDesc();
	    m.ApplyTo(r, true);
	    return r;
	}
	public static implicit operator PH1DJointNonLinearMotorDescStruct(PH1DJointNonLinearMotorDesc r) {
	    PH1DJointNonLinearMotorDescStruct m = new PH1DJointNonLinearMotorDescStruct();
	    m.ApplyFrom(r, true);
	    return m;
	}
    }
    public partial class PHHuman1DJointResistanceDesc : PH1DJointNonLinearMotorDesc {
	public PHHuman1DJointResistanceDesc() { _thisArray[0] = SprExport.Spr_new_PHHuman1DJointResistanceDesc(); _flag = true; }
	public PHHuman1DJointResistanceDesc(IntPtr ptr) : base(ptr) {}
	public PHHuman1DJointResistanceDesc(IntPtr ptr, bool flag) : base(ptr, flag) {}
	~PHHuman1DJointResistanceDesc() { if (_flag) { SprExport.Spr_delete_PHHuman1DJointResistanceDesc(_thisArray[0]); _flag = false; } }
	public Vec4d coefficient {
	    get { return new Vec4d(SprExport.Spr_PHHuman1DJointResistanceDesc_addr_coefficient(_thisArray[0])); }
	    set { SprExport.Spr_PHHuman1DJointResistanceDesc_set_coefficient(_thisArray[0], value); }
	}
    }
    [System.Serializable]
    public class PHHuman1DJointResistanceDescStruct : PH1DJointNonLinearMotorDescStruct {
        public PHHuman1DJointResistanceDescStruct() {
            PHHuman1DJointResistanceDesc desc = new PHHuman1DJointResistanceDesc();
            ApplyFrom(desc, true);
        }
	public Vec4dStruct coefficient;
	public void ApplyTo(PHHuman1DJointResistanceDesc r, bool apply_to_base_class = false) {
		r.coefficient = coefficient;
		if (apply_to_base_class) {
		    base.ApplyTo(r, apply_to_base_class);
		}
	}
	public void ApplyFrom(PHHuman1DJointResistanceDesc r, bool apply_to_base_class = false) {
		coefficient = r.coefficient;
		if (apply_to_base_class) {
		    base.ApplyFrom(r, apply_to_base_class);
		}
	}
	public static implicit operator PHHuman1DJointResistanceDesc(PHHuman1DJointResistanceDescStruct m) {
	    PHHuman1DJointResistanceDesc r = new PHHuman1DJointResistanceDesc();
	    m.ApplyTo(r, true);
	    return r;
	}
	public static implicit operator PHHuman1DJointResistanceDescStruct(PHHuman1DJointResistanceDesc r) {
	    PHHuman1DJointResistanceDescStruct m = new PHHuman1DJointResistanceDescStruct();
	    m.ApplyFrom(r, true);
	    return m;
	}
    }
    public partial class PHBallJointMotorDesc : CsObject {
	public PHBallJointMotorDesc() { _thisArray[0] = SprExport.Spr_new_PHBallJointMotorDesc(); _flag = true; }
	public PHBallJointMotorDesc(IntPtr ptr) : base(ptr) {}
	public PHBallJointMotorDesc(IntPtr ptr, bool flag) : base(ptr, flag) {}
	~PHBallJointMotorDesc() { if (_flag) { SprExport.Spr_delete_PHBallJointMotorDesc(_thisArray[0]); _flag = false; } }
    }
    [System.Serializable]
    public class PHBallJointMotorDescStruct : CsObject {
        public PHBallJointMotorDescStruct() {
            PHBallJointMotorDesc desc = new PHBallJointMotorDesc();
            ApplyFrom(desc, false);
        }
	public void ApplyTo(PHBallJointMotorDesc r, bool apply_to_base_class = false) {
	}
	public void ApplyFrom(PHBallJointMotorDesc r, bool apply_to_base_class = false) {
	}
	public static implicit operator PHBallJointMotorDesc(PHBallJointMotorDescStruct m) {
	    PHBallJointMotorDesc r = new PHBallJointMotorDesc();
	    m.ApplyTo(r, true);
	    return r;
	}
	public static implicit operator PHBallJointMotorDescStruct(PHBallJointMotorDesc r) {
	    PHBallJointMotorDescStruct m = new PHBallJointMotorDescStruct();
	    m.ApplyFrom(r, true);
	    return m;
	}
    }
    public partial class PHBallJointNonLinearMotorDesc : PHBallJointMotorDesc {
	public PHBallJointNonLinearMotorDesc() { _thisArray[0] = SprExport.Spr_new_PHBallJointNonLinearMotorDesc(); _flag = true; }
	public PHBallJointNonLinearMotorDesc(IntPtr ptr) : base(ptr) {}
	public PHBallJointNonLinearMotorDesc(IntPtr ptr, bool flag) : base(ptr, flag) {}
	~PHBallJointNonLinearMotorDesc() { if (_flag) { SprExport.Spr_delete_PHBallJointNonLinearMotorDesc(_thisArray[0]); _flag = false; } }
    }
    [System.Serializable]
    public class PHBallJointNonLinearMotorDescStruct : PHBallJointMotorDescStruct {
        public PHBallJointNonLinearMotorDescStruct() {
            PHBallJointNonLinearMotorDesc desc = new PHBallJointNonLinearMotorDesc();
            ApplyFrom(desc, true);
        }
	public void ApplyTo(PHBallJointNonLinearMotorDesc r, bool apply_to_base_class = false) {
		if (apply_to_base_class) {
		    base.ApplyTo(r, apply_to_base_class);
		}
	}
	public void ApplyFrom(PHBallJointNonLinearMotorDesc r, bool apply_to_base_class = false) {
		if (apply_to_base_class) {
		    base.ApplyFrom(r, apply_to_base_class);
		}
	}
	public static implicit operator PHBallJointNonLinearMotorDesc(PHBallJointNonLinearMotorDescStruct m) {
	    PHBallJointNonLinearMotorDesc r = new PHBallJointNonLinearMotorDesc();
	    m.ApplyTo(r, true);
	    return r;
	}
	public static implicit operator PHBallJointNonLinearMotorDescStruct(PHBallJointNonLinearMotorDesc r) {
	    PHBallJointNonLinearMotorDescStruct m = new PHBallJointNonLinearMotorDescStruct();
	    m.ApplyFrom(r, true);
	    return m;
	}
    }
    public partial class PHHumanBallJointResistanceDesc : PHBallJointNonLinearMotorDesc {
	public PHHumanBallJointResistanceDesc() { _thisArray[0] = SprExport.Spr_new_PHHumanBallJointResistanceDesc(); _flag = true; }
	public PHHumanBallJointResistanceDesc(IntPtr ptr) : base(ptr) {}
	public PHHumanBallJointResistanceDesc(IntPtr ptr, bool flag) : base(ptr, flag) {}
	~PHHumanBallJointResistanceDesc() { if (_flag) { SprExport.Spr_delete_PHHumanBallJointResistanceDesc(_thisArray[0]); _flag = false; } }
	public Vec4d xCoefficient {
	    get { return new Vec4d(SprExport.Spr_PHHumanBallJointResistanceDesc_addr_xCoefficient(_thisArray[0])); }
	    set { SprExport.Spr_PHHumanBallJointResistanceDesc_set_xCoefficient(_thisArray[0], value); }
	}
	public Vec4d yCoefficient {
	    get { return new Vec4d(SprExport.Spr_PHHumanBallJointResistanceDesc_addr_yCoefficient(_thisArray[0])); }
	    set { SprExport.Spr_PHHumanBallJointResistanceDesc_set_yCoefficient(_thisArray[0], value); }
	}
	public Vec4d zCoefficient {
	    get { return new Vec4d(SprExport.Spr_PHHumanBallJointResistanceDesc_addr_zCoefficient(_thisArray[0])); }
	    set { SprExport.Spr_PHHumanBallJointResistanceDesc_set_zCoefficient(_thisArray[0], value); }
	}
    }
    [System.Serializable]
    public class PHHumanBallJointResistanceDescStruct : PHBallJointNonLinearMotorDescStruct {
        public PHHumanBallJointResistanceDescStruct() {
            PHHumanBallJointResistanceDesc desc = new PHHumanBallJointResistanceDesc();
            ApplyFrom(desc, true);
        }
	public Vec4dStruct xCoefficient;
	public Vec4dStruct yCoefficient;
	public Vec4dStruct zCoefficient;
	public void ApplyTo(PHHumanBallJointResistanceDesc r, bool apply_to_base_class = false) {
		r.xCoefficient = xCoefficient;
		r.yCoefficient = yCoefficient;
		r.zCoefficient = zCoefficient;
		if (apply_to_base_class) {
		    base.ApplyTo(r, apply_to_base_class);
		}
	}
	public void ApplyFrom(PHHumanBallJointResistanceDesc r, bool apply_to_base_class = false) {
		xCoefficient = r.xCoefficient;
		yCoefficient = r.yCoefficient;
		zCoefficient = r.zCoefficient;
		if (apply_to_base_class) {
		    base.ApplyFrom(r, apply_to_base_class);
		}
	}
	public static implicit operator PHHumanBallJointResistanceDesc(PHHumanBallJointResistanceDescStruct m) {
	    PHHumanBallJointResistanceDesc r = new PHHumanBallJointResistanceDesc();
	    m.ApplyTo(r, true);
	    return r;
	}
	public static implicit operator PHHumanBallJointResistanceDescStruct(PHHumanBallJointResistanceDesc r) {
	    PHHumanBallJointResistanceDescStruct m = new PHHumanBallJointResistanceDescStruct();
	    m.ApplyFrom(r, true);
	    return m;
	}
    }
    public partial class PHSpringMotorDesc : CsObject {
	public PHSpringMotorDesc() { _thisArray[0] = SprExport.Spr_new_PHSpringMotorDesc(); _flag = true; }
	public PHSpringMotorDesc(IntPtr ptr) : base(ptr) {}
	public PHSpringMotorDesc(IntPtr ptr, bool flag) : base(ptr, flag) {}
	~PHSpringMotorDesc() { if (_flag) { SprExport.Spr_delete_PHSpringMotorDesc(_thisArray[0]); _flag = false; } }
    }
    [System.Serializable]
    public class PHSpringMotorDescStruct : CsObject {
        public PHSpringMotorDescStruct() {
            PHSpringMotorDesc desc = new PHSpringMotorDesc();
            ApplyFrom(desc, false);
        }
	public void ApplyTo(PHSpringMotorDesc r, bool apply_to_base_class = false) {
	}
	public void ApplyFrom(PHSpringMotorDesc r, bool apply_to_base_class = false) {
	}
	public static implicit operator PHSpringMotorDesc(PHSpringMotorDescStruct m) {
	    PHSpringMotorDesc r = new PHSpringMotorDesc();
	    m.ApplyTo(r, true);
	    return r;
	}
	public static implicit operator PHSpringMotorDescStruct(PHSpringMotorDesc r) {
	    PHSpringMotorDescStruct m = new PHSpringMotorDescStruct();
	    m.ApplyFrom(r, true);
	    return m;
	}
    }
    public partial class PHInactiveSolids : CsObject {
	public PHInactiveSolids() { _thisArray[0] = SprExport.Spr_new_PHInactiveSolids(); _flag = true; }
	public PHInactiveSolids(IntPtr ptr) : base(ptr) {}
	public PHInactiveSolids(IntPtr ptr, bool flag) : base(ptr, flag) {}
	~PHInactiveSolids() { if (_flag) { SprExport.Spr_delete_PHInactiveSolids(_thisArray[0]); _flag = false; } }
        public vectorwrapper_string solids {
            get { return new vectorwrapper_string(SprExport.Spr_PHInactiveSolids_addr_solids(_thisArray[0])); }
            set { SprExport.Spr_PHInactiveSolids_set_solids(_thisArray[0], value); }
        }
    }
    public partial class PHOpObjState : CsObject {
	public PHOpObjState() { _thisArray[0] = SprExport.Spr_new_PHOpObjState(); _flag = true; }
	public PHOpObjState(IntPtr ptr) : base(ptr) {}
	public PHOpObjState(IntPtr ptr, bool flag) : base(ptr, flag) {}
	~PHOpObjState() { if (_flag) { SprExport.Spr_delete_PHOpObjState(_thisArray[0]); _flag = false; } }
	public Vec3d velocity {
	    get { return new Vec3d(SprExport.Spr_PHOpObjState_addr_velocity(_thisArray[0])); }
	    set { SprExport.Spr_PHOpObjState_set_velocity(_thisArray[0], value); }
	}
	public Vec3d angVelocity {
	    get { return new Vec3d(SprExport.Spr_PHOpObjState_addr_angVelocity(_thisArray[0])); }
	    set { SprExport.Spr_PHOpObjState_set_angVelocity(_thisArray[0], value); }
	}
	public Posed pose {
	    get { return new Posed(SprExport.Spr_PHOpObjState_addr_pose(_thisArray[0])); }
	    set { SprExport.Spr_PHOpObjState_set_pose(_thisArray[0], value); }
	}
    }
    [System.Serializable]
    public class PHOpObjStateStruct : CsObject {
        public PHOpObjStateStruct() {
            PHOpObjState desc = new PHOpObjState();
            ApplyFrom(desc, false);
        }
	public Vec3dStruct velocity;
	public Vec3dStruct angVelocity;
	public PosedStruct pose;
	public void ApplyTo(PHOpObjState r, bool apply_to_base_class = false) {
		r.velocity = velocity;
		r.angVelocity = angVelocity;
		r.pose = pose;
	}
	public void ApplyFrom(PHOpObjState r, bool apply_to_base_class = false) {
		velocity = r.velocity;
		angVelocity = r.angVelocity;
		pose = r.pose;
	}
	public static implicit operator PHOpObjState(PHOpObjStateStruct m) {
	    PHOpObjState r = new PHOpObjState();
	    m.ApplyTo(r, true);
	    return r;
	}
	public static implicit operator PHOpObjStateStruct(PHOpObjState r) {
	    PHOpObjStateStruct m = new PHOpObjStateStruct();
	    m.ApplyFrom(r, true);
	    return m;
	}
    }
    public partial class PHOpHapticRendererDesc : CsObject {
	public PHOpHapticRendererDesc() { _thisArray[0] = SprExport.Spr_new_PHOpHapticRendererDesc(); _flag = true; }
	public PHOpHapticRendererDesc(IntPtr ptr) : base(ptr) {}
	public PHOpHapticRendererDesc(IntPtr ptr, bool flag) : base(ptr, flag) {}
	~PHOpHapticRendererDesc() { if (_flag) { SprExport.Spr_delete_PHOpHapticRendererDesc(_thisArray[0]); _flag = false; } }
	public float extForceSpring {
	    get { return SprExport.Spr_PHOpHapticRendererDesc_get_extForceSpring(_thisArray[0]); }
	    set { SprExport.Spr_PHOpHapticRendererDesc_set_extForceSpring(_thisArray[0], value); }
	}
	public float outForceSpring {
	    get { return SprExport.Spr_PHOpHapticRendererDesc_get_outForceSpring(_thisArray[0]); }
	    set { SprExport.Spr_PHOpHapticRendererDesc_set_outForceSpring(_thisArray[0], value); }
	}
	public float constraintSpring {
	    get { return SprExport.Spr_PHOpHapticRendererDesc_get_constraintSpring(_thisArray[0]); }
	    set { SprExport.Spr_PHOpHapticRendererDesc_set_constraintSpring(_thisArray[0], value); }
	}
	public float timeStep {
	    get { return SprExport.Spr_PHOpHapticRendererDesc_get_timeStep(_thisArray[0]); }
	    set { SprExport.Spr_PHOpHapticRendererDesc_set_timeStep(_thisArray[0], value); }
	}
	public float forceOnRadius {
	    get { return SprExport.Spr_PHOpHapticRendererDesc_get_forceOnRadius(_thisArray[0]); }
	    set { SprExport.Spr_PHOpHapticRendererDesc_set_forceOnRadius(_thisArray[0], value); }
	}
	public bool useConstrainForce {
	    get {
	        byte ret = (byte) SprExport.Spr_PHOpHapticRendererDesc_get_useConstrainForce(_thisArray[0]);
	        return (ret == 0) ? false : true;
	    }
	    set {
	        byte val = (byte) (value ? 1 : 0);
	        SprExport.Spr_PHOpHapticRendererDesc_set_useConstrainForce(_thisArray[0], (char) val);
	    }
	}
	public bool useProxyfixSubitr {
	    get {
	        byte ret = (byte) SprExport.Spr_PHOpHapticRendererDesc_get_useProxyfixSubitr(_thisArray[0]);
	        return (ret == 0) ? false : true;
	    }
	    set {
	        byte val = (byte) (value ? 1 : 0);
	        SprExport.Spr_PHOpHapticRendererDesc_set_useProxyfixSubitr(_thisArray[0], (char) val);
	    }
	}
	public bool useIncreaseMeshMove {
	    get {
	        byte ret = (byte) SprExport.Spr_PHOpHapticRendererDesc_get_useIncreaseMeshMove(_thisArray[0]);
	        return (ret == 0) ? false : true;
	    }
	    set {
	        byte val = (byte) (value ? 1 : 0);
	        SprExport.Spr_PHOpHapticRendererDesc_set_useIncreaseMeshMove(_thisArray[0], (char) val);
	    }
	}
	public bool sqrtAlphaForce {
	    get {
	        byte ret = (byte) SprExport.Spr_PHOpHapticRendererDesc_get_sqrtAlphaForce(_thisArray[0]);
	        return (ret == 0) ? false : true;
	    }
	    set {
	        byte val = (byte) (value ? 1 : 0);
	        SprExport.Spr_PHOpHapticRendererDesc_set_sqrtAlphaForce(_thisArray[0], (char) val);
	    }
	}
	public bool hitWall {
	    get {
	        byte ret = (byte) SprExport.Spr_PHOpHapticRendererDesc_get_hitWall(_thisArray[0]);
	        return (ret == 0) ? false : true;
	    }
	    set {
	        byte val = (byte) (value ? 1 : 0);
	        SprExport.Spr_PHOpHapticRendererDesc_set_hitWall(_thisArray[0], (char) val);
	    }
	}
	public bool useDualTranFix {
	    get {
	        byte ret = (byte) SprExport.Spr_PHOpHapticRendererDesc_get_useDualTranFix(_thisArray[0]);
	        return (ret == 0) ? false : true;
	    }
	    set {
	        byte val = (byte) (value ? 1 : 0);
	        SprExport.Spr_PHOpHapticRendererDesc_set_useDualTranFix(_thisArray[0], (char) val);
	    }
	}
	public bool rigid {
	    get {
	        byte ret = (byte) SprExport.Spr_PHOpHapticRendererDesc_get_rigid(_thisArray[0]);
	        return (ret == 0) ? false : true;
	    }
	    set {
	        byte val = (byte) (value ? 1 : 0);
	        SprExport.Spr_PHOpHapticRendererDesc_set_rigid(_thisArray[0], (char) val);
	    }
	}
	public int proxyItrtNum {
	    get { return SprExport.Spr_PHOpHapticRendererDesc_get_proxyItrtNum(_thisArray[0]); }
	    set { SprExport.Spr_PHOpHapticRendererDesc_set_proxyItrtNum(_thisArray[0], value); }
	}
	public int proxyItrtMaxNum {
	    get { return SprExport.Spr_PHOpHapticRendererDesc_get_proxyItrtMaxNum(_thisArray[0]); }
	    set { SprExport.Spr_PHOpHapticRendererDesc_set_proxyItrtMaxNum(_thisArray[0], value); }
	}
	public int currDtType {
	    get { return SprExport.Spr_PHOpHapticRendererDesc_get_currDtType(_thisArray[0]); }
	    set { SprExport.Spr_PHOpHapticRendererDesc_set_currDtType(_thisArray[0], value); }
	}
	public int objNum {
	    get { return SprExport.Spr_PHOpHapticRendererDesc_get_objNum(_thisArray[0]); }
	    set { SprExport.Spr_PHOpHapticRendererDesc_set_objNum(_thisArray[0], value); }
	}
	public int noCtcItrNum {
	    get { return SprExport.Spr_PHOpHapticRendererDesc_get_noCtcItrNum(_thisArray[0]); }
	    set { SprExport.Spr_PHOpHapticRendererDesc_set_noCtcItrNum(_thisArray[0], value); }
	}
	public Vec3f proxyFixPos {
	    get { return new Vec3f(SprExport.Spr_PHOpHapticRendererDesc_addr_proxyFixPos(_thisArray[0])); }
	    set { SprExport.Spr_PHOpHapticRendererDesc_set_proxyFixPos(_thisArray[0], value); }
	}
    }
    [System.Serializable]
    public class PHOpHapticRendererDescStruct : CsObject {
        public PHOpHapticRendererDescStruct() {
            PHOpHapticRendererDesc desc = new PHOpHapticRendererDesc();
            ApplyFrom(desc, false);
        }
	public float extForceSpring;
	public float outForceSpring;
	public float constraintSpring;
	public float timeStep;
	public float forceOnRadius;
	public bool useConstrainForce;
	public bool useProxyfixSubitr;
	public bool useIncreaseMeshMove;
	public bool sqrtAlphaForce;
	public bool hitWall;
	public bool useDualTranFix;
	public bool rigid;
	public int proxyItrtNum;
	public int proxyItrtMaxNum;
	public int currDtType;
	public int objNum;
	public int noCtcItrNum;
	public Vec3fStruct proxyFixPos;
	public void ApplyTo(PHOpHapticRendererDesc r, bool apply_to_base_class = false) {
		r.extForceSpring = extForceSpring;
		r.outForceSpring = outForceSpring;
		r.constraintSpring = constraintSpring;
		r.timeStep = timeStep;
		r.forceOnRadius = forceOnRadius;
		r.useConstrainForce = useConstrainForce;
		r.useProxyfixSubitr = useProxyfixSubitr;
		r.useIncreaseMeshMove = useIncreaseMeshMove;
		r.sqrtAlphaForce = sqrtAlphaForce;
		r.hitWall = hitWall;
		r.useDualTranFix = useDualTranFix;
		r.rigid = rigid;
		r.proxyItrtNum = proxyItrtNum;
		r.proxyItrtMaxNum = proxyItrtMaxNum;
		r.currDtType = currDtType;
		r.objNum = objNum;
		r.noCtcItrNum = noCtcItrNum;
		r.proxyFixPos = proxyFixPos;
	}
	public void ApplyFrom(PHOpHapticRendererDesc r, bool apply_to_base_class = false) {
		extForceSpring = r.extForceSpring;
		outForceSpring = r.outForceSpring;
		constraintSpring = r.constraintSpring;
		timeStep = r.timeStep;
		forceOnRadius = r.forceOnRadius;
		useConstrainForce = r.useConstrainForce;
		useProxyfixSubitr = r.useProxyfixSubitr;
		useIncreaseMeshMove = r.useIncreaseMeshMove;
		sqrtAlphaForce = r.sqrtAlphaForce;
		hitWall = r.hitWall;
		useDualTranFix = r.useDualTranFix;
		rigid = r.rigid;
		proxyItrtNum = r.proxyItrtNum;
		proxyItrtMaxNum = r.proxyItrtMaxNum;
		currDtType = r.currDtType;
		objNum = r.objNum;
		noCtcItrNum = r.noCtcItrNum;
		proxyFixPos = r.proxyFixPos;
	}
	public static implicit operator PHOpHapticRendererDesc(PHOpHapticRendererDescStruct m) {
	    PHOpHapticRendererDesc r = new PHOpHapticRendererDesc();
	    m.ApplyTo(r, true);
	    return r;
	}
	public static implicit operator PHOpHapticRendererDescStruct(PHOpHapticRendererDesc r) {
	    PHOpHapticRendererDescStruct m = new PHOpHapticRendererDescStruct();
	    m.ApplyFrom(r, true);
	    return m;
	}
    }
    public partial class PHOpObjDesc : PHOpObjState {
	public PHOpObjDesc() { _thisArray[0] = SprExport.Spr_new_PHOpObjDesc(); _flag = true; }
	public PHOpObjDesc(IntPtr ptr) : base(ptr) {}
	public PHOpObjDesc(IntPtr ptr, bool flag) : base(ptr, flag) {}
	~PHOpObjDesc() { if (_flag) { SprExport.Spr_delete_PHOpObjDesc(_thisArray[0]); _flag = false; } }
	public double mass {
	    get { return SprExport.Spr_PHOpObjDesc_get_mass(_thisArray[0]); }
	    set { SprExport.Spr_PHOpObjDesc_set_mass(_thisArray[0], value); }
	}
	public Matrix3d inertia {
	    get { return new Matrix3d(SprExport.Spr_PHOpObjDesc_addr_inertia(_thisArray[0])); }
	    set { SprExport.Spr_PHOpObjDesc_set_inertia(_thisArray[0], value); }
	}
	public Vec3d center {
	    get { return new Vec3d(SprExport.Spr_PHOpObjDesc_addr_center(_thisArray[0])); }
	    set { SprExport.Spr_PHOpObjDesc_set_center(_thisArray[0], value); }
	}
	public bool dynamical {
	    get {
	        byte ret = (byte) SprExport.Spr_PHOpObjDesc_get_dynamical(_thisArray[0]);
	        return (ret == 0) ? false : true;
	    }
	    set {
	        byte val = (byte) (value ? 1 : 0);
	        SprExport.Spr_PHOpObjDesc_set_dynamical(_thisArray[0], (char) val);
	    }
	}
	public Vec3f objTargetVts {
	    get { return new Vec3f(SprExport.Spr_PHOpObjDesc_get_objTargetVts(_thisArray[0])); }
	    set { SprExport.Spr_PHOpObjDesc_set_objTargetVts(_thisArray[0], value); }
	}
        public arraywrapper_float objTargetVtsArr {
            get { return new arraywrapper_float(SprExport.Spr_PHOpObjDesc_addr_objTargetVtsArr(_thisArray[0])); }
            set { SprExport.Spr_PHOpObjDesc_set_objTargetVtsArr(_thisArray[0], value); }
        }
	public int objTargetVtsNum {
	    get { return SprExport.Spr_PHOpObjDesc_get_objTargetVtsNum(_thisArray[0]); }
	    set { SprExport.Spr_PHOpObjDesc_set_objTargetVtsNum(_thisArray[0], value); }
	}
	public int assPsNum {
	    get { return SprExport.Spr_PHOpObjDesc_get_assPsNum(_thisArray[0]); }
	    set { SprExport.Spr_PHOpObjDesc_set_assPsNum(_thisArray[0], value); }
	}
	public int assGrpNum {
	    get { return SprExport.Spr_PHOpObjDesc_get_assGrpNum(_thisArray[0]); }
	    set { SprExport.Spr_PHOpObjDesc_set_assGrpNum(_thisArray[0], value); }
	}
	public int objGrouplinkCount {
	    get { return SprExport.Spr_PHOpObjDesc_get_objGrouplinkCount(_thisArray[0]); }
	    set { SprExport.Spr_PHOpObjDesc_set_objGrouplinkCount(_thisArray[0], value); }
	}
	public int objId {
	    get { return SprExport.Spr_PHOpObjDesc_get_objId(_thisArray[0]); }
	    set { SprExport.Spr_PHOpObjDesc_set_objId(_thisArray[0], value); }
	}
	public bool objUseDistCstr {
	    get {
	        byte ret = (byte) SprExport.Spr_PHOpObjDesc_get_objUseDistCstr(_thisArray[0]);
	        return (ret == 0) ? false : true;
	    }
	    set {
	        byte val = (byte) (value ? 1 : 0);
	        SprExport.Spr_PHOpObjDesc_set_objUseDistCstr(_thisArray[0], (char) val);
	    }
	}
	public bool objNoMeshObj {
	    get {
	        byte ret = (byte) SprExport.Spr_PHOpObjDesc_get_objNoMeshObj(_thisArray[0]);
	        return (ret == 0) ? false : true;
	    }
	    set {
	        byte val = (byte) (value ? 1 : 0);
	        SprExport.Spr_PHOpObjDesc_set_objNoMeshObj(_thisArray[0], (char) val);
	    }
	}
	public bool isRigid {
	    get {
	        byte ret = (byte) SprExport.Spr_PHOpObjDesc_get_isRigid(_thisArray[0]);
	        return (ret == 0) ? false : true;
	    }
	    set {
	        byte val = (byte) (value ? 1 : 0);
	        SprExport.Spr_PHOpObjDesc_set_isRigid(_thisArray[0], (char) val);
	    }
	}
	public int objType {
	    get { return SprExport.Spr_PHOpObjDesc_get_objType(_thisArray[0]); }
	    set { SprExport.Spr_PHOpObjDesc_set_objType(_thisArray[0], value); }
	}
	public float objAverRadius {
	    get { return SprExport.Spr_PHOpObjDesc_get_objAverRadius(_thisArray[0]); }
	    set { SprExport.Spr_PHOpObjDesc_set_objAverRadius(_thisArray[0], value); }
	}
	public float objMaxRadius {
	    get { return SprExport.Spr_PHOpObjDesc_get_objMaxRadius(_thisArray[0]); }
	    set { SprExport.Spr_PHOpObjDesc_set_objMaxRadius(_thisArray[0], value); }
	}
	public int objitrTime {
	    get { return SprExport.Spr_PHOpObjDesc_get_objitrTime(_thisArray[0]); }
	    set { SprExport.Spr_PHOpObjDesc_set_objitrTime(_thisArray[0], value); }
	}
	public bool updateNormals {
	    get {
	        byte ret = (byte) SprExport.Spr_PHOpObjDesc_get_updateNormals(_thisArray[0]);
	        return (ret == 0) ? false : true;
	    }
	    set {
	        byte val = (byte) (value ? 1 : 0);
	        SprExport.Spr_PHOpObjDesc_set_updateNormals(_thisArray[0], (char) val);
	    }
	}
	public void Init() {
	    SprExport.Spr_PHOpObjDesc_Init((IntPtr) _thisArray[0]);
	}
    }
    [System.Serializable]
    public class PHOpObjDescStruct : PHOpObjStateStruct {
        public PHOpObjDescStruct() {
            PHOpObjDesc desc = new PHOpObjDesc();
            ApplyFrom(desc, false);
        }
	public double mass;
	public Matrix3dStruct inertia;
	public Vec3dStruct center;
	public bool dynamical;
	public Vec3fStruct objTargetVts;
	public arraywrapper_float objTargetVtsArr;
	public int objTargetVtsNum;
	public int assPsNum;
	public int assGrpNum;
	public int objGrouplinkCount;
	public int objId;
	public bool objUseDistCstr;
	public bool objNoMeshObj;
	public bool isRigid;
	public int objType;
	public float objAverRadius;
	public float objMaxRadius;
	public int objitrTime;
	public bool updateNormals;
	public void ApplyTo(PHOpObjDesc r, bool apply_to_base_class = false) {
		r.mass = mass;
		r.inertia = inertia;
		r.center = center;
		r.dynamical = dynamical;
		r.objTargetVts = objTargetVts;
		r.objTargetVtsArr = objTargetVtsArr;
		r.objTargetVtsNum = objTargetVtsNum;
		r.assPsNum = assPsNum;
		r.assGrpNum = assGrpNum;
		r.objGrouplinkCount = objGrouplinkCount;
		r.objId = objId;
		r.objUseDistCstr = objUseDistCstr;
		r.objNoMeshObj = objNoMeshObj;
		r.isRigid = isRigid;
		r.objType = objType;
		r.objAverRadius = objAverRadius;
		r.objMaxRadius = objMaxRadius;
		r.objitrTime = objitrTime;
		r.updateNormals = updateNormals;
	}
	public void ApplyFrom(PHOpObjDesc r, bool apply_to_base_class = false) {
		mass = r.mass;
		inertia = r.inertia;
		center = r.center;
		dynamical = r.dynamical;
		objTargetVts = r.objTargetVts;
		objTargetVtsArr = r.objTargetVtsArr;
		objTargetVtsNum = r.objTargetVtsNum;
		assPsNum = r.assPsNum;
		assGrpNum = r.assGrpNum;
		objGrouplinkCount = r.objGrouplinkCount;
		objId = r.objId;
		objUseDistCstr = r.objUseDistCstr;
		objNoMeshObj = r.objNoMeshObj;
		isRigid = r.isRigid;
		objType = r.objType;
		objAverRadius = r.objAverRadius;
		objMaxRadius = r.objMaxRadius;
		objitrTime = r.objitrTime;
		updateNormals = r.updateNormals;
	}
	public static implicit operator PHOpObjDesc(PHOpObjDescStruct m) {
	    PHOpObjDesc r = new PHOpObjDesc();
	    m.ApplyTo(r, true);
	    return r;
	}
	public static implicit operator PHOpObjDescStruct(PHOpObjDesc r) {
	    PHOpObjDescStruct m = new PHOpObjDescStruct();
	    m.ApplyFrom(r, true);
	    return m;
	}
    }
    public partial class PHOpParticleDesc : CsObject {
	public PHOpParticleDesc() { _thisArray[0] = SprExport.Spr_new_PHOpParticleDesc(); _flag = true; }
	public PHOpParticleDesc(IntPtr ptr) : base(ptr) {}
	public PHOpParticleDesc(IntPtr ptr, bool flag) : base(ptr, flag) {}
	~PHOpParticleDesc() { if (_flag) { SprExport.Spr_delete_PHOpParticleDesc(_thisArray[0]); _flag = false; } }
	public int pNvertex {
	    get { return SprExport.Spr_PHOpParticleDesc_get_pNvertex(_thisArray[0]); }
	    set { SprExport.Spr_PHOpParticleDesc_set_pNvertex(_thisArray[0], value); }
	}
	public int pMyGroupInd {
	    get { return SprExport.Spr_PHOpParticleDesc_get_pMyGroupInd(_thisArray[0]); }
	    set { SprExport.Spr_PHOpParticleDesc_set_pMyGroupInd(_thisArray[0], value); }
	}
	public int pPId {
	    get { return SprExport.Spr_PHOpParticleDesc_get_pPId(_thisArray[0]); }
	    set { SprExport.Spr_PHOpParticleDesc_set_pPId(_thisArray[0], value); }
	}
	public int pObjId {
	    get { return SprExport.Spr_PHOpParticleDesc_get_pObjId(_thisArray[0]); }
	    set { SprExport.Spr_PHOpParticleDesc_set_pObjId(_thisArray[0], value); }
	}
	public float pParaAlpha {
	    get { return SprExport.Spr_PHOpParticleDesc_get_pParaAlpha(_thisArray[0]); }
	    set { SprExport.Spr_PHOpParticleDesc_set_pParaAlpha(_thisArray[0], value); }
	}
	public bool hitedByMouse {
	    get {
	        byte ret = (byte) SprExport.Spr_PHOpParticleDesc_get_hitedByMouse(_thisArray[0]);
	        return (ret == 0) ? false : true;
	    }
	    set {
	        byte val = (byte) (value ? 1 : 0);
	        SprExport.Spr_PHOpParticleDesc_set_hitedByMouse(_thisArray[0], (char) val);
	    }
	}
	public float pSingleVMass {
	    get { return SprExport.Spr_PHOpParticleDesc_get_pSingleVMass(_thisArray[0]); }
	    set { SprExport.Spr_PHOpParticleDesc_set_pSingleVMass(_thisArray[0], value); }
	}
	public float pTotalMass {
	    get { return SprExport.Spr_PHOpParticleDesc_get_pTotalMass(_thisArray[0]); }
	    set { SprExport.Spr_PHOpParticleDesc_set_pTotalMass(_thisArray[0], value); }
	}
	public float pRadii {
	    get { return SprExport.Spr_PHOpParticleDesc_get_pRadii(_thisArray[0]); }
	    set { SprExport.Spr_PHOpParticleDesc_set_pRadii(_thisArray[0], value); }
	}
	public float pDynamicRadius {
	    get { return SprExport.Spr_PHOpParticleDesc_get_pDynamicRadius(_thisArray[0]); }
	    set { SprExport.Spr_PHOpParticleDesc_set_pDynamicRadius(_thisArray[0], value); }
	}
	public Vec3f pMainRadiusVec {
	    get { return new Vec3f(SprExport.Spr_PHOpParticleDesc_addr_pMainRadiusVec(_thisArray[0])); }
	    set { SprExport.Spr_PHOpParticleDesc_set_pMainRadiusVec(_thisArray[0], value); }
	}
	public Vec3f pSecRadiusVec {
	    get { return new Vec3f(SprExport.Spr_PHOpParticleDesc_addr_pSecRadiusVec(_thisArray[0])); }
	    set { SprExport.Spr_PHOpParticleDesc_set_pSecRadiusVec(_thisArray[0], value); }
	}
	public Vec3f pThrRadiusVec {
	    get { return new Vec3f(SprExport.Spr_PHOpParticleDesc_addr_pThrRadiusVec(_thisArray[0])); }
	    set { SprExport.Spr_PHOpParticleDesc_set_pThrRadiusVec(_thisArray[0], value); }
	}
	public float pMainRadius {
	    get { return SprExport.Spr_PHOpParticleDesc_get_pMainRadius(_thisArray[0]); }
	    set { SprExport.Spr_PHOpParticleDesc_set_pMainRadius(_thisArray[0], value); }
	}
	public float pSecRadius {
	    get { return SprExport.Spr_PHOpParticleDesc_get_pSecRadius(_thisArray[0]); }
	    set { SprExport.Spr_PHOpParticleDesc_set_pSecRadius(_thisArray[0], value); }
	}
	public float pThrRadius {
	    get { return SprExport.Spr_PHOpParticleDesc_get_pThrRadius(_thisArray[0]); }
	    set { SprExport.Spr_PHOpParticleDesc_set_pThrRadius(_thisArray[0], value); }
	}
	public Vec3f pCurrCtr {
	    get { return new Vec3f(SprExport.Spr_PHOpParticleDesc_addr_pCurrCtr(_thisArray[0])); }
	    set { SprExport.Spr_PHOpParticleDesc_set_pCurrCtr(_thisArray[0], value); }
	}
	public Vec3f pOrigCtr {
	    get { return new Vec3f(SprExport.Spr_PHOpParticleDesc_addr_pOrigCtr(_thisArray[0])); }
	    set { SprExport.Spr_PHOpParticleDesc_set_pOrigCtr(_thisArray[0], value); }
	}
	public Vec3f pNewCtr {
	    get { return new Vec3f(SprExport.Spr_PHOpParticleDesc_addr_pNewCtr(_thisArray[0])); }
	    set { SprExport.Spr_PHOpParticleDesc_set_pNewCtr(_thisArray[0], value); }
	}
	public Vec3f pVelocity {
	    get { return new Vec3f(SprExport.Spr_PHOpParticleDesc_addr_pVelocity(_thisArray[0])); }
	    set { SprExport.Spr_PHOpParticleDesc_set_pVelocity(_thisArray[0], value); }
	}
	public bool isColliedbySphash {
	    get {
	        byte ret = (byte) SprExport.Spr_PHOpParticleDesc_get_isColliedbySphash(_thisArray[0]);
	        return (ret == 0) ? false : true;
	    }
	    set {
	        byte val = (byte) (value ? 1 : 0);
	        SprExport.Spr_PHOpParticleDesc_set_isColliedbySphash(_thisArray[0], (char) val);
	    }
	}
	public bool isColliedbyColliCube {
	    get {
	        byte ret = (byte) SprExport.Spr_PHOpParticleDesc_get_isColliedbyColliCube(_thisArray[0]);
	        return (ret == 0) ? false : true;
	    }
	    set {
	        byte val = (byte) (value ? 1 : 0);
	        SprExport.Spr_PHOpParticleDesc_set_isColliedbyColliCube(_thisArray[0], (char) val);
	    }
	}
	public bool isFixedbyMouse {
	    get {
	        byte ret = (byte) SprExport.Spr_PHOpParticleDesc_get_isFixedbyMouse(_thisArray[0]);
	        return (ret == 0) ? false : true;
	    }
	    set {
	        byte val = (byte) (value ? 1 : 0);
	        SprExport.Spr_PHOpParticleDesc_set_isFixedbyMouse(_thisArray[0], (char) val);
	    }
	}
	public bool isFixed {
	    get {
	        byte ret = (byte) SprExport.Spr_PHOpParticleDesc_get_isFixed(_thisArray[0]);
	        return (ret == 0) ? false : true;
	    }
	    set {
	        byte val = (byte) (value ? 1 : 0);
	        SprExport.Spr_PHOpParticleDesc_set_isFixed(_thisArray[0], (char) val);
	    }
	}
	public bool isColliedSphashSolved {
	    get {
	        byte ret = (byte) SprExport.Spr_PHOpParticleDesc_get_isColliedSphashSolved(_thisArray[0]);
	        return (ret == 0) ? false : true;
	    }
	    set {
	        byte val = (byte) (value ? 1 : 0);
	        SprExport.Spr_PHOpParticleDesc_set_isColliedSphashSolved(_thisArray[0], (char) val);
	    }
	}
	public bool isColliedSphashSolvedReady {
	    get {
	        byte ret = (byte) SprExport.Spr_PHOpParticleDesc_get_isColliedSphashSolvedReady(_thisArray[0]);
	        return (ret == 0) ? false : true;
	    }
	    set {
	        byte val = (byte) (value ? 1 : 0);
	        SprExport.Spr_PHOpParticleDesc_set_isColliedSphashSolvedReady(_thisArray[0], (char) val);
	    }
	}
	public Vec3f pExternalForce {
	    get { return new Vec3f(SprExport.Spr_PHOpParticleDesc_addr_pExternalForce(_thisArray[0])); }
	    set { SprExport.Spr_PHOpParticleDesc_set_pExternalForce(_thisArray[0], value); }
	}
	public Vec3f pExternalTorque {
	    get { return new Vec3f(SprExport.Spr_PHOpParticleDesc_addr_pExternalTorque(_thisArray[0])); }
	    set { SprExport.Spr_PHOpParticleDesc_set_pExternalTorque(_thisArray[0], value); }
	}
	public Vec3f pExternalDisplacement {
	    get { return new Vec3f(SprExport.Spr_PHOpParticleDesc_addr_pExternalDisplacement(_thisArray[0])); }
	    set { SprExport.Spr_PHOpParticleDesc_set_pExternalDisplacement(_thisArray[0], value); }
	}
        public vectorwrapper_int pFaceInd {
            get { return new vectorwrapper_int(SprExport.Spr_PHOpParticleDesc_addr_pFaceInd(_thisArray[0])); }
            set { SprExport.Spr_PHOpParticleDesc_set_pFaceInd(_thisArray[0], value); }
        }
	public Matrix3f pMomentR {
	    get { return new Matrix3f(SprExport.Spr_PHOpParticleDesc_addr_pMomentR(_thisArray[0])); }
	    set { SprExport.Spr_PHOpParticleDesc_set_pMomentR(_thisArray[0], value); }
	}
	public Matrix3f pSmR {
	    get { return new Matrix3f(SprExport.Spr_PHOpParticleDesc_addr_pSmR(_thisArray[0])); }
	    set { SprExport.Spr_PHOpParticleDesc_set_pSmR(_thisArray[0], value); }
	}
	public Matrix3f pMomentInertia {
	    get { return new Matrix3f(SprExport.Spr_PHOpParticleDesc_addr_pMomentInertia(_thisArray[0])); }
	    set { SprExport.Spr_PHOpParticleDesc_set_pMomentInertia(_thisArray[0], value); }
	}
	public Matrix3f pInverseOfMomentInertia {
	    get { return new Matrix3f(SprExport.Spr_PHOpParticleDesc_addr_pInverseOfMomentInertia(_thisArray[0])); }
	    set { SprExport.Spr_PHOpParticleDesc_set_pInverseOfMomentInertia(_thisArray[0], value); }
	}
	public Matrix3f ellipRotMatrix {
	    get { return new Matrix3f(SprExport.Spr_PHOpParticleDesc_addr_ellipRotMatrix(_thisArray[0])); }
	    set { SprExport.Spr_PHOpParticleDesc_set_ellipRotMatrix(_thisArray[0], value); }
	}
	public Quaternionf ellipOrigOrint {
	    get { return new Quaternionf(SprExport.Spr_PHOpParticleDesc_addr_ellipOrigOrint(_thisArray[0])); }
	    set { SprExport.Spr_PHOpParticleDesc_set_ellipOrigOrint(_thisArray[0], value); }
	}
	public Vec3f pWvel {
	    get { return new Vec3f(SprExport.Spr_PHOpParticleDesc_addr_pWvel(_thisArray[0])); }
	    set { SprExport.Spr_PHOpParticleDesc_set_pWvel(_thisArray[0], value); }
	}
	public Matrix3f pPreEllipA {
	    get { return new Matrix3f(SprExport.Spr_PHOpParticleDesc_addr_pPreEllipA(_thisArray[0])); }
	    set { SprExport.Spr_PHOpParticleDesc_set_pPreEllipA(_thisArray[0], value); }
	}
	public Quaternionf pCurrOrint {
	    get { return new Quaternionf(SprExport.Spr_PHOpParticleDesc_addr_pCurrOrint(_thisArray[0])); }
	    set { SprExport.Spr_PHOpParticleDesc_set_pCurrOrint(_thisArray[0], value); }
	}
	public Quaternionf pOrigOrint {
	    get { return new Quaternionf(SprExport.Spr_PHOpParticleDesc_addr_pOrigOrint(_thisArray[0])); }
	    set { SprExport.Spr_PHOpParticleDesc_set_pOrigOrint(_thisArray[0], value); }
	}
	public Quaternionf pNewOrint {
	    get { return new Quaternionf(SprExport.Spr_PHOpParticleDesc_addr_pNewOrint(_thisArray[0])); }
	    set { SprExport.Spr_PHOpParticleDesc_set_pNewOrint(_thisArray[0], value); }
	}
    }
    [System.Serializable]
    public class PHOpParticleDescStruct : CsObject {
        public PHOpParticleDescStruct() {
            PHOpParticleDesc desc = new PHOpParticleDesc();
            ApplyFrom(desc, false);
        }
	public int pNvertex;
	public int pMyGroupInd;
	public int pPId;
	public int pObjId;
	public float pParaAlpha;
	public bool hitedByMouse;
	public float pSingleVMass;
	public float pTotalMass;
	public float pRadii;
	public float pDynamicRadius;
	public Vec3fStruct pMainRadiusVec;
	public Vec3fStruct pSecRadiusVec;
	public Vec3fStruct pThrRadiusVec;
	public float pMainRadius;
	public float pSecRadius;
	public float pThrRadius;
	public Vec3fStruct pCurrCtr;
	public Vec3fStruct pOrigCtr;
	public Vec3fStruct pNewCtr;
	public Vec3fStruct pVelocity;
	public bool isColliedbySphash;
	public bool isColliedbyColliCube;
	public bool isFixedbyMouse;
	public bool isFixed;
	public bool isColliedSphashSolved;
	public bool isColliedSphashSolvedReady;
	public Vec3fStruct pExternalForce;
	public Vec3fStruct pExternalTorque;
	public Vec3fStruct pExternalDisplacement;
	public vectorwrapper_int pFaceInd;
	public Matrix3fStruct pMomentR;
	public Matrix3fStruct pSmR;
	public Matrix3fStruct pMomentInertia;
	public Matrix3fStruct pInverseOfMomentInertia;
	public Matrix3fStruct ellipRotMatrix;
	public QuaternionfStruct ellipOrigOrint;
	public Vec3fStruct pWvel;
	public Matrix3fStruct pPreEllipA;
	public QuaternionfStruct pCurrOrint;
	public QuaternionfStruct pOrigOrint;
	public QuaternionfStruct pNewOrint;
	public void ApplyTo(PHOpParticleDesc r, bool apply_to_base_class = false) {
		r.pNvertex = pNvertex;
		r.pMyGroupInd = pMyGroupInd;
		r.pPId = pPId;
		r.pObjId = pObjId;
		r.pParaAlpha = pParaAlpha;
		r.hitedByMouse = hitedByMouse;
		r.pSingleVMass = pSingleVMass;
		r.pTotalMass = pTotalMass;
		r.pRadii = pRadii;
		r.pDynamicRadius = pDynamicRadius;
		r.pMainRadiusVec = pMainRadiusVec;
		r.pSecRadiusVec = pSecRadiusVec;
		r.pThrRadiusVec = pThrRadiusVec;
		r.pMainRadius = pMainRadius;
		r.pSecRadius = pSecRadius;
		r.pThrRadius = pThrRadius;
		r.pCurrCtr = pCurrCtr;
		r.pOrigCtr = pOrigCtr;
		r.pNewCtr = pNewCtr;
		r.pVelocity = pVelocity;
		r.isColliedbySphash = isColliedbySphash;
		r.isColliedbyColliCube = isColliedbyColliCube;
		r.isFixedbyMouse = isFixedbyMouse;
		r.isFixed = isFixed;
		r.isColliedSphashSolved = isColliedSphashSolved;
		r.isColliedSphashSolvedReady = isColliedSphashSolvedReady;
		r.pExternalForce = pExternalForce;
		r.pExternalTorque = pExternalTorque;
		r.pExternalDisplacement = pExternalDisplacement;
		r.pFaceInd = pFaceInd;
		r.pMomentR = pMomentR;
		r.pSmR = pSmR;
		r.pMomentInertia = pMomentInertia;
		r.pInverseOfMomentInertia = pInverseOfMomentInertia;
		r.ellipRotMatrix = ellipRotMatrix;
		r.ellipOrigOrint = ellipOrigOrint;
		r.pWvel = pWvel;
		r.pPreEllipA = pPreEllipA;
		r.pCurrOrint = pCurrOrint;
		r.pOrigOrint = pOrigOrint;
		r.pNewOrint = pNewOrint;
	}
	public void ApplyFrom(PHOpParticleDesc r, bool apply_to_base_class = false) {
		pNvertex = r.pNvertex;
		pMyGroupInd = r.pMyGroupInd;
		pPId = r.pPId;
		pObjId = r.pObjId;
		pParaAlpha = r.pParaAlpha;
		hitedByMouse = r.hitedByMouse;
		pSingleVMass = r.pSingleVMass;
		pTotalMass = r.pTotalMass;
		pRadii = r.pRadii;
		pDynamicRadius = r.pDynamicRadius;
		pMainRadiusVec = r.pMainRadiusVec;
		pSecRadiusVec = r.pSecRadiusVec;
		pThrRadiusVec = r.pThrRadiusVec;
		pMainRadius = r.pMainRadius;
		pSecRadius = r.pSecRadius;
		pThrRadius = r.pThrRadius;
		pCurrCtr = r.pCurrCtr;
		pOrigCtr = r.pOrigCtr;
		pNewCtr = r.pNewCtr;
		pVelocity = r.pVelocity;
		isColliedbySphash = r.isColliedbySphash;
		isColliedbyColliCube = r.isColliedbyColliCube;
		isFixedbyMouse = r.isFixedbyMouse;
		isFixed = r.isFixed;
		isColliedSphashSolved = r.isColliedSphashSolved;
		isColliedSphashSolvedReady = r.isColliedSphashSolvedReady;
		pExternalForce = r.pExternalForce;
		pExternalTorque = r.pExternalTorque;
		pExternalDisplacement = r.pExternalDisplacement;
		pFaceInd = r.pFaceInd;
		pMomentR = r.pMomentR;
		pSmR = r.pSmR;
		pMomentInertia = r.pMomentInertia;
		pInverseOfMomentInertia = r.pInverseOfMomentInertia;
		ellipRotMatrix = r.ellipRotMatrix;
		ellipOrigOrint = r.ellipOrigOrint;
		pWvel = r.pWvel;
		pPreEllipA = r.pPreEllipA;
		pCurrOrint = r.pCurrOrint;
		pOrigOrint = r.pOrigOrint;
		pNewOrint = r.pNewOrint;
	}
	public static implicit operator PHOpParticleDesc(PHOpParticleDescStruct m) {
	    PHOpParticleDesc r = new PHOpParticleDesc();
	    m.ApplyTo(r, true);
	    return r;
	}
	public static implicit operator PHOpParticleDescStruct(PHOpParticleDesc r) {
	    PHOpParticleDescStruct m = new PHOpParticleDescStruct();
	    m.ApplyFrom(r, true);
	    return m;
	}
    }
    public partial class PHOpGroupDesc : CsObject {
	public PHOpGroupDesc() { _thisArray[0] = SprExport.Spr_new_PHOpGroupDesc(); _flag = true; }
	public PHOpGroupDesc(IntPtr ptr) : base(ptr) {}
	public PHOpGroupDesc(IntPtr ptr, bool flag) : base(ptr, flag) {}
	~PHOpGroupDesc() { if (_flag) { SprExport.Spr_delete_PHOpGroupDesc(_thisArray[0]); _flag = false; } }
	public int gMyIndex {
	    get { return SprExport.Spr_PHOpGroupDesc_get_gMyIndex(_thisArray[0]); }
	    set { SprExport.Spr_PHOpGroupDesc_set_gMyIndex(_thisArray[0], value); }
	}
	public Matrix3f gAgroup {
	    get { return new Matrix3f(SprExport.Spr_PHOpGroupDesc_addr_gAgroup(_thisArray[0])); }
	    set { SprExport.Spr_PHOpGroupDesc_set_gAgroup(_thisArray[0], value); }
	}
	public Matrix3f gEigen {
	    get { return new Matrix3f(SprExport.Spr_PHOpGroupDesc_addr_gEigen(_thisArray[0])); }
	    set { SprExport.Spr_PHOpGroupDesc_set_gEigen(_thisArray[0], value); }
	}
	public float gtotalMass {
	    get { return SprExport.Spr_PHOpGroupDesc_get_gtotalMass(_thisArray[0]); }
	    set { SprExport.Spr_PHOpGroupDesc_set_gtotalMass(_thisArray[0], value); }
	}
	public Vec3f gOrigCenter {
	    get { return new Vec3f(SprExport.Spr_PHOpGroupDesc_addr_gOrigCenter(_thisArray[0])); }
	    set { SprExport.Spr_PHOpGroupDesc_set_gOrigCenter(_thisArray[0], value); }
	}
	public Vec3f gCurrCenter {
	    get { return new Vec3f(SprExport.Spr_PHOpGroupDesc_addr_gCurrCenter(_thisArray[0])); }
	    set { SprExport.Spr_PHOpGroupDesc_set_gCurrCenter(_thisArray[0], value); }
	}
	public int gNptcl {
	    get { return SprExport.Spr_PHOpGroupDesc_get_gNptcl(_thisArray[0]); }
	    set { SprExport.Spr_PHOpGroupDesc_set_gNptcl(_thisArray[0], value); }
	}
    }
    [System.Serializable]
    public class PHOpGroupDescStruct : CsObject {
        public PHOpGroupDescStruct() {
            PHOpGroupDesc desc = new PHOpGroupDesc();
            ApplyFrom(desc, false);
        }
	public int gMyIndex;
	public Matrix3fStruct gAgroup;
	public Matrix3fStruct gEigen;
	public float gtotalMass;
	public Vec3fStruct gOrigCenter;
	public Vec3fStruct gCurrCenter;
	public int gNptcl;
	public void ApplyTo(PHOpGroupDesc r, bool apply_to_base_class = false) {
		r.gMyIndex = gMyIndex;
		r.gAgroup = gAgroup;
		r.gEigen = gEigen;
		r.gtotalMass = gtotalMass;
		r.gOrigCenter = gOrigCenter;
		r.gCurrCenter = gCurrCenter;
		r.gNptcl = gNptcl;
	}
	public void ApplyFrom(PHOpGroupDesc r, bool apply_to_base_class = false) {
		gMyIndex = r.gMyIndex;
		gAgroup = r.gAgroup;
		gEigen = r.gEigen;
		gtotalMass = r.gtotalMass;
		gOrigCenter = r.gOrigCenter;
		gCurrCenter = r.gCurrCenter;
		gNptcl = r.gNptcl;
	}
	public static implicit operator PHOpGroupDesc(PHOpGroupDescStruct m) {
	    PHOpGroupDesc r = new PHOpGroupDesc();
	    m.ApplyTo(r, true);
	    return r;
	}
	public static implicit operator PHOpGroupDescStruct(PHOpGroupDesc r) {
	    PHOpGroupDescStruct m = new PHOpGroupDescStruct();
	    m.ApplyFrom(r, true);
	    return m;
	}
    }
    public partial class PHOpHapticControllerDesc : CsObject {
	public PHOpHapticControllerDesc() { _thisArray[0] = SprExport.Spr_new_PHOpHapticControllerDesc(); _flag = true; }
	public PHOpHapticControllerDesc(IntPtr ptr) : base(ptr) {}
	public PHOpHapticControllerDesc(IntPtr ptr, bool flag) : base(ptr, flag) {}
	~PHOpHapticControllerDesc() { if (_flag) { SprExport.Spr_delete_PHOpHapticControllerDesc(_thisArray[0]); _flag = false; } }
	public float posScale {
	    get { return SprExport.Spr_PHOpHapticControllerDesc_get_posScale(_thisArray[0]); }
	    set { SprExport.Spr_PHOpHapticControllerDesc_set_posScale(_thisArray[0], value); }
	}
	public float rotScale {
	    get { return SprExport.Spr_PHOpHapticControllerDesc_get_rotScale(_thisArray[0]); }
	    set { SprExport.Spr_PHOpHapticControllerDesc_set_rotScale(_thisArray[0], value); }
	}
	public float forceScale {
	    get { return SprExport.Spr_PHOpHapticControllerDesc_get_forceScale(_thisArray[0]); }
	    set { SprExport.Spr_PHOpHapticControllerDesc_set_forceScale(_thisArray[0], value); }
	}
	public Vec3f userPos {
	    get { return new Vec3f(SprExport.Spr_PHOpHapticControllerDesc_addr_userPos(_thisArray[0])); }
	    set { SprExport.Spr_PHOpHapticControllerDesc_set_userPos(_thisArray[0], value); }
	}
	public Posef userPose {
	    get { return new Posef(SprExport.Spr_PHOpHapticControllerDesc_addr_userPose(_thisArray[0])); }
	    set { SprExport.Spr_PHOpHapticControllerDesc_set_userPose(_thisArray[0], value); }
	}
	public Vec3f hcCurrPPos {
	    get { return new Vec3f(SprExport.Spr_PHOpHapticControllerDesc_addr_hcCurrPPos(_thisArray[0])); }
	    set { SprExport.Spr_PHOpHapticControllerDesc_set_hcCurrPPos(_thisArray[0], value); }
	}
	public Vec3f hcCurrUPos {
	    get { return new Vec3f(SprExport.Spr_PHOpHapticControllerDesc_addr_hcCurrUPos(_thisArray[0])); }
	    set { SprExport.Spr_PHOpHapticControllerDesc_set_hcCurrUPos(_thisArray[0], value); }
	}
	public Vec3f hcLastUPos {
	    get { return new Vec3f(SprExport.Spr_PHOpHapticControllerDesc_addr_hcLastUPos(_thisArray[0])); }
	    set { SprExport.Spr_PHOpHapticControllerDesc_set_hcLastUPos(_thisArray[0], value); }
	}
	public Vec3f hcFixsubGoal {
	    get { return new Vec3f(SprExport.Spr_PHOpHapticControllerDesc_addr_hcFixsubGoal(_thisArray[0])); }
	    set { SprExport.Spr_PHOpHapticControllerDesc_set_hcFixsubGoal(_thisArray[0], value); }
	}
	public float c_obstRadius {
	    get { return SprExport.Spr_PHOpHapticControllerDesc_get_c_obstRadius(_thisArray[0]); }
	    set { SprExport.Spr_PHOpHapticControllerDesc_set_c_obstRadius(_thisArray[0], value); }
	}
	public int hpObjIndex {
	    get { return SprExport.Spr_PHOpHapticControllerDesc_get_hpObjIndex(_thisArray[0]); }
	    set { SprExport.Spr_PHOpHapticControllerDesc_set_hpObjIndex(_thisArray[0], value); }
	}
	public HapticDOFType hcType {
	    get { return (HapticDOFType) SprExport.Spr_PHOpHapticControllerDesc_get_hcType(_thisArray[0]); }
	    set { SprExport.Spr_PHOpHapticControllerDesc_set_hcType(_thisArray[0], (int) value); }
	}
	public bool logForce {
	    get {
	        byte ret = (byte) SprExport.Spr_PHOpHapticControllerDesc_get_logForce(_thisArray[0]);
	        return (ret == 0) ? false : true;
	    }
	    set {
	        byte val = (byte) (value ? 1 : 0);
	        SprExport.Spr_PHOpHapticControllerDesc_set_logForce(_thisArray[0], (char) val);
	    }
	}
	public bool hcReady {
	    get {
	        byte ret = (byte) SprExport.Spr_PHOpHapticControllerDesc_get_hcReady(_thisArray[0]);
	        return (ret == 0) ? false : true;
	    }
	    set {
	        byte val = (byte) (value ? 1 : 0);
	        SprExport.Spr_PHOpHapticControllerDesc_set_hcReady(_thisArray[0], (char) val);
	    }
	}
	public bool IsSetForceReady {
	    get {
	        byte ret = (byte) SprExport.Spr_PHOpHapticControllerDesc_get_IsSetForceReady(_thisArray[0]);
	        return (ret == 0) ? false : true;
	    }
	    set {
	        byte val = (byte) (value ? 1 : 0);
	        SprExport.Spr_PHOpHapticControllerDesc_set_IsSetForceReady(_thisArray[0], (char) val);
	    }
	}
	public int fileindex {
	    get { return SprExport.Spr_PHOpHapticControllerDesc_get_fileindex(_thisArray[0]); }
	    set { SprExport.Spr_PHOpHapticControllerDesc_set_fileindex(_thisArray[0], value); }
	}
	public Vec3f lastHpRateF {
	    get { return new Vec3f(SprExport.Spr_PHOpHapticControllerDesc_addr_lastHpRateF(_thisArray[0])); }
	    set { SprExport.Spr_PHOpHapticControllerDesc_set_lastHpRateF(_thisArray[0], value); }
	}
	public bool hcCollied {
	    get {
	        byte ret = (byte) SprExport.Spr_PHOpHapticControllerDesc_get_hcCollied(_thisArray[0]);
	        return (ret == 0) ? false : true;
	    }
	    set {
	        byte val = (byte) (value ? 1 : 0);
	        SprExport.Spr_PHOpHapticControllerDesc_set_hcCollied(_thisArray[0], (char) val);
	    }
	}
	public int constrainCount {
	    get { return SprExport.Spr_PHOpHapticControllerDesc_get_constrainCount(_thisArray[0]); }
	    set { SprExport.Spr_PHOpHapticControllerDesc_set_constrainCount(_thisArray[0], value); }
	}
	public int constrainCountHc {
	    get { return SprExport.Spr_PHOpHapticControllerDesc_get_constrainCountHc(_thisArray[0]); }
	    set { SprExport.Spr_PHOpHapticControllerDesc_set_constrainCountHc(_thisArray[0], value); }
	}
	public Vec3f couterPlaneN {
	    get { return new Vec3f(SprExport.Spr_PHOpHapticControllerDesc_addr_couterPlaneN(_thisArray[0])); }
	    set { SprExport.Spr_PHOpHapticControllerDesc_set_couterPlaneN(_thisArray[0], value); }
	}
	public float hcElmDtcRadius {
	    get { return SprExport.Spr_PHOpHapticControllerDesc_get_hcElmDtcRadius(_thisArray[0]); }
	    set { SprExport.Spr_PHOpHapticControllerDesc_set_hcElmDtcRadius(_thisArray[0], value); }
	}
	public int collectCount {
	    get { return SprExport.Spr_PHOpHapticControllerDesc_get_collectCount(_thisArray[0]); }
	    set { SprExport.Spr_PHOpHapticControllerDesc_set_collectCount(_thisArray[0], value); }
	}
	public int collectItrtor {
	    get { return SprExport.Spr_PHOpHapticControllerDesc_get_collectItrtor(_thisArray[0]); }
	    set { SprExport.Spr_PHOpHapticControllerDesc_set_collectItrtor(_thisArray[0], value); }
	}
	public bool hcProxyOn {
	    get {
	        byte ret = (byte) SprExport.Spr_PHOpHapticControllerDesc_get_hcProxyOn(_thisArray[0]);
	        return (ret == 0) ? false : true;
	    }
	    set {
	        byte val = (byte) (value ? 1 : 0);
	        SprExport.Spr_PHOpHapticControllerDesc_set_hcProxyOn(_thisArray[0], (char) val);
	    }
	}
	public int suspObjid {
	    get { return SprExport.Spr_PHOpHapticControllerDesc_get_suspObjid(_thisArray[0]); }
	    set { SprExport.Spr_PHOpHapticControllerDesc_set_suspObjid(_thisArray[0], value); }
	}
	public float proxyRadius {
	    get { return SprExport.Spr_PHOpHapticControllerDesc_get_proxyRadius(_thisArray[0]); }
	    set { SprExport.Spr_PHOpHapticControllerDesc_set_proxyRadius(_thisArray[0], value); }
	}
	public int surrCnstrs {
	    get { return SprExport.Spr_PHOpHapticControllerDesc_get_surrCnstrs(_thisArray[0]); }
	    set { SprExport.Spr_PHOpHapticControllerDesc_set_surrCnstrs(_thisArray[0], value); }
	}
	public enum HapticDOFType : int {
	    _3DOF = 0, _6DOF = _3DOF + 1
	}
	public enum cstrainType : int {
	    cstPoint, cstEdge = cstPoint + 1, cstFace = cstEdge + 1
	}
    }
    [System.Serializable]
    public class PHOpHapticControllerDescStruct : CsObject {
        public PHOpHapticControllerDescStruct() {
            PHOpHapticControllerDesc desc = new PHOpHapticControllerDesc();
            ApplyFrom(desc, false);
        }
	public float posScale;
	public float rotScale;
	public float forceScale;
	public Vec3fStruct userPos;
	public PosefStruct userPose;
	public Vec3fStruct hcCurrPPos;
	public Vec3fStruct hcCurrUPos;
	public Vec3fStruct hcLastUPos;
	public Vec3fStruct hcFixsubGoal;
	public float c_obstRadius;
	public int hpObjIndex;
	public PHOpHapticControllerDesc.HapticDOFType hcType;
	public bool logForce;
	public bool hcReady;
	public bool IsSetForceReady;
	public int fileindex;
	public Vec3fStruct lastHpRateF;
	public bool hcCollied;
	public int constrainCount;
	public int constrainCountHc;
	public Vec3fStruct couterPlaneN;
	public float hcElmDtcRadius;
	public int collectCount;
	public int collectItrtor;
	public bool hcProxyOn;
	public int suspObjid;
	public float proxyRadius;
	public int surrCnstrs;
	public void ApplyTo(PHOpHapticControllerDesc r, bool apply_to_base_class = false) {
		r.posScale = posScale;
		r.rotScale = rotScale;
		r.forceScale = forceScale;
		r.userPos = userPos;
		r.userPose = userPose;
		r.hcCurrPPos = hcCurrPPos;
		r.hcCurrUPos = hcCurrUPos;
		r.hcLastUPos = hcLastUPos;
		r.hcFixsubGoal = hcFixsubGoal;
		r.c_obstRadius = c_obstRadius;
		r.hpObjIndex = hpObjIndex;
		r.hcType = hcType;
		r.logForce = logForce;
		r.hcReady = hcReady;
		r.IsSetForceReady = IsSetForceReady;
		r.fileindex = fileindex;
		r.lastHpRateF = lastHpRateF;
		r.hcCollied = hcCollied;
		r.constrainCount = constrainCount;
		r.constrainCountHc = constrainCountHc;
		r.couterPlaneN = couterPlaneN;
		r.hcElmDtcRadius = hcElmDtcRadius;
		r.collectCount = collectCount;
		r.collectItrtor = collectItrtor;
		r.hcProxyOn = hcProxyOn;
		r.suspObjid = suspObjid;
		r.proxyRadius = proxyRadius;
		r.surrCnstrs = surrCnstrs;
	}
	public void ApplyFrom(PHOpHapticControllerDesc r, bool apply_to_base_class = false) {
		posScale = r.posScale;
		rotScale = r.rotScale;
		forceScale = r.forceScale;
		userPos = r.userPos;
		userPose = r.userPose;
		hcCurrPPos = r.hcCurrPPos;
		hcCurrUPos = r.hcCurrUPos;
		hcLastUPos = r.hcLastUPos;
		hcFixsubGoal = r.hcFixsubGoal;
		c_obstRadius = r.c_obstRadius;
		hpObjIndex = r.hpObjIndex;
		hcType = r.hcType;
		logForce = r.logForce;
		hcReady = r.hcReady;
		IsSetForceReady = r.IsSetForceReady;
		fileindex = r.fileindex;
		lastHpRateF = r.lastHpRateF;
		hcCollied = r.hcCollied;
		constrainCount = r.constrainCount;
		constrainCountHc = r.constrainCountHc;
		couterPlaneN = r.couterPlaneN;
		hcElmDtcRadius = r.hcElmDtcRadius;
		collectCount = r.collectCount;
		collectItrtor = r.collectItrtor;
		hcProxyOn = r.hcProxyOn;
		suspObjid = r.suspObjid;
		proxyRadius = r.proxyRadius;
		surrCnstrs = r.surrCnstrs;
	}
	public static implicit operator PHOpHapticControllerDesc(PHOpHapticControllerDescStruct m) {
	    PHOpHapticControllerDesc r = new PHOpHapticControllerDesc();
	    m.ApplyTo(r, true);
	    return r;
	}
	public static implicit operator PHOpHapticControllerDescStruct(PHOpHapticControllerDesc r) {
	    PHOpHapticControllerDescStruct m = new PHOpHapticControllerDescStruct();
	    m.ApplyFrom(r, true);
	    return m;
	}
    }
    public partial class PHOpAnimationDesc : CsObject {
	public PHOpAnimationDesc() { _thisArray[0] = SprExport.Spr_new_PHOpAnimationDesc(); _flag = true; }
	public PHOpAnimationDesc(IntPtr ptr) : base(ptr) {}
	public PHOpAnimationDesc(IntPtr ptr, bool flag) : base(ptr, flag) {}
	~PHOpAnimationDesc() { if (_flag) { SprExport.Spr_delete_PHOpAnimationDesc(_thisArray[0]); _flag = false; } }
	public float timestep {
	    get { return SprExport.Spr_PHOpAnimationDesc_get_timestep(_thisArray[0]); }
	    set { SprExport.Spr_PHOpAnimationDesc_set_timestep(_thisArray[0], value); }
	}
    }
    [System.Serializable]
    public class PHOpAnimationDescStruct : CsObject {
        public PHOpAnimationDescStruct() {
            PHOpAnimationDesc desc = new PHOpAnimationDesc();
            ApplyFrom(desc, false);
        }
	public float timestep;
	public void ApplyTo(PHOpAnimationDesc r, bool apply_to_base_class = false) {
		r.timestep = timestep;
	}
	public void ApplyFrom(PHOpAnimationDesc r, bool apply_to_base_class = false) {
		timestep = r.timestep;
	}
	public static implicit operator PHOpAnimationDesc(PHOpAnimationDescStruct m) {
	    PHOpAnimationDesc r = new PHOpAnimationDesc();
	    m.ApplyTo(r, true);
	    return r;
	}
	public static implicit operator PHOpAnimationDescStruct(PHOpAnimationDesc r) {
	    PHOpAnimationDescStruct m = new PHOpAnimationDescStruct();
	    m.ApplyFrom(r, true);
	    return m;
	}
    }
    public partial class PHOpSpHashColliAgentDesc : CsObject {
	public PHOpSpHashColliAgentDesc() { _thisArray[0] = SprExport.Spr_new_PHOpSpHashColliAgentDesc(); _flag = true; }
	public PHOpSpHashColliAgentDesc(IntPtr ptr) : base(ptr) {}
	public PHOpSpHashColliAgentDesc(IntPtr ptr, bool flag) : base(ptr, flag) {}
	~PHOpSpHashColliAgentDesc() { if (_flag) { SprExport.Spr_delete_PHOpSpHashColliAgentDesc(_thisArray[0]); _flag = false; } }
	public bool useDirColli {
	    get {
	        byte ret = (byte) SprExport.Spr_PHOpSpHashColliAgentDesc_get_useDirColli(_thisArray[0]);
	        return (ret == 0) ? false : true;
	    }
	    set {
	        byte val = (byte) (value ? 1 : 0);
	        SprExport.Spr_PHOpSpHashColliAgentDesc_set_useDirColli(_thisArray[0], (char) val);
	    }
	}
	public float collisionCstrStiffness {
	    get { return SprExport.Spr_PHOpSpHashColliAgentDesc_get_collisionCstrStiffness(_thisArray[0]); }
	    set { SprExport.Spr_PHOpSpHashColliAgentDesc_set_collisionCstrStiffness(_thisArray[0], value); }
	}
    }
    [System.Serializable]
    public class PHOpSpHashColliAgentDescStruct : CsObject {
        public PHOpSpHashColliAgentDescStruct() {
            PHOpSpHashColliAgentDesc desc = new PHOpSpHashColliAgentDesc();
            ApplyFrom(desc, false);
        }
	public bool useDirColli;
	public float collisionCstrStiffness;
	public void ApplyTo(PHOpSpHashColliAgentDesc r, bool apply_to_base_class = false) {
		r.useDirColli = useDirColli;
		r.collisionCstrStiffness = collisionCstrStiffness;
	}
	public void ApplyFrom(PHOpSpHashColliAgentDesc r, bool apply_to_base_class = false) {
		useDirColli = r.useDirColli;
		collisionCstrStiffness = r.collisionCstrStiffness;
	}
	public static implicit operator PHOpSpHashColliAgentDesc(PHOpSpHashColliAgentDescStruct m) {
	    PHOpSpHashColliAgentDesc r = new PHOpSpHashColliAgentDesc();
	    m.ApplyTo(r, true);
	    return r;
	}
	public static implicit operator PHOpSpHashColliAgentDescStruct(PHOpSpHashColliAgentDesc r) {
	    PHOpSpHashColliAgentDescStruct m = new PHOpSpHashColliAgentDescStruct();
	    m.ApplyFrom(r, true);
	    return m;
	}
    }
    public partial class PHRaycastHit : CsObject {
	public PHRaycastHit() { _thisArray[0] = SprExport.Spr_new_PHRaycastHit(); _flag = true; }
	public PHRaycastHit(IntPtr ptr) : base(ptr) {}
	public PHRaycastHit(IntPtr ptr, bool flag) : base(ptr, flag) {}
	~PHRaycastHit() { if (_flag) { SprExport.Spr_delete_PHRaycastHit(_thisArray[0]); _flag = false; } }
	public PHSolidIf solid {
	    get { return new PHSolidIf(SprExport.Spr_PHRaycastHit_get_solid(_thisArray[0])); }
	    set { SprExport.Spr_PHRaycastHit_set_solid(_thisArray[0], value); }
	}
	public CDShapeIf shape {
	    get { return new CDShapeIf(SprExport.Spr_PHRaycastHit_get_shape(_thisArray[0])); }
	    set { SprExport.Spr_PHRaycastHit_set_shape(_thisArray[0], value); }
	}
	public Vec3f point {
	    get { return new Vec3f(SprExport.Spr_PHRaycastHit_addr_point(_thisArray[0])); }
	    set { SprExport.Spr_PHRaycastHit_set_point(_thisArray[0], value); }
	}
	public float distance {
	    get { return SprExport.Spr_PHRaycastHit_get_distance(_thisArray[0]); }
	    set { SprExport.Spr_PHRaycastHit_set_distance(_thisArray[0], value); }
	}
    }
    public partial class PHRayDesc : CsObject {
	public PHRayDesc() { _thisArray[0] = SprExport.Spr_new_PHRayDesc(); _flag = true; }
	public PHRayDesc(IntPtr ptr) : base(ptr) {}
	public PHRayDesc(IntPtr ptr, bool flag) : base(ptr, flag) {}
	~PHRayDesc() { if (_flag) { SprExport.Spr_delete_PHRayDesc(_thisArray[0]); _flag = false; } }
	public Vec3d origin {
	    get { return new Vec3d(SprExport.Spr_PHRayDesc_addr_origin(_thisArray[0])); }
	    set { SprExport.Spr_PHRayDesc_set_origin(_thisArray[0], value); }
	}
	public Vec3d direction {
	    get { return new Vec3d(SprExport.Spr_PHRayDesc_addr_direction(_thisArray[0])); }
	    set { SprExport.Spr_PHRayDesc_set_direction(_thisArray[0], value); }
	}
    }
    [System.Serializable]
    public class PHRayDescStruct : CsObject {
        public PHRayDescStruct() {
            PHRayDesc desc = new PHRayDesc();
            ApplyFrom(desc, false);
        }
	public Vec3dStruct origin;
	public Vec3dStruct direction;
	public void ApplyTo(PHRayDesc r, bool apply_to_base_class = false) {
		r.origin = origin;
		r.direction = direction;
	}
	public void ApplyFrom(PHRayDesc r, bool apply_to_base_class = false) {
		origin = r.origin;
		direction = r.direction;
	}
	public static implicit operator PHRayDesc(PHRayDescStruct m) {
	    PHRayDesc r = new PHRayDesc();
	    m.ApplyTo(r, true);
	    return r;
	}
	public static implicit operator PHRayDescStruct(PHRayDesc r) {
	    PHRayDescStruct m = new PHRayDescStruct();
	    m.ApplyFrom(r, true);
	    return m;
	}
    }
    public partial class PHSceneState : CsObject {
	public PHSceneState() { _thisArray[0] = SprExport.Spr_new_PHSceneState(); _flag = true; }
	public PHSceneState(IntPtr ptr) : base(ptr) {}
	public PHSceneState(IntPtr ptr, bool flag) : base(ptr, flag) {}
	~PHSceneState() { if (_flag) { SprExport.Spr_delete_PHSceneState(_thisArray[0]); _flag = false; } }
	public double timeStep {
	    get { return SprExport.Spr_PHSceneState_get_timeStep(_thisArray[0]); }
	    set { SprExport.Spr_PHSceneState_set_timeStep(_thisArray[0], value); }
	}
	public double haptictimeStep {
	    get { return SprExport.Spr_PHSceneState_get_haptictimeStep(_thisArray[0]); }
	    set { SprExport.Spr_PHSceneState_set_haptictimeStep(_thisArray[0], value); }
	}
	public uint count {
	    get { return SprExport.Spr_PHSceneState_get_count(_thisArray[0]); }
	    set { SprExport.Spr_PHSceneState_set_count(_thisArray[0], value); }
	}
	public void Init() {
	    SprExport.Spr_PHSceneState_Init((IntPtr) _thisArray[0]);
	}
    }
    [System.Serializable]
    public class PHSceneStateStruct : CsObject {
        public PHSceneStateStruct() {
            PHSceneState desc = new PHSceneState();
            ApplyFrom(desc, false);
        }
	public double timeStep;
	public double haptictimeStep;
	public uint count;
	public void ApplyTo(PHSceneState r, bool apply_to_base_class = false) {
		r.timeStep = timeStep;
		r.haptictimeStep = haptictimeStep;
		r.count = count;
	}
	public void ApplyFrom(PHSceneState r, bool apply_to_base_class = false) {
		timeStep = r.timeStep;
		haptictimeStep = r.haptictimeStep;
		count = r.count;
	}
	public static implicit operator PHSceneState(PHSceneStateStruct m) {
	    PHSceneState r = new PHSceneState();
	    m.ApplyTo(r, true);
	    return r;
	}
	public static implicit operator PHSceneStateStruct(PHSceneState r) {
	    PHSceneStateStruct m = new PHSceneStateStruct();
	    m.ApplyFrom(r, true);
	    return m;
	}
    }
    public partial class PHSceneDesc : PHSceneState {
	public PHSceneDesc() { _thisArray[0] = SprExport.Spr_new_PHSceneDesc(); _flag = true; }
	public PHSceneDesc(IntPtr ptr) : base(ptr) {}
	public PHSceneDesc(IntPtr ptr, bool flag) : base(ptr, flag) {}
	~PHSceneDesc() { if (_flag) { SprExport.Spr_delete_PHSceneDesc(_thisArray[0]); _flag = false; } }
	public Vec3d gravity {
	    get { return new Vec3d(SprExport.Spr_PHSceneDesc_addr_gravity(_thisArray[0])); }
	    set { SprExport.Spr_PHSceneDesc_set_gravity(_thisArray[0], value); }
	}
	public double airResistanceRateForVelocity {
	    get { return SprExport.Spr_PHSceneDesc_get_airResistanceRateForVelocity(_thisArray[0]); }
	    set { SprExport.Spr_PHSceneDesc_set_airResistanceRateForVelocity(_thisArray[0], value); }
	}
	public double airResistanceRateForAngularVelocity {
	    get { return SprExport.Spr_PHSceneDesc_get_airResistanceRateForAngularVelocity(_thisArray[0]); }
	    set { SprExport.Spr_PHSceneDesc_set_airResistanceRateForAngularVelocity(_thisArray[0], value); }
	}
	public double contactTolerance {
	    get { return SprExport.Spr_PHSceneDesc_get_contactTolerance(_thisArray[0]); }
	    set { SprExport.Spr_PHSceneDesc_set_contactTolerance(_thisArray[0], value); }
	}
	public double impactThreshold {
	    get { return SprExport.Spr_PHSceneDesc_get_impactThreshold(_thisArray[0]); }
	    set { SprExport.Spr_PHSceneDesc_set_impactThreshold(_thisArray[0], value); }
	}
	public double frictionThreshold {
	    get { return SprExport.Spr_PHSceneDesc_get_frictionThreshold(_thisArray[0]); }
	    set { SprExport.Spr_PHSceneDesc_set_frictionThreshold(_thisArray[0], value); }
	}
	public double maxDeltaPosition {
	    get { return SprExport.Spr_PHSceneDesc_get_maxDeltaPosition(_thisArray[0]); }
	    set { SprExport.Spr_PHSceneDesc_set_maxDeltaPosition(_thisArray[0], value); }
	}
	public double maxDeltaOrientation {
	    get { return SprExport.Spr_PHSceneDesc_get_maxDeltaOrientation(_thisArray[0]); }
	    set { SprExport.Spr_PHSceneDesc_set_maxDeltaOrientation(_thisArray[0], value); }
	}
	public double maxVelocity {
	    get { return SprExport.Spr_PHSceneDesc_get_maxVelocity(_thisArray[0]); }
	    set { SprExport.Spr_PHSceneDesc_set_maxVelocity(_thisArray[0], value); }
	}
	public double maxAngularVelocity {
	    get { return SprExport.Spr_PHSceneDesc_get_maxAngularVelocity(_thisArray[0]); }
	    set { SprExport.Spr_PHSceneDesc_set_maxAngularVelocity(_thisArray[0], value); }
	}
	public double maxForce {
	    get { return SprExport.Spr_PHSceneDesc_get_maxForce(_thisArray[0]); }
	    set { SprExport.Spr_PHSceneDesc_set_maxForce(_thisArray[0], value); }
	}
	public double maxMoment {
	    get { return SprExport.Spr_PHSceneDesc_get_maxMoment(_thisArray[0]); }
	    set { SprExport.Spr_PHSceneDesc_set_maxMoment(_thisArray[0], value); }
	}
	public int numIteration {
	    get { return SprExport.Spr_PHSceneDesc_get_numIteration(_thisArray[0]); }
	    set { SprExport.Spr_PHSceneDesc_set_numIteration(_thisArray[0], value); }
	}
	public int method {
	    get { return SprExport.Spr_PHSceneDesc_get_method(_thisArray[0]); }
	    set { SprExport.Spr_PHSceneDesc_set_method(_thisArray[0], value); }
	}
	public bool bContactDetectionEnabled {
	    get {
	        byte ret = (byte) SprExport.Spr_PHSceneDesc_get_bContactDetectionEnabled(_thisArray[0]);
	        return (ret == 0) ? false : true;
	    }
	    set {
	        byte val = (byte) (value ? 1 : 0);
	        SprExport.Spr_PHSceneDesc_set_bContactDetectionEnabled(_thisArray[0], (char) val);
	    }
	}
	public bool bCCDEnabled {
	    get {
	        byte ret = (byte) SprExport.Spr_PHSceneDesc_get_bCCDEnabled(_thisArray[0]);
	        return (ret == 0) ? false : true;
	    }
	    set {
	        byte val = (byte) (value ? 1 : 0);
	        SprExport.Spr_PHSceneDesc_set_bCCDEnabled(_thisArray[0], (char) val);
	    }
	}
	public int broadPhaseMode {
	    get { return SprExport.Spr_PHSceneDesc_get_broadPhaseMode(_thisArray[0]); }
	    set { SprExport.Spr_PHSceneDesc_set_broadPhaseMode(_thisArray[0], value); }
	}
	public int blendMode {
	    get { return SprExport.Spr_PHSceneDesc_get_blendMode(_thisArray[0]); }
	    set { SprExport.Spr_PHSceneDesc_set_blendMode(_thisArray[0], value); }
	}
	public enum BroadPhaseMode : int {
	    MODE_SORT_AND_SWEEP_X = 0, MODE_SORT_AND_SWEEP_Y = MODE_SORT_AND_SWEEP_X + 1, MODE_SORT_AND_SWEEP_Z = MODE_SORT_AND_SWEEP_Y + 1, MODE_PARTITION = MODE_SORT_AND_SWEEP_Z + 1
	}
	public enum ContactMode : int {
	    MODE_NONE = 0, MODE_PENALTY = MODE_NONE + 1, MODE_LCP = MODE_PENALTY + 1
	}
	public enum MatrialBlending : int {
	    BLEND_MIN = 0, BLEND_MAX = BLEND_MIN + 1, BLEND_AVE_ADD = BLEND_MAX + 1, BLEND_AVE_MUL = BLEND_AVE_ADD + 1
	}
	public enum LCPSolver : int {
	    SOLVER_GS = 0, SOLVER_CG = SOLVER_GS + 1
	}
	public void Init() {
	    SprExport.Spr_PHSceneDesc_Init((IntPtr) _thisArray[0]);
	}
    }
    [System.Serializable]
    public class PHSceneDescStruct : PHSceneStateStruct {
        public PHSceneDescStruct() {
            PHSceneDesc desc = new PHSceneDesc();
            ApplyFrom(desc, false);
        }
	public Vec3dStruct gravity;
	public double airResistanceRateForVelocity;
	public double airResistanceRateForAngularVelocity;
	public double contactTolerance;
	public double impactThreshold;
	public double frictionThreshold;
	public double maxDeltaPosition;
	public double maxDeltaOrientation;
	public double maxVelocity;
	public double maxAngularVelocity;
	public double maxForce;
	public double maxMoment;
	public int numIteration;
	public int method;
	public bool bContactDetectionEnabled;
	public bool bCCDEnabled;
	public int broadPhaseMode;
	public int blendMode;
	public void ApplyTo(PHSceneDesc r, bool apply_to_base_class = false) {
		r.gravity = gravity;
		r.airResistanceRateForVelocity = airResistanceRateForVelocity;
		r.airResistanceRateForAngularVelocity = airResistanceRateForAngularVelocity;
		r.contactTolerance = contactTolerance;
		r.impactThreshold = impactThreshold;
		r.frictionThreshold = frictionThreshold;
		r.maxDeltaPosition = maxDeltaPosition;
		r.maxDeltaOrientation = maxDeltaOrientation;
		r.maxVelocity = maxVelocity;
		r.maxAngularVelocity = maxAngularVelocity;
		r.maxForce = maxForce;
		r.maxMoment = maxMoment;
		r.numIteration = numIteration;
		r.method = method;
		r.bContactDetectionEnabled = bContactDetectionEnabled;
		r.bCCDEnabled = bCCDEnabled;
		r.broadPhaseMode = broadPhaseMode;
		r.blendMode = blendMode;
	}
	public void ApplyFrom(PHSceneDesc r, bool apply_to_base_class = false) {
		gravity = r.gravity;
		airResistanceRateForVelocity = r.airResistanceRateForVelocity;
		airResistanceRateForAngularVelocity = r.airResistanceRateForAngularVelocity;
		contactTolerance = r.contactTolerance;
		impactThreshold = r.impactThreshold;
		frictionThreshold = r.frictionThreshold;
		maxDeltaPosition = r.maxDeltaPosition;
		maxDeltaOrientation = r.maxDeltaOrientation;
		maxVelocity = r.maxVelocity;
		maxAngularVelocity = r.maxAngularVelocity;
		maxForce = r.maxForce;
		maxMoment = r.maxMoment;
		numIteration = r.numIteration;
		method = r.method;
		bContactDetectionEnabled = r.bContactDetectionEnabled;
		bCCDEnabled = r.bCCDEnabled;
		broadPhaseMode = r.broadPhaseMode;
		blendMode = r.blendMode;
	}
	public static implicit operator PHSceneDesc(PHSceneDescStruct m) {
	    PHSceneDesc r = new PHSceneDesc();
	    m.ApplyTo(r, true);
	    return r;
	}
	public static implicit operator PHSceneDescStruct(PHSceneDesc r) {
	    PHSceneDescStruct m = new PHSceneDescStruct();
	    m.ApplyFrom(r, true);
	    return m;
	}
    }
    public partial class PHSdkDesc : CsObject {
	public PHSdkDesc() { _thisArray[0] = SprExport.Spr_new_PHSdkDesc(); _flag = true; }
	public PHSdkDesc(IntPtr ptr) : base(ptr) {}
	public PHSdkDesc(IntPtr ptr, bool flag) : base(ptr, flag) {}
	~PHSdkDesc() { if (_flag) { SprExport.Spr_delete_PHSdkDesc(_thisArray[0]); _flag = false; } }
    }
    [System.Serializable]
    public class PHSdkDescStruct : CsObject {
        public PHSdkDescStruct() {
            PHSdkDesc desc = new PHSdkDesc();
            ApplyFrom(desc, false);
        }
	public void ApplyTo(PHSdkDesc r, bool apply_to_base_class = false) {
	}
	public void ApplyFrom(PHSdkDesc r, bool apply_to_base_class = false) {
	}
	public static implicit operator PHSdkDesc(PHSdkDescStruct m) {
	    PHSdkDesc r = new PHSdkDesc();
	    m.ApplyTo(r, true);
	    return r;
	}
	public static implicit operator PHSdkDescStruct(PHSdkDesc r) {
	    PHSdkDescStruct m = new PHSdkDescStruct();
	    m.ApplyFrom(r, true);
	    return m;
	}
    }
    public partial class PHBoneDesc : CsObject {
	public PHBoneDesc() { _thisArray[0] = SprExport.Spr_new_PHBoneDesc(); _flag = true; }
	public PHBoneDesc(IntPtr ptr) : base(ptr) {}
	public PHBoneDesc(IntPtr ptr, bool flag) : base(ptr, flag) {}
	~PHBoneDesc() { if (_flag) { SprExport.Spr_delete_PHBoneDesc(_thisArray[0]); _flag = false; } }
    }
    [System.Serializable]
    public class PHBoneDescStruct : CsObject {
        public PHBoneDescStruct() {
            PHBoneDesc desc = new PHBoneDesc();
            ApplyFrom(desc, false);
        }
	public void ApplyTo(PHBoneDesc r, bool apply_to_base_class = false) {
	}
	public void ApplyFrom(PHBoneDesc r, bool apply_to_base_class = false) {
	}
	public static implicit operator PHBoneDesc(PHBoneDescStruct m) {
	    PHBoneDesc r = new PHBoneDesc();
	    m.ApplyTo(r, true);
	    return r;
	}
	public static implicit operator PHBoneDescStruct(PHBoneDesc r) {
	    PHBoneDescStruct m = new PHBoneDescStruct();
	    m.ApplyFrom(r, true);
	    return m;
	}
    }
    public partial class PHSkeletonDesc : CsObject {
	public PHSkeletonDesc() { _thisArray[0] = SprExport.Spr_new_PHSkeletonDesc(); _flag = true; }
	public PHSkeletonDesc(IntPtr ptr) : base(ptr) {}
	public PHSkeletonDesc(IntPtr ptr, bool flag) : base(ptr, flag) {}
	~PHSkeletonDesc() { if (_flag) { SprExport.Spr_delete_PHSkeletonDesc(_thisArray[0]); _flag = false; } }
    }
    [System.Serializable]
    public class PHSkeletonDescStruct : CsObject {
        public PHSkeletonDescStruct() {
            PHSkeletonDesc desc = new PHSkeletonDesc();
            ApplyFrom(desc, false);
        }
	public void ApplyTo(PHSkeletonDesc r, bool apply_to_base_class = false) {
	}
	public void ApplyFrom(PHSkeletonDesc r, bool apply_to_base_class = false) {
	}
	public static implicit operator PHSkeletonDesc(PHSkeletonDescStruct m) {
	    PHSkeletonDesc r = new PHSkeletonDesc();
	    m.ApplyTo(r, true);
	    return r;
	}
	public static implicit operator PHSkeletonDescStruct(PHSkeletonDesc r) {
	    PHSkeletonDescStruct m = new PHSkeletonDescStruct();
	    m.ApplyFrom(r, true);
	    return m;
	}
    }
    public partial class PHEngineIf : SceneObjectIf {
	public PHEngineIf() { _thisArray[0] = SprExport.Spr_new_PHEngineIf(); _flag = true; }
	public PHEngineIf(IntPtr ptr) : base(ptr) {}
	public PHEngineIf(IntPtr ptr, bool flag) : base(ptr, flag) {}
	public static implicit operator PHEngineIf(CsCastObject target) {
		return (target._info.Inherit(PHEngineIf.GetIfInfoStatic()) ? new PHEngineIf(target._thisArray[0], target._flag) : null);
	}
	~PHEngineIf() { if (_flag) { SprExport.Spr_delete_PHEngineIf(_thisArray[0]); _flag = false; } }
        public override string ToString() {
            IntPtr ptr = SprExport.Spr_PHEngineIf_ToString((IntPtr) _thisArray[0]);
            string bstr = Marshal.PtrToStringBSTR(ptr);
            SprExport.Spr_PHEngineIf_FreeString((IntPtr) ptr);
            return bstr;
        }
	public IfInfo GetIfInfo() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHEngineIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new IfInfo(ptr);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHEngineIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new IfInfo(ptr);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHEngineIf_GetIfInfo((IntPtr) _thisArray[0]);
            return new IfInfo(ptr);
		}
		throw new InvalidOperationException();
	}
	public static IfInfo GetIfInfoStatic() {
	    IntPtr ptr = SprExport.Spr_PHEngineIf_GetIfInfoStatic();
            return new IfInfo(ptr);
	}
	public int GetPriority() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    int result = (int) SprExport.Spr_PHEngineIf_GetPriority((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    int result = (int) SprExport.Spr_PHEngineIf_GetPriority((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    int result = (int) SprExport.Spr_PHEngineIf_GetPriority((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public void Step() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHEngineIf_Step((IntPtr) _thisArray[phSceneIf.sceneForStep]);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHEngineIf_Step((IntPtr) _thisArray[phSceneIf.sceneForGet]);
				}
			}
		} else {
	    SprExport.Spr_PHEngineIf_Step((IntPtr) _thisArray[0]);
		}
		throw new InvalidOperationException();
	}
	public void Enable(bool on) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHEngineIf_Enable((IntPtr) _thisArray[phSceneIf.sceneForStep], (bool) on);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHEngineIf_Enable((IntPtr) _thisArray[phSceneIf.sceneForGet], (bool) on);
				}
			}
		} else {
	    SprExport.Spr_PHEngineIf_Enable((IntPtr) _thisArray[0], (bool) on);
		}
		throw new InvalidOperationException();
	}
	public void Enable() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHEngineIf_Enable_1((IntPtr) _thisArray[phSceneIf.sceneForStep]);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHEngineIf_Enable_1((IntPtr) _thisArray[phSceneIf.sceneForGet]);
				}
			}
		} else {
	    SprExport.Spr_PHEngineIf_Enable_1((IntPtr) _thisArray[0]);
		}
		throw new InvalidOperationException();
	}
	public bool IsEnabled() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    char ret = SprExport.Spr_PHEngineIf_IsEnabled((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return (ret == 0) ? false : true;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    char ret = SprExport.Spr_PHEngineIf_IsEnabled((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return (ret == 0) ? false : true;
				}
			}
		} else {
	    char ret = SprExport.Spr_PHEngineIf_IsEnabled((IntPtr) _thisArray[0]);
	    return (ret == 0) ? false : true;
		}
		throw new InvalidOperationException();
	}
	public PHSceneIf GetScene() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHEngineIf_GetScene((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            if (ptr == IntPtr.Zero) { return null; } 
            PHSceneIf obj = new PHSceneIf(ptr);
            return obj;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHEngineIf_GetScene((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            if (ptr == IntPtr.Zero) { return null; } 
            PHSceneIf obj = new PHSceneIf(ptr);
            return obj;
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHEngineIf_GetScene((IntPtr) _thisArray[0]);
            if (ptr == IntPtr.Zero) { return null; } 
            PHSceneIf obj = new PHSceneIf(ptr);
            return obj;
		}
		throw new InvalidOperationException();
	}
    }
    public partial class PHConstraintEngineIf : PHEngineIf {
	public PHConstraintEngineIf() { _thisArray[0] = SprExport.Spr_new_PHConstraintEngineIf(); _flag = true; }
	public PHConstraintEngineIf(IntPtr ptr) : base(ptr) {}
	public PHConstraintEngineIf(IntPtr ptr, bool flag) : base(ptr, flag) {}
	public static implicit operator PHConstraintEngineIf(CsCastObject target) {
		return (target._info.Inherit(PHConstraintEngineIf.GetIfInfoStatic()) ? new PHConstraintEngineIf(target._thisArray[0], target._flag) : null);
	}
	~PHConstraintEngineIf() { if (_flag) { SprExport.Spr_delete_PHConstraintEngineIf(_thisArray[0]); _flag = false; } }
        public override string ToString() {
            IntPtr ptr = SprExport.Spr_PHConstraintEngineIf_ToString((IntPtr) _thisArray[0]);
            string bstr = Marshal.PtrToStringBSTR(ptr);
            SprExport.Spr_PHConstraintEngineIf_FreeString((IntPtr) ptr);
            return bstr;
        }
	public IfInfo GetIfInfo() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHConstraintEngineIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new IfInfo(ptr);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHConstraintEngineIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new IfInfo(ptr);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHConstraintEngineIf_GetIfInfo((IntPtr) _thisArray[0]);
            return new IfInfo(ptr);
		}
		throw new InvalidOperationException();
	}
	public static IfInfo GetIfInfoStatic() {
	    IntPtr ptr = SprExport.Spr_PHConstraintEngineIf_GetIfInfoStatic();
            return new IfInfo(ptr);
	}
	public PHConstraintsIf GetContactPoints() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHConstraintEngineIf_GetContactPoints((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            if (ptr == IntPtr.Zero) { return null; } 
            PHConstraintsIf obj = new PHConstraintsIf(ptr);
            return obj;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHConstraintEngineIf_GetContactPoints((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            if (ptr == IntPtr.Zero) { return null; } 
            PHConstraintsIf obj = new PHConstraintsIf(ptr);
            return obj;
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHConstraintEngineIf_GetContactPoints((IntPtr) _thisArray[0]);
            if (ptr == IntPtr.Zero) { return null; } 
            PHConstraintsIf obj = new PHConstraintsIf(ptr);
            return obj;
		}
		throw new InvalidOperationException();
	}
	public void SetVelCorrectionRate(double value) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHConstraintEngineIf_SetVelCorrectionRate((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) value);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHConstraintEngineIf_SetVelCorrectionRate((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) value);
				}
			}
		} else {
	    SprExport.Spr_PHConstraintEngineIf_SetVelCorrectionRate((IntPtr) _thisArray[0], (double) value);
		}
		throw new InvalidOperationException();
	}
	public double GetVelCorrectionRate() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    double result = (double) SprExport.Spr_PHConstraintEngineIf_GetVelCorrectionRate((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    double result = (double) SprExport.Spr_PHConstraintEngineIf_GetVelCorrectionRate((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    double result = (double) SprExport.Spr_PHConstraintEngineIf_GetVelCorrectionRate((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public void SetPosCorrectionRate(double value) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHConstraintEngineIf_SetPosCorrectionRate((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) value);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHConstraintEngineIf_SetPosCorrectionRate((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) value);
				}
			}
		} else {
	    SprExport.Spr_PHConstraintEngineIf_SetPosCorrectionRate((IntPtr) _thisArray[0], (double) value);
		}
		throw new InvalidOperationException();
	}
	public double GetPosCorrectionRate() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    double result = (double) SprExport.Spr_PHConstraintEngineIf_GetPosCorrectionRate((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    double result = (double) SprExport.Spr_PHConstraintEngineIf_GetPosCorrectionRate((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    double result = (double) SprExport.Spr_PHConstraintEngineIf_GetPosCorrectionRate((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public void SetContactCorrectionRate(double value) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHConstraintEngineIf_SetContactCorrectionRate((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) value);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHConstraintEngineIf_SetContactCorrectionRate((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) value);
				}
			}
		} else {
	    SprExport.Spr_PHConstraintEngineIf_SetContactCorrectionRate((IntPtr) _thisArray[0], (double) value);
		}
		throw new InvalidOperationException();
	}
	public double GetContactCorrectionRate() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    double result = (double) SprExport.Spr_PHConstraintEngineIf_GetContactCorrectionRate((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    double result = (double) SprExport.Spr_PHConstraintEngineIf_GetContactCorrectionRate((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    double result = (double) SprExport.Spr_PHConstraintEngineIf_GetContactCorrectionRate((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public void SetBSaveConstraints(bool value) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHConstraintEngineIf_SetBSaveConstraints((IntPtr) _thisArray[phSceneIf.sceneForStep], (bool) value);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHConstraintEngineIf_SetBSaveConstraints((IntPtr) _thisArray[phSceneIf.sceneForGet], (bool) value);
				}
			}
		} else {
	    SprExport.Spr_PHConstraintEngineIf_SetBSaveConstraints((IntPtr) _thisArray[0], (bool) value);
		}
		throw new InvalidOperationException();
	}
	public void SetUpdateAllSolidState(bool flag) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHConstraintEngineIf_SetUpdateAllSolidState((IntPtr) _thisArray[phSceneIf.sceneForStep], (bool) flag);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHConstraintEngineIf_SetUpdateAllSolidState((IntPtr) _thisArray[phSceneIf.sceneForGet], (bool) flag);
				}
			}
		} else {
	    SprExport.Spr_PHConstraintEngineIf_SetUpdateAllSolidState((IntPtr) _thisArray[0], (bool) flag);
		}
		throw new InvalidOperationException();
	}
	public void SetUseContactSurface(bool flag) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHConstraintEngineIf_SetUseContactSurface((IntPtr) _thisArray[phSceneIf.sceneForStep], (bool) flag);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHConstraintEngineIf_SetUseContactSurface((IntPtr) _thisArray[phSceneIf.sceneForGet], (bool) flag);
				}
			}
		} else {
	    SprExport.Spr_PHConstraintEngineIf_SetUseContactSurface((IntPtr) _thisArray[0], (bool) flag);
		}
		throw new InvalidOperationException();
	}
	public void SetShrinkRate(double data) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHConstraintEngineIf_SetShrinkRate((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) data);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHConstraintEngineIf_SetShrinkRate((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) data);
				}
			}
		} else {
	    SprExport.Spr_PHConstraintEngineIf_SetShrinkRate((IntPtr) _thisArray[0], (double) data);
		}
		throw new InvalidOperationException();
	}
	public double GetShrinkRate() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    double result = (double) SprExport.Spr_PHConstraintEngineIf_GetShrinkRate((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    double result = (double) SprExport.Spr_PHConstraintEngineIf_GetShrinkRate((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    double result = (double) SprExport.Spr_PHConstraintEngineIf_GetShrinkRate((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public void SetShrinkRateCorrection(double data) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHConstraintEngineIf_SetShrinkRateCorrection((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) data);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHConstraintEngineIf_SetShrinkRateCorrection((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) data);
				}
			}
		} else {
	    SprExport.Spr_PHConstraintEngineIf_SetShrinkRateCorrection((IntPtr) _thisArray[0], (double) data);
		}
		throw new InvalidOperationException();
	}
	public double GetShrinkRateCorrection() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    double result = (double) SprExport.Spr_PHConstraintEngineIf_GetShrinkRateCorrection((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    double result = (double) SprExport.Spr_PHConstraintEngineIf_GetShrinkRateCorrection((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    double result = (double) SprExport.Spr_PHConstraintEngineIf_GetShrinkRateCorrection((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public void SetRegularization(double reg) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHConstraintEngineIf_SetRegularization((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) reg);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHConstraintEngineIf_SetRegularization((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) reg);
				}
			}
		} else {
	    SprExport.Spr_PHConstraintEngineIf_SetRegularization((IntPtr) _thisArray[0], (double) reg);
		}
		throw new InvalidOperationException();
	}
	public double GetRegularization() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    double result = (double) SprExport.Spr_PHConstraintEngineIf_GetRegularization((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    double result = (double) SprExport.Spr_PHConstraintEngineIf_GetRegularization((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    double result = (double) SprExport.Spr_PHConstraintEngineIf_GetRegularization((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public void EnableRenderContact(bool enable) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHConstraintEngineIf_EnableRenderContact((IntPtr) _thisArray[phSceneIf.sceneForStep], (bool) enable);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHConstraintEngineIf_EnableRenderContact((IntPtr) _thisArray[phSceneIf.sceneForGet], (bool) enable);
				}
			}
		} else {
	    SprExport.Spr_PHConstraintEngineIf_EnableRenderContact((IntPtr) _thisArray[0], (bool) enable);
		}
		throw new InvalidOperationException();
	}
    }
    public partial class PHGravityEngineIf : PHEngineIf {
	public PHGravityEngineIf() { _thisArray[0] = SprExport.Spr_new_PHGravityEngineIf(); _flag = true; }
	public PHGravityEngineIf(IntPtr ptr) : base(ptr) {}
	public PHGravityEngineIf(IntPtr ptr, bool flag) : base(ptr, flag) {}
	public static implicit operator PHGravityEngineIf(CsCastObject target) {
		return (target._info.Inherit(PHGravityEngineIf.GetIfInfoStatic()) ? new PHGravityEngineIf(target._thisArray[0], target._flag) : null);
	}
	~PHGravityEngineIf() { if (_flag) { SprExport.Spr_delete_PHGravityEngineIf(_thisArray[0]); _flag = false; } }
        public override string ToString() {
            IntPtr ptr = SprExport.Spr_PHGravityEngineIf_ToString((IntPtr) _thisArray[0]);
            string bstr = Marshal.PtrToStringBSTR(ptr);
            SprExport.Spr_PHGravityEngineIf_FreeString((IntPtr) ptr);
            return bstr;
        }
	public IfInfo GetIfInfo() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHGravityEngineIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new IfInfo(ptr);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHGravityEngineIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new IfInfo(ptr);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHGravityEngineIf_GetIfInfo((IntPtr) _thisArray[0]);
            return new IfInfo(ptr);
		}
		throw new InvalidOperationException();
	}
	public static IfInfo GetIfInfoStatic() {
	    IntPtr ptr = SprExport.Spr_PHGravityEngineIf_GetIfInfoStatic();
            return new IfInfo(ptr);
	}
    }
    public partial class PHPenaltyEngineIf : PHEngineIf {
	public PHPenaltyEngineIf() { _thisArray[0] = SprExport.Spr_new_PHPenaltyEngineIf(); _flag = true; }
	public PHPenaltyEngineIf(IntPtr ptr) : base(ptr) {}
	public PHPenaltyEngineIf(IntPtr ptr, bool flag) : base(ptr, flag) {}
	public static implicit operator PHPenaltyEngineIf(CsCastObject target) {
		return (target._info.Inherit(PHPenaltyEngineIf.GetIfInfoStatic()) ? new PHPenaltyEngineIf(target._thisArray[0], target._flag) : null);
	}
	~PHPenaltyEngineIf() { if (_flag) { SprExport.Spr_delete_PHPenaltyEngineIf(_thisArray[0]); _flag = false; } }
        public override string ToString() {
            IntPtr ptr = SprExport.Spr_PHPenaltyEngineIf_ToString((IntPtr) _thisArray[0]);
            string bstr = Marshal.PtrToStringBSTR(ptr);
            SprExport.Spr_PHPenaltyEngineIf_FreeString((IntPtr) ptr);
            return bstr;
        }
	public IfInfo GetIfInfo() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHPenaltyEngineIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new IfInfo(ptr);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHPenaltyEngineIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new IfInfo(ptr);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHPenaltyEngineIf_GetIfInfo((IntPtr) _thisArray[0]);
            return new IfInfo(ptr);
		}
		throw new InvalidOperationException();
	}
	public static IfInfo GetIfInfoStatic() {
	    IntPtr ptr = SprExport.Spr_PHPenaltyEngineIf_GetIfInfoStatic();
            return new IfInfo(ptr);
	}
    }
    public partial class PHIKEngineIf : PHEngineIf {
	public PHIKEngineIf() { _thisArray[0] = SprExport.Spr_new_PHIKEngineIf(); _flag = true; }
	public PHIKEngineIf(IntPtr ptr) : base(ptr) {}
	public PHIKEngineIf(IntPtr ptr, bool flag) : base(ptr, flag) {}
	public static implicit operator PHIKEngineIf(CsCastObject target) {
		return (target._info.Inherit(PHIKEngineIf.GetIfInfoStatic()) ? new PHIKEngineIf(target._thisArray[0], target._flag) : null);
	}
	~PHIKEngineIf() { if (_flag) { SprExport.Spr_delete_PHIKEngineIf(_thisArray[0]); _flag = false; } }
        public override string ToString() {
            IntPtr ptr = SprExport.Spr_PHIKEngineIf_ToString((IntPtr) _thisArray[0]);
            string bstr = Marshal.PtrToStringBSTR(ptr);
            SprExport.Spr_PHIKEngineIf_FreeString((IntPtr) ptr);
            return bstr;
        }
	public void SetMaxVelocity(double maxVel) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHIKEngineIf_SetMaxVelocity((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) maxVel);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHIKEngineIf_SetMaxVelocity((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) maxVel);
				}
			}
		} else {
	    SprExport.Spr_PHIKEngineIf_SetMaxVelocity((IntPtr) _thisArray[0], (double) maxVel);
		}
		throw new InvalidOperationException();
	}
	public double GetMaxVelocity() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    double result = (double) SprExport.Spr_PHIKEngineIf_GetMaxVelocity((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    double result = (double) SprExport.Spr_PHIKEngineIf_GetMaxVelocity((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    double result = (double) SprExport.Spr_PHIKEngineIf_GetMaxVelocity((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public void SetMaxAngularVelocity(double maxAV) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHIKEngineIf_SetMaxAngularVelocity((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) maxAV);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHIKEngineIf_SetMaxAngularVelocity((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) maxAV);
				}
			}
		} else {
	    SprExport.Spr_PHIKEngineIf_SetMaxAngularVelocity((IntPtr) _thisArray[0], (double) maxAV);
		}
		throw new InvalidOperationException();
	}
	public double GetMaxAngularVelocity() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    double result = (double) SprExport.Spr_PHIKEngineIf_GetMaxAngularVelocity((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    double result = (double) SprExport.Spr_PHIKEngineIf_GetMaxAngularVelocity((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    double result = (double) SprExport.Spr_PHIKEngineIf_GetMaxAngularVelocity((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public void SetMaxActuatorVelocity(double maxAV) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHIKEngineIf_SetMaxActuatorVelocity((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) maxAV);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHIKEngineIf_SetMaxActuatorVelocity((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) maxAV);
				}
			}
		} else {
	    SprExport.Spr_PHIKEngineIf_SetMaxActuatorVelocity((IntPtr) _thisArray[0], (double) maxAV);
		}
		throw new InvalidOperationException();
	}
	public double GetMaxActuatorVelocity() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    double result = (double) SprExport.Spr_PHIKEngineIf_GetMaxActuatorVelocity((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    double result = (double) SprExport.Spr_PHIKEngineIf_GetMaxActuatorVelocity((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    double result = (double) SprExport.Spr_PHIKEngineIf_GetMaxActuatorVelocity((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public void SetRegularizeParam(double epsilon) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHIKEngineIf_SetRegularizeParam((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) epsilon);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHIKEngineIf_SetRegularizeParam((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) epsilon);
				}
			}
		} else {
	    SprExport.Spr_PHIKEngineIf_SetRegularizeParam((IntPtr) _thisArray[0], (double) epsilon);
		}
		throw new InvalidOperationException();
	}
	public double GetRegularizeParam() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    double result = (double) SprExport.Spr_PHIKEngineIf_GetRegularizeParam((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    double result = (double) SprExport.Spr_PHIKEngineIf_GetRegularizeParam((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    double result = (double) SprExport.Spr_PHIKEngineIf_GetRegularizeParam((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public void SetIterCutOffAngVel(double epsilon) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHIKEngineIf_SetIterCutOffAngVel((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) epsilon);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHIKEngineIf_SetIterCutOffAngVel((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) epsilon);
				}
			}
		} else {
	    SprExport.Spr_PHIKEngineIf_SetIterCutOffAngVel((IntPtr) _thisArray[0], (double) epsilon);
		}
		throw new InvalidOperationException();
	}
	public double GetIterCutOffAngVel() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    double result = (double) SprExport.Spr_PHIKEngineIf_GetIterCutOffAngVel((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    double result = (double) SprExport.Spr_PHIKEngineIf_GetIterCutOffAngVel((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    double result = (double) SprExport.Spr_PHIKEngineIf_GetIterCutOffAngVel((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public void SetIntpRate() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHIKEngineIf_SetIntpRate((IntPtr) _thisArray[phSceneIf.sceneForStep]);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHIKEngineIf_SetIntpRate((IntPtr) _thisArray[phSceneIf.sceneForGet]);
				}
			}
		} else {
	    SprExport.Spr_PHIKEngineIf_SetIntpRate((IntPtr) _thisArray[0]);
		}
		throw new InvalidOperationException();
	}
	public int GetIntpRate() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    int result = (int) SprExport.Spr_PHIKEngineIf_GetIntpRate((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    int result = (int) SprExport.Spr_PHIKEngineIf_GetIntpRate((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    int result = (int) SprExport.Spr_PHIKEngineIf_GetIntpRate((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public void ApplyExactState(bool reverse) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHIKEngineIf_ApplyExactState((IntPtr) _thisArray[phSceneIf.sceneForStep], (bool) reverse);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHIKEngineIf_ApplyExactState((IntPtr) _thisArray[phSceneIf.sceneForGet], (bool) reverse);
				}
			}
		} else {
	    SprExport.Spr_PHIKEngineIf_ApplyExactState((IntPtr) _thisArray[0], (bool) reverse);
		}
		throw new InvalidOperationException();
	}
	public void ApplyExactState() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHIKEngineIf_ApplyExactState_1((IntPtr) _thisArray[phSceneIf.sceneForStep]);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHIKEngineIf_ApplyExactState_1((IntPtr) _thisArray[phSceneIf.sceneForGet]);
				}
			}
		} else {
	    SprExport.Spr_PHIKEngineIf_ApplyExactState_1((IntPtr) _thisArray[0]);
		}
		throw new InvalidOperationException();
	}
	public void SetNumIter(int numIter) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHIKEngineIf_SetNumIter((IntPtr) _thisArray[phSceneIf.sceneForStep], (int) numIter);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHIKEngineIf_SetNumIter((IntPtr) _thisArray[phSceneIf.sceneForGet], (int) numIter);
				}
			}
		} else {
	    SprExport.Spr_PHIKEngineIf_SetNumIter((IntPtr) _thisArray[0], (int) numIter);
		}
		throw new InvalidOperationException();
	}
	public int GetNumIter() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    int result = (int) SprExport.Spr_PHIKEngineIf_GetNumIter((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    int result = (int) SprExport.Spr_PHIKEngineIf_GetNumIter((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    int result = (int) SprExport.Spr_PHIKEngineIf_GetNumIter((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public void FK() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHIKEngineIf_FK((IntPtr) _thisArray[phSceneIf.sceneForStep]);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHIKEngineIf_FK((IntPtr) _thisArray[phSceneIf.sceneForGet]);
				}
			}
		} else {
	    SprExport.Spr_PHIKEngineIf_FK((IntPtr) _thisArray[0]);
		}
		throw new InvalidOperationException();
	}
	public IfInfo GetIfInfo() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHIKEngineIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new IfInfo(ptr);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHIKEngineIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new IfInfo(ptr);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHIKEngineIf_GetIfInfo((IntPtr) _thisArray[0]);
            return new IfInfo(ptr);
		}
		throw new InvalidOperationException();
	}
	public static IfInfo GetIfInfoStatic() {
	    IntPtr ptr = SprExport.Spr_PHIKEngineIf_GetIfInfoStatic();
            return new IfInfo(ptr);
	}
    }
    public partial class PHFemEngineIf : PHEngineIf {
	public PHFemEngineIf() { _thisArray[0] = SprExport.Spr_new_PHFemEngineIf(); _flag = true; }
	public PHFemEngineIf(IntPtr ptr) : base(ptr) {}
	public PHFemEngineIf(IntPtr ptr, bool flag) : base(ptr, flag) {}
	public static implicit operator PHFemEngineIf(CsCastObject target) {
		return (target._info.Inherit(PHFemEngineIf.GetIfInfoStatic()) ? new PHFemEngineIf(target._thisArray[0], target._flag) : null);
	}
	~PHFemEngineIf() { if (_flag) { SprExport.Spr_delete_PHFemEngineIf(_thisArray[0]); _flag = false; } }
        public override string ToString() {
            IntPtr ptr = SprExport.Spr_PHFemEngineIf_ToString((IntPtr) _thisArray[0]);
            string bstr = Marshal.PtrToStringBSTR(ptr);
            SprExport.Spr_PHFemEngineIf_FreeString((IntPtr) ptr);
            return bstr;
        }
	public IfInfo GetIfInfo() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHFemEngineIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new IfInfo(ptr);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHFemEngineIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new IfInfo(ptr);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHFemEngineIf_GetIfInfo((IntPtr) _thisArray[0]);
            return new IfInfo(ptr);
		}
		throw new InvalidOperationException();
	}
	public static IfInfo GetIfInfoStatic() {
	    IntPtr ptr = SprExport.Spr_PHFemEngineIf_GetIfInfoStatic();
            return new IfInfo(ptr);
	}
	public void SetTimeStep(double dt) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemEngineIf_SetTimeStep((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) dt);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemEngineIf_SetTimeStep((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) dt);
				}
			}
		} else {
	    SprExport.Spr_PHFemEngineIf_SetTimeStep((IntPtr) _thisArray[0], (double) dt);
		}
		throw new InvalidOperationException();
	}
	public double GetTimeStep() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    double result = (double) SprExport.Spr_PHFemEngineIf_GetTimeStep((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    double result = (double) SprExport.Spr_PHFemEngineIf_GetTimeStep((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    double result = (double) SprExport.Spr_PHFemEngineIf_GetTimeStep((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public void SetVibrationTransfer(bool bEnable) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemEngineIf_SetVibrationTransfer((IntPtr) _thisArray[phSceneIf.sceneForStep], (bool) bEnable);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemEngineIf_SetVibrationTransfer((IntPtr) _thisArray[phSceneIf.sceneForGet], (bool) bEnable);
				}
			}
		} else {
	    SprExport.Spr_PHFemEngineIf_SetVibrationTransfer((IntPtr) _thisArray[0], (bool) bEnable);
		}
		throw new InvalidOperationException();
	}
	public void SetThermalTransfer(bool bEnable) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemEngineIf_SetThermalTransfer((IntPtr) _thisArray[phSceneIf.sceneForStep], (bool) bEnable);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemEngineIf_SetThermalTransfer((IntPtr) _thisArray[phSceneIf.sceneForGet], (bool) bEnable);
				}
			}
		} else {
	    SprExport.Spr_PHFemEngineIf_SetThermalTransfer((IntPtr) _thisArray[0], (bool) bEnable);
		}
		throw new InvalidOperationException();
	}
	public int NMeshNew() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    int result = (int) SprExport.Spr_PHFemEngineIf_NMeshNew((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    int result = (int) SprExport.Spr_PHFemEngineIf_NMeshNew((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    int result = (int) SprExport.Spr_PHFemEngineIf_NMeshNew((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public PHFemMeshNewIf GetMeshNew(int i) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHFemEngineIf_GetMeshNew((IntPtr) _thisArray[phSceneIf.sceneForStep], (int) i);
            if (ptr == IntPtr.Zero) { return null; } 
            PHFemMeshNewIf obj = new PHFemMeshNewIf(ptr);
            return obj;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHFemEngineIf_GetMeshNew((IntPtr) _thisArray[phSceneIf.sceneForGet], (int) i);
            if (ptr == IntPtr.Zero) { return null; } 
            PHFemMeshNewIf obj = new PHFemMeshNewIf(ptr);
            return obj;
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHFemEngineIf_GetMeshNew((IntPtr) _thisArray[0], (int) i);
            if (ptr == IntPtr.Zero) { return null; } 
            PHFemMeshNewIf obj = new PHFemMeshNewIf(ptr);
            return obj;
		}
		throw new InvalidOperationException();
	}
	public bool AddMeshPair(PHFemMeshNewIf m0, PHFemMeshNewIf m1) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    char ret = SprExport.Spr_PHFemEngineIf_AddMeshPair((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) m0, (IntPtr) m1);
	    return (ret == 0) ? false : true;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    char ret = SprExport.Spr_PHFemEngineIf_AddMeshPair((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) m0, (IntPtr) m1);
	    return (ret == 0) ? false : true;
				}
			}
		} else {
	    char ret = SprExport.Spr_PHFemEngineIf_AddMeshPair((IntPtr) _thisArray[0], (IntPtr) m0, (IntPtr) m1);
	    return (ret == 0) ? false : true;
		}
		throw new InvalidOperationException();
	}
	public bool RemoveMeshPair(PHFemMeshNewIf m0, PHFemMeshNewIf m1) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    char ret = SprExport.Spr_PHFemEngineIf_RemoveMeshPair((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) m0, (IntPtr) m1);
	    return (ret == 0) ? false : true;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    char ret = SprExport.Spr_PHFemEngineIf_RemoveMeshPair((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) m0, (IntPtr) m1);
	    return (ret == 0) ? false : true;
				}
			}
		} else {
	    char ret = SprExport.Spr_PHFemEngineIf_RemoveMeshPair((IntPtr) _thisArray[0], (IntPtr) m0, (IntPtr) m1);
	    return (ret == 0) ? false : true;
		}
		throw new InvalidOperationException();
	}
	public void ThermalTransfer() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemEngineIf_ThermalTransfer((IntPtr) _thisArray[phSceneIf.sceneForStep]);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemEngineIf_ThermalTransfer((IntPtr) _thisArray[phSceneIf.sceneForGet]);
				}
			}
		} else {
	    SprExport.Spr_PHFemEngineIf_ThermalTransfer((IntPtr) _thisArray[0]);
		}
		throw new InvalidOperationException();
	}
	public void setheatTransferRatio(double setheatTransferRatio) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemEngineIf_setheatTransferRatio((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) setheatTransferRatio);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemEngineIf_setheatTransferRatio((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) setheatTransferRatio);
				}
			}
		} else {
	    SprExport.Spr_PHFemEngineIf_setheatTransferRatio((IntPtr) _thisArray[0], (double) setheatTransferRatio);
		}
		throw new InvalidOperationException();
	}
	public void FEMSolidMatchRefresh() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemEngineIf_FEMSolidMatchRefresh((IntPtr) _thisArray[phSceneIf.sceneForStep]);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemEngineIf_FEMSolidMatchRefresh((IntPtr) _thisArray[phSceneIf.sceneForGet]);
				}
			}
		} else {
	    SprExport.Spr_PHFemEngineIf_FEMSolidMatchRefresh((IntPtr) _thisArray[0]);
		}
		throw new InvalidOperationException();
	}
	public void InitContacts() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemEngineIf_InitContacts((IntPtr) _thisArray[phSceneIf.sceneForStep]);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemEngineIf_InitContacts((IntPtr) _thisArray[phSceneIf.sceneForGet]);
				}
			}
		} else {
	    SprExport.Spr_PHFemEngineIf_InitContacts((IntPtr) _thisArray[0]);
		}
		throw new InvalidOperationException();
	}
	public void ClearContactVectors() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemEngineIf_ClearContactVectors((IntPtr) _thisArray[phSceneIf.sceneForStep]);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemEngineIf_ClearContactVectors((IntPtr) _thisArray[phSceneIf.sceneForGet]);
				}
			}
		} else {
	    SprExport.Spr_PHFemEngineIf_ClearContactVectors((IntPtr) _thisArray[0]);
		}
		throw new InvalidOperationException();
	}
	public int NMesh() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    int result = (int) SprExport.Spr_PHFemEngineIf_NMesh((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    int result = (int) SprExport.Spr_PHFemEngineIf_NMesh((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    int result = (int) SprExport.Spr_PHFemEngineIf_NMesh((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public PHFemMeshIf GetMesh(int i) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHFemEngineIf_GetMesh((IntPtr) _thisArray[phSceneIf.sceneForStep], (int) i);
            if (ptr == IntPtr.Zero) { return null; } 
            PHFemMeshIf obj = new PHFemMeshIf(ptr);
            if (obj.GetIfInfo() == PHFemMeshThermoIf.GetIfInfoStatic()) { return new PHFemMeshThermoIf(ptr); }
            return obj;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHFemEngineIf_GetMesh((IntPtr) _thisArray[phSceneIf.sceneForGet], (int) i);
            if (ptr == IntPtr.Zero) { return null; } 
            PHFemMeshIf obj = new PHFemMeshIf(ptr);
            if (obj.GetIfInfo() == PHFemMeshThermoIf.GetIfInfoStatic()) { return new PHFemMeshThermoIf(ptr); }
            return obj;
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHFemEngineIf_GetMesh((IntPtr) _thisArray[0], (int) i);
            if (ptr == IntPtr.Zero) { return null; } 
            PHFemMeshIf obj = new PHFemMeshIf(ptr);
            if (obj.GetIfInfo() == PHFemMeshThermoIf.GetIfInfoStatic()) { return new PHFemMeshThermoIf(ptr); }
            return obj;
		}
		throw new InvalidOperationException();
	}
    }
    public partial class PHOpEngineIf : PHEngineIf {
	public PHOpEngineIf() { _thisArray[0] = SprExport.Spr_new_PHOpEngineIf(); _flag = true; }
	public PHOpEngineIf(IntPtr ptr) : base(ptr) {}
	public PHOpEngineIf(IntPtr ptr, bool flag) : base(ptr, flag) {}
	public static implicit operator PHOpEngineIf(CsCastObject target) {
		return (target._info.Inherit(PHOpEngineIf.GetIfInfoStatic()) ? new PHOpEngineIf(target._thisArray[0], target._flag) : null);
	}
	~PHOpEngineIf() { if (_flag) { SprExport.Spr_delete_PHOpEngineIf(_thisArray[0]); _flag = false; } }
        public override string ToString() {
            IntPtr ptr = SprExport.Spr_PHOpEngineIf_ToString((IntPtr) _thisArray[0]);
            string bstr = Marshal.PtrToStringBSTR(ptr);
            SprExport.Spr_PHOpEngineIf_FreeString((IntPtr) ptr);
            return bstr;
        }
	public IfInfo GetIfInfo() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHOpEngineIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new IfInfo(ptr);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHOpEngineIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new IfInfo(ptr);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHOpEngineIf_GetIfInfo((IntPtr) _thisArray[0]);
            return new IfInfo(ptr);
		}
		throw new InvalidOperationException();
	}
	public static IfInfo GetIfInfoStatic() {
	    IntPtr ptr = SprExport.Spr_PHOpEngineIf_GetIfInfoStatic();
            return new IfInfo(ptr);
	}
	public void SetTimeStep(double dt) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHOpEngineIf_SetTimeStep((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) dt);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHOpEngineIf_SetTimeStep((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) dt);
				}
			}
		} else {
	    SprExport.Spr_PHOpEngineIf_SetTimeStep((IntPtr) _thisArray[0], (double) dt);
		}
		throw new InvalidOperationException();
	}
	public double GetTimeStep() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    double result = (double) SprExport.Spr_PHOpEngineIf_GetTimeStep((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    double result = (double) SprExport.Spr_PHOpEngineIf_GetTimeStep((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    double result = (double) SprExport.Spr_PHOpEngineIf_GetTimeStep((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public void SetGravity(bool gflag) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHOpEngineIf_SetGravity((IntPtr) _thisArray[phSceneIf.sceneForStep], (bool) gflag);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHOpEngineIf_SetGravity((IntPtr) _thisArray[phSceneIf.sceneForGet], (bool) gflag);
				}
			}
		} else {
	    SprExport.Spr_PHOpEngineIf_SetGravity((IntPtr) _thisArray[0], (bool) gflag);
		}
		throw new InvalidOperationException();
	}
	public void InitialHapticRenderer(int objId) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHOpEngineIf_InitialHapticRenderer((IntPtr) _thisArray[phSceneIf.sceneForStep], (int) objId);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHOpEngineIf_InitialHapticRenderer((IntPtr) _thisArray[phSceneIf.sceneForGet], (int) objId);
				}
			}
		} else {
	    SprExport.Spr_PHOpEngineIf_InitialHapticRenderer((IntPtr) _thisArray[0], (int) objId);
		}
		throw new InvalidOperationException();
	}
	public arraywrapper_PHOpObjDesc GetOpObj(int i) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHOpEngineIf_GetOpObj((IntPtr) _thisArray[phSceneIf.sceneForStep], (int) i);
            return new arraywrapper_PHOpObjDesc(ptr);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHOpEngineIf_GetOpObj((IntPtr) _thisArray[phSceneIf.sceneForGet], (int) i);
            return new arraywrapper_PHOpObjDesc(ptr);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHOpEngineIf_GetOpObj((IntPtr) _thisArray[0], (int) i);
            return new arraywrapper_PHOpObjDesc(ptr);
		}
		throw new InvalidOperationException();
	}
	public void StepWithBlend() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHOpEngineIf_StepWithBlend((IntPtr) _thisArray[phSceneIf.sceneForStep]);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHOpEngineIf_StepWithBlend((IntPtr) _thisArray[phSceneIf.sceneForGet]);
				}
			}
		} else {
	    SprExport.Spr_PHOpEngineIf_StepWithBlend((IntPtr) _thisArray[0]);
		}
		throw new InvalidOperationException();
	}
	public int AddOpObj() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    int result = (int) SprExport.Spr_PHOpEngineIf_AddOpObj((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    int result = (int) SprExport.Spr_PHOpEngineIf_AddOpObj((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    int result = (int) SprExport.Spr_PHOpEngineIf_AddOpObj((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public void SetHapticSolveEnable(bool enable) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHOpEngineIf_SetHapticSolveEnable((IntPtr) _thisArray[phSceneIf.sceneForStep], (bool) enable);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHOpEngineIf_SetHapticSolveEnable((IntPtr) _thisArray[phSceneIf.sceneForGet], (bool) enable);
				}
			}
		} else {
	    SprExport.Spr_PHOpEngineIf_SetHapticSolveEnable((IntPtr) _thisArray[0], (bool) enable);
		}
		throw new InvalidOperationException();
	}
	public bool IsHapticSolve() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    char ret = SprExport.Spr_PHOpEngineIf_IsHapticSolve((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return (ret == 0) ? false : true;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    char ret = SprExport.Spr_PHOpEngineIf_IsHapticSolve((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return (ret == 0) ? false : true;
				}
			}
		} else {
	    char ret = SprExport.Spr_PHOpEngineIf_IsHapticSolve((IntPtr) _thisArray[0]);
	    return (ret == 0) ? false : true;
		}
		throw new InvalidOperationException();
	}
	public void SetProxyCorrectionEnable(bool enable) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHOpEngineIf_SetProxyCorrectionEnable((IntPtr) _thisArray[phSceneIf.sceneForStep], (bool) enable);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHOpEngineIf_SetProxyCorrectionEnable((IntPtr) _thisArray[phSceneIf.sceneForGet], (bool) enable);
				}
			}
		} else {
	    SprExport.Spr_PHOpEngineIf_SetProxyCorrectionEnable((IntPtr) _thisArray[0], (bool) enable);
		}
		throw new InvalidOperationException();
	}
	public bool IsProxyCorrection() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    char ret = SprExport.Spr_PHOpEngineIf_IsProxyCorrection((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return (ret == 0) ? false : true;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    char ret = SprExport.Spr_PHOpEngineIf_IsProxyCorrection((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return (ret == 0) ? false : true;
				}
			}
		} else {
	    char ret = SprExport.Spr_PHOpEngineIf_IsProxyCorrection((IntPtr) _thisArray[0]);
	    return (ret == 0) ? false : true;
		}
		throw new InvalidOperationException();
	}
	public void SetUpdateNormal(bool flag) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHOpEngineIf_SetUpdateNormal((IntPtr) _thisArray[phSceneIf.sceneForStep], (bool) flag);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHOpEngineIf_SetUpdateNormal((IntPtr) _thisArray[phSceneIf.sceneForGet], (bool) flag);
				}
			}
		} else {
	    SprExport.Spr_PHOpEngineIf_SetUpdateNormal((IntPtr) _thisArray[0], (bool) flag);
		}
		throw new InvalidOperationException();
	}
	public bool IsUpdateNormal(int obji) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    char ret = SprExport.Spr_PHOpEngineIf_IsUpdateNormal((IntPtr) _thisArray[phSceneIf.sceneForStep], (int) obji);
	    return (ret == 0) ? false : true;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    char ret = SprExport.Spr_PHOpEngineIf_IsUpdateNormal((IntPtr) _thisArray[phSceneIf.sceneForGet], (int) obji);
	    return (ret == 0) ? false : true;
				}
			}
		} else {
	    char ret = SprExport.Spr_PHOpEngineIf_IsUpdateNormal((IntPtr) _thisArray[0], (int) obji);
	    return (ret == 0) ? false : true;
		}
		throw new InvalidOperationException();
	}
	public void SetUseHaptic(bool hapticUsage) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHOpEngineIf_SetUseHaptic((IntPtr) _thisArray[phSceneIf.sceneForStep], (bool) hapticUsage);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHOpEngineIf_SetUseHaptic((IntPtr) _thisArray[phSceneIf.sceneForGet], (bool) hapticUsage);
				}
			}
		} else {
	    SprExport.Spr_PHOpEngineIf_SetUseHaptic((IntPtr) _thisArray[0], (bool) hapticUsage);
		}
		throw new InvalidOperationException();
	}
	public bool GetUseHaptic() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    char ret = SprExport.Spr_PHOpEngineIf_GetUseHaptic((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return (ret == 0) ? false : true;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    char ret = SprExport.Spr_PHOpEngineIf_GetUseHaptic((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return (ret == 0) ? false : true;
				}
			}
		} else {
	    char ret = SprExport.Spr_PHOpEngineIf_GetUseHaptic((IntPtr) _thisArray[0]);
	    return (ret == 0) ? false : true;
		}
		throw new InvalidOperationException();
	}
	public PHOpObjIf GetOpObjIf(int obji) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHOpEngineIf_GetOpObjIf((IntPtr) _thisArray[phSceneIf.sceneForStep], (int) obji);
            if (ptr == IntPtr.Zero) { return null; } 
            PHOpObjIf obj = new PHOpObjIf(ptr);
            return obj;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHOpEngineIf_GetOpObjIf((IntPtr) _thisArray[phSceneIf.sceneForGet], (int) obji);
            if (ptr == IntPtr.Zero) { return null; } 
            PHOpObjIf obj = new PHOpObjIf(ptr);
            return obj;
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHOpEngineIf_GetOpObjIf((IntPtr) _thisArray[0], (int) obji);
            if (ptr == IntPtr.Zero) { return null; } 
            PHOpObjIf obj = new PHOpObjIf(ptr);
            return obj;
		}
		throw new InvalidOperationException();
	}
	public int GetOpObjNum() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    int result = (int) SprExport.Spr_PHOpEngineIf_GetOpObjNum((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    int result = (int) SprExport.Spr_PHOpEngineIf_GetOpObjNum((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    int result = (int) SprExport.Spr_PHOpEngineIf_GetOpObjNum((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public ObjectIf GetOpAnimator() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHOpEngineIf_GetOpAnimator((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            if (ptr == IntPtr.Zero) { return null; } 
            ObjectIf obj = new ObjectIf(ptr);
            if (obj.GetIfInfo() == PHSolidPairIf.GetIfInfoStatic()) { return new PHSolidPairIf(ptr); }
            if (obj.GetIfInfo() == PHOpParticleIf.GetIfInfoStatic()) { return new PHOpParticleIf(ptr); }
            if (obj.GetIfInfo() == PHOpGroupIf.GetIfInfoStatic()) { return new PHOpGroupIf(ptr); }
            if (obj.GetIfInfo() == PHOpSpHashColliAgentIf.GetIfInfoStatic()) { return new PHOpSpHashColliAgentIf(ptr); }
            if (obj.GetIfInfo() == PHSolidPairForLCPIf.GetIfInfoStatic()) { return new PHSolidPairForLCPIf(ptr); }
            if (obj.GetIfInfo() == PHSolidPairForHapticIf.GetIfInfoStatic()) { return new PHSolidPairForHapticIf(ptr); }
            return obj;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHOpEngineIf_GetOpAnimator((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            if (ptr == IntPtr.Zero) { return null; } 
            ObjectIf obj = new ObjectIf(ptr);
            if (obj.GetIfInfo() == PHSolidPairIf.GetIfInfoStatic()) { return new PHSolidPairIf(ptr); }
            if (obj.GetIfInfo() == PHOpParticleIf.GetIfInfoStatic()) { return new PHOpParticleIf(ptr); }
            if (obj.GetIfInfo() == PHOpGroupIf.GetIfInfoStatic()) { return new PHOpGroupIf(ptr); }
            if (obj.GetIfInfo() == PHOpSpHashColliAgentIf.GetIfInfoStatic()) { return new PHOpSpHashColliAgentIf(ptr); }
            if (obj.GetIfInfo() == PHSolidPairForLCPIf.GetIfInfoStatic()) { return new PHSolidPairForLCPIf(ptr); }
            if (obj.GetIfInfo() == PHSolidPairForHapticIf.GetIfInfoStatic()) { return new PHSolidPairForHapticIf(ptr); }
            return obj;
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHOpEngineIf_GetOpAnimator((IntPtr) _thisArray[0]);
            if (ptr == IntPtr.Zero) { return null; } 
            ObjectIf obj = new ObjectIf(ptr);
            if (obj.GetIfInfo() == PHSolidPairIf.GetIfInfoStatic()) { return new PHSolidPairIf(ptr); }
            if (obj.GetIfInfo() == PHOpParticleIf.GetIfInfoStatic()) { return new PHOpParticleIf(ptr); }
            if (obj.GetIfInfo() == PHOpGroupIf.GetIfInfoStatic()) { return new PHOpGroupIf(ptr); }
            if (obj.GetIfInfo() == PHOpSpHashColliAgentIf.GetIfInfoStatic()) { return new PHOpSpHashColliAgentIf(ptr); }
            if (obj.GetIfInfo() == PHSolidPairForLCPIf.GetIfInfoStatic()) { return new PHSolidPairForLCPIf(ptr); }
            if (obj.GetIfInfo() == PHSolidPairForHapticIf.GetIfInfoStatic()) { return new PHSolidPairForHapticIf(ptr); }
            return obj;
		}
		throw new InvalidOperationException();
	}
	public ObjectIf GetOpHapticController() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHOpEngineIf_GetOpHapticController((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            if (ptr == IntPtr.Zero) { return null; } 
            ObjectIf obj = new ObjectIf(ptr);
            if (obj.GetIfInfo() == PHSolidPairIf.GetIfInfoStatic()) { return new PHSolidPairIf(ptr); }
            if (obj.GetIfInfo() == PHOpParticleIf.GetIfInfoStatic()) { return new PHOpParticleIf(ptr); }
            if (obj.GetIfInfo() == PHOpGroupIf.GetIfInfoStatic()) { return new PHOpGroupIf(ptr); }
            if (obj.GetIfInfo() == PHOpSpHashColliAgentIf.GetIfInfoStatic()) { return new PHOpSpHashColliAgentIf(ptr); }
            if (obj.GetIfInfo() == PHSolidPairForLCPIf.GetIfInfoStatic()) { return new PHSolidPairForLCPIf(ptr); }
            if (obj.GetIfInfo() == PHSolidPairForHapticIf.GetIfInfoStatic()) { return new PHSolidPairForHapticIf(ptr); }
            return obj;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHOpEngineIf_GetOpHapticController((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            if (ptr == IntPtr.Zero) { return null; } 
            ObjectIf obj = new ObjectIf(ptr);
            if (obj.GetIfInfo() == PHSolidPairIf.GetIfInfoStatic()) { return new PHSolidPairIf(ptr); }
            if (obj.GetIfInfo() == PHOpParticleIf.GetIfInfoStatic()) { return new PHOpParticleIf(ptr); }
            if (obj.GetIfInfo() == PHOpGroupIf.GetIfInfoStatic()) { return new PHOpGroupIf(ptr); }
            if (obj.GetIfInfo() == PHOpSpHashColliAgentIf.GetIfInfoStatic()) { return new PHOpSpHashColliAgentIf(ptr); }
            if (obj.GetIfInfo() == PHSolidPairForLCPIf.GetIfInfoStatic()) { return new PHSolidPairForLCPIf(ptr); }
            if (obj.GetIfInfo() == PHSolidPairForHapticIf.GetIfInfoStatic()) { return new PHSolidPairForHapticIf(ptr); }
            return obj;
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHOpEngineIf_GetOpHapticController((IntPtr) _thisArray[0]);
            if (ptr == IntPtr.Zero) { return null; } 
            ObjectIf obj = new ObjectIf(ptr);
            if (obj.GetIfInfo() == PHSolidPairIf.GetIfInfoStatic()) { return new PHSolidPairIf(ptr); }
            if (obj.GetIfInfo() == PHOpParticleIf.GetIfInfoStatic()) { return new PHOpParticleIf(ptr); }
            if (obj.GetIfInfo() == PHOpGroupIf.GetIfInfoStatic()) { return new PHOpGroupIf(ptr); }
            if (obj.GetIfInfo() == PHOpSpHashColliAgentIf.GetIfInfoStatic()) { return new PHOpSpHashColliAgentIf(ptr); }
            if (obj.GetIfInfo() == PHSolidPairForLCPIf.GetIfInfoStatic()) { return new PHSolidPairForLCPIf(ptr); }
            if (obj.GetIfInfo() == PHSolidPairForHapticIf.GetIfInfoStatic()) { return new PHSolidPairForHapticIf(ptr); }
            return obj;
		}
		throw new InvalidOperationException();
	}
	public ObjectIf GetOpHapticRenderer() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHOpEngineIf_GetOpHapticRenderer((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            if (ptr == IntPtr.Zero) { return null; } 
            ObjectIf obj = new ObjectIf(ptr);
            if (obj.GetIfInfo() == PHSolidPairIf.GetIfInfoStatic()) { return new PHSolidPairIf(ptr); }
            if (obj.GetIfInfo() == PHOpParticleIf.GetIfInfoStatic()) { return new PHOpParticleIf(ptr); }
            if (obj.GetIfInfo() == PHOpGroupIf.GetIfInfoStatic()) { return new PHOpGroupIf(ptr); }
            if (obj.GetIfInfo() == PHOpSpHashColliAgentIf.GetIfInfoStatic()) { return new PHOpSpHashColliAgentIf(ptr); }
            if (obj.GetIfInfo() == PHSolidPairForLCPIf.GetIfInfoStatic()) { return new PHSolidPairForLCPIf(ptr); }
            if (obj.GetIfInfo() == PHSolidPairForHapticIf.GetIfInfoStatic()) { return new PHSolidPairForHapticIf(ptr); }
            return obj;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHOpEngineIf_GetOpHapticRenderer((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            if (ptr == IntPtr.Zero) { return null; } 
            ObjectIf obj = new ObjectIf(ptr);
            if (obj.GetIfInfo() == PHSolidPairIf.GetIfInfoStatic()) { return new PHSolidPairIf(ptr); }
            if (obj.GetIfInfo() == PHOpParticleIf.GetIfInfoStatic()) { return new PHOpParticleIf(ptr); }
            if (obj.GetIfInfo() == PHOpGroupIf.GetIfInfoStatic()) { return new PHOpGroupIf(ptr); }
            if (obj.GetIfInfo() == PHOpSpHashColliAgentIf.GetIfInfoStatic()) { return new PHOpSpHashColliAgentIf(ptr); }
            if (obj.GetIfInfo() == PHSolidPairForLCPIf.GetIfInfoStatic()) { return new PHSolidPairForLCPIf(ptr); }
            if (obj.GetIfInfo() == PHSolidPairForHapticIf.GetIfInfoStatic()) { return new PHSolidPairForHapticIf(ptr); }
            return obj;
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHOpEngineIf_GetOpHapticRenderer((IntPtr) _thisArray[0]);
            if (ptr == IntPtr.Zero) { return null; } 
            ObjectIf obj = new ObjectIf(ptr);
            if (obj.GetIfInfo() == PHSolidPairIf.GetIfInfoStatic()) { return new PHSolidPairIf(ptr); }
            if (obj.GetIfInfo() == PHOpParticleIf.GetIfInfoStatic()) { return new PHOpParticleIf(ptr); }
            if (obj.GetIfInfo() == PHOpGroupIf.GetIfInfoStatic()) { return new PHOpGroupIf(ptr); }
            if (obj.GetIfInfo() == PHOpSpHashColliAgentIf.GetIfInfoStatic()) { return new PHOpSpHashColliAgentIf(ptr); }
            if (obj.GetIfInfo() == PHSolidPairForLCPIf.GetIfInfoStatic()) { return new PHSolidPairForLCPIf(ptr); }
            if (obj.GetIfInfo() == PHSolidPairForHapticIf.GetIfInfoStatic()) { return new PHSolidPairForHapticIf(ptr); }
            return obj;
		}
		throw new InvalidOperationException();
	}
	public void SetIterationCount(int count) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHOpEngineIf_SetIterationCount((IntPtr) _thisArray[phSceneIf.sceneForStep], (int) count);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHOpEngineIf_SetIterationCount((IntPtr) _thisArray[phSceneIf.sceneForGet], (int) count);
				}
			}
		} else {
	    SprExport.Spr_PHOpEngineIf_SetIterationCount((IntPtr) _thisArray[0], (int) count);
		}
		throw new InvalidOperationException();
	}
	public int GetIterationCount() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    int result = (int) SprExport.Spr_PHOpEngineIf_GetIterationCount((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    int result = (int) SprExport.Spr_PHOpEngineIf_GetIterationCount((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    int result = (int) SprExport.Spr_PHOpEngineIf_GetIterationCount((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public void SetAnimationFlag(bool flag) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHOpEngineIf_SetAnimationFlag((IntPtr) _thisArray[phSceneIf.sceneForStep], (bool) flag);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHOpEngineIf_SetAnimationFlag((IntPtr) _thisArray[phSceneIf.sceneForGet], (bool) flag);
				}
			}
		} else {
	    SprExport.Spr_PHOpEngineIf_SetAnimationFlag((IntPtr) _thisArray[0], (bool) flag);
		}
		throw new InvalidOperationException();
	}
	public bool GetAnimationFlag() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    char ret = SprExport.Spr_PHOpEngineIf_GetAnimationFlag((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return (ret == 0) ? false : true;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    char ret = SprExport.Spr_PHOpEngineIf_GetAnimationFlag((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return (ret == 0) ? false : true;
				}
			}
		} else {
	    char ret = SprExport.Spr_PHOpEngineIf_GetAnimationFlag((IntPtr) _thisArray[0]);
	    return (ret == 0) ? false : true;
		}
		throw new InvalidOperationException();
	}
	public void SetDrawPtclR(float r) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHOpEngineIf_SetDrawPtclR((IntPtr) _thisArray[phSceneIf.sceneForStep], (float) r);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHOpEngineIf_SetDrawPtclR((IntPtr) _thisArray[phSceneIf.sceneForGet], (float) r);
				}
			}
		} else {
	    SprExport.Spr_PHOpEngineIf_SetDrawPtclR((IntPtr) _thisArray[0], (float) r);
		}
		throw new InvalidOperationException();
	}
	public float GetDrawPtclR() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    float result = (float) SprExport.Spr_PHOpEngineIf_GetDrawPtclR((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    float result = (float) SprExport.Spr_PHOpEngineIf_GetDrawPtclR((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    float result = (float) SprExport.Spr_PHOpEngineIf_GetDrawPtclR((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public void InitialNoMeshHapticRenderer() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHOpEngineIf_InitialNoMeshHapticRenderer((IntPtr) _thisArray[phSceneIf.sceneForStep]);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHOpEngineIf_InitialNoMeshHapticRenderer((IntPtr) _thisArray[phSceneIf.sceneForGet]);
				}
			}
		} else {
	    SprExport.Spr_PHOpEngineIf_InitialNoMeshHapticRenderer((IntPtr) _thisArray[0]);
		}
		throw new InvalidOperationException();
	}
    }
    public partial class PHFemMeshIf : SceneObjectIf {
	public PHFemMeshIf() { _thisArray[0] = SprExport.Spr_new_PHFemMeshIf(); _flag = true; }
	public PHFemMeshIf(IntPtr ptr) : base(ptr) {}
	public PHFemMeshIf(IntPtr ptr, bool flag) : base(ptr, flag) {}
	public static implicit operator PHFemMeshIf(CsCastObject target) {
		return (target._info.Inherit(PHFemMeshIf.GetIfInfoStatic()) ? new PHFemMeshIf(target._thisArray[0], target._flag) : null);
	}
	~PHFemMeshIf() { if (_flag) { SprExport.Spr_delete_PHFemMeshIf(_thisArray[0]); _flag = false; } }
        public override string ToString() {
            IntPtr ptr = SprExport.Spr_PHFemMeshIf_ToString((IntPtr) _thisArray[0]);
            string bstr = Marshal.PtrToStringBSTR(ptr);
            SprExport.Spr_PHFemMeshIf_FreeString((IntPtr) ptr);
            return bstr;
        }
	public IfInfo GetIfInfo() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHFemMeshIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new IfInfo(ptr);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHFemMeshIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new IfInfo(ptr);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHFemMeshIf_GetIfInfo((IntPtr) _thisArray[0]);
            return new IfInfo(ptr);
		}
		throw new InvalidOperationException();
	}
	public static IfInfo GetIfInfoStatic() {
	    IntPtr ptr = SprExport.Spr_PHFemMeshIf_GetIfInfoStatic();
            return new IfInfo(ptr);
	}
    }
    public partial class PHFemMeshThermoIf : PHFemMeshIf {
	public PHFemMeshThermoIf() { _thisArray[0] = SprExport.Spr_new_PHFemMeshThermoIf(); _flag = true; }
	public PHFemMeshThermoIf(IntPtr ptr) : base(ptr) {}
	public PHFemMeshThermoIf(IntPtr ptr, bool flag) : base(ptr, flag) {}
	public static implicit operator PHFemMeshThermoIf(CsCastObject target) {
		return (target._info.Inherit(PHFemMeshThermoIf.GetIfInfoStatic()) ? new PHFemMeshThermoIf(target._thisArray[0], target._flag) : null);
	}
	~PHFemMeshThermoIf() { if (_flag) { SprExport.Spr_delete_PHFemMeshThermoIf(_thisArray[0]); _flag = false; } }
        public override string ToString() {
            IntPtr ptr = SprExport.Spr_PHFemMeshThermoIf_ToString((IntPtr) _thisArray[0]);
            string bstr = Marshal.PtrToStringBSTR(ptr);
            SprExport.Spr_PHFemMeshThermoIf_FreeString((IntPtr) ptr);
            return bstr;
        }
	public IfInfo GetIfInfo() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHFemMeshThermoIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new IfInfo(ptr);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHFemMeshThermoIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new IfInfo(ptr);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHFemMeshThermoIf_GetIfInfo((IntPtr) _thisArray[0]);
            return new IfInfo(ptr);
		}
		throw new InvalidOperationException();
	}
	public static IfInfo GetIfInfoStatic() {
	    IntPtr ptr = SprExport.Spr_PHFemMeshThermoIf_GetIfInfoStatic();
            return new IfInfo(ptr);
	}
	public int GetSurfaceVertex(int id) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    int result = (int) SprExport.Spr_PHFemMeshThermoIf_GetSurfaceVertex((IntPtr) _thisArray[phSceneIf.sceneForStep], (int) id);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    int result = (int) SprExport.Spr_PHFemMeshThermoIf_GetSurfaceVertex((IntPtr) _thisArray[phSceneIf.sceneForGet], (int) id);
	    return result;
				}
			}
		} else {
	    int result = (int) SprExport.Spr_PHFemMeshThermoIf_GetSurfaceVertex((IntPtr) _thisArray[0], (int) id);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public int NSurfaceVertices() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    int result = (int) SprExport.Spr_PHFemMeshThermoIf_NSurfaceVertices((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    int result = (int) SprExport.Spr_PHFemMeshThermoIf_NSurfaceVertices((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    int result = (int) SprExport.Spr_PHFemMeshThermoIf_NSurfaceVertices((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public void SetVertexTc(int id, double temp) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemMeshThermoIf_SetVertexTc((IntPtr) _thisArray[phSceneIf.sceneForStep], (int) id, (double) temp);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemMeshThermoIf_SetVertexTc((IntPtr) _thisArray[phSceneIf.sceneForGet], (int) id, (double) temp);
				}
			}
		} else {
	    SprExport.Spr_PHFemMeshThermoIf_SetVertexTc((IntPtr) _thisArray[0], (int) id, (double) temp);
		}
		throw new InvalidOperationException();
	}
	public void SetVertexTc(int id, double temp, double heatTrans) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemMeshThermoIf_SetVertexTc_1((IntPtr) _thisArray[phSceneIf.sceneForStep], (int) id, (double) temp, (double) heatTrans);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemMeshThermoIf_SetVertexTc_1((IntPtr) _thisArray[phSceneIf.sceneForGet], (int) id, (double) temp, (double) heatTrans);
				}
			}
		} else {
	    SprExport.Spr_PHFemMeshThermoIf_SetVertexTc_1((IntPtr) _thisArray[0], (int) id, (double) temp, (double) heatTrans);
		}
		throw new InvalidOperationException();
	}
	public Vec3d GetPose(int id) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHFemMeshThermoIf_GetPose((IntPtr) _thisArray[phSceneIf.sceneForStep], (int) id);
            return new Vec3d(ptr, true);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHFemMeshThermoIf_GetPose((IntPtr) _thisArray[phSceneIf.sceneForGet], (int) id);
            return new Vec3d(ptr, true);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHFemMeshThermoIf_GetPose((IntPtr) _thisArray[0], (int) id);
            return new Vec3d(ptr, true);
		}
		throw new InvalidOperationException();
	}
	public Vec3d GetSufVtxPose(uint id) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHFemMeshThermoIf_GetSufVtxPose((IntPtr) _thisArray[phSceneIf.sceneForStep], (uint) id);
            return new Vec3d(ptr, true);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHFemMeshThermoIf_GetSufVtxPose((IntPtr) _thisArray[phSceneIf.sceneForGet], (uint) id);
            return new Vec3d(ptr, true);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHFemMeshThermoIf_GetSufVtxPose((IntPtr) _thisArray[0], (uint) id);
            return new Vec3d(ptr, true);
		}
		throw new InvalidOperationException();
	}
	public uint GetStepCount() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    uint result = (uint) SprExport.Spr_PHFemMeshThermoIf_GetStepCount((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    uint result = (uint) SprExport.Spr_PHFemMeshThermoIf_GetStepCount((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    uint result = (uint) SprExport.Spr_PHFemMeshThermoIf_GetStepCount((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public uint GetStepCountCyc() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    uint result = (uint) SprExport.Spr_PHFemMeshThermoIf_GetStepCountCyc((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    uint result = (uint) SprExport.Spr_PHFemMeshThermoIf_GetStepCountCyc((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    uint result = (uint) SprExport.Spr_PHFemMeshThermoIf_GetStepCountCyc((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public double GetVertexTemp(uint id) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    double result = (double) SprExport.Spr_PHFemMeshThermoIf_GetVertexTemp((IntPtr) _thisArray[phSceneIf.sceneForStep], (uint) id);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    double result = (double) SprExport.Spr_PHFemMeshThermoIf_GetVertexTemp((IntPtr) _thisArray[phSceneIf.sceneForGet], (uint) id);
	    return result;
				}
			}
		} else {
	    double result = (double) SprExport.Spr_PHFemMeshThermoIf_GetVertexTemp((IntPtr) _thisArray[0], (uint) id);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public double GetSufVertexTemp(uint id) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    double result = (double) SprExport.Spr_PHFemMeshThermoIf_GetSufVertexTemp((IntPtr) _thisArray[phSceneIf.sceneForStep], (uint) id);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    double result = (double) SprExport.Spr_PHFemMeshThermoIf_GetSufVertexTemp((IntPtr) _thisArray[phSceneIf.sceneForGet], (uint) id);
	    return result;
				}
			}
		} else {
	    double result = (double) SprExport.Spr_PHFemMeshThermoIf_GetSufVertexTemp((IntPtr) _thisArray[0], (uint) id);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public void SetVertexTemp(uint id, double temp) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemMeshThermoIf_SetVertexTemp((IntPtr) _thisArray[phSceneIf.sceneForStep], (uint) id, (double) temp);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemMeshThermoIf_SetVertexTemp((IntPtr) _thisArray[phSceneIf.sceneForGet], (uint) id, (double) temp);
				}
			}
		} else {
	    SprExport.Spr_PHFemMeshThermoIf_SetVertexTemp((IntPtr) _thisArray[0], (uint) id, (double) temp);
		}
		throw new InvalidOperationException();
	}
	public void SetVerticesTempAll(double temp) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemMeshThermoIf_SetVerticesTempAll((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) temp);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemMeshThermoIf_SetVerticesTempAll((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) temp);
				}
			}
		} else {
	    SprExport.Spr_PHFemMeshThermoIf_SetVerticesTempAll((IntPtr) _thisArray[0], (double) temp);
		}
		throw new InvalidOperationException();
	}
	public void AddvecFAll(uint id, double dqdt) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemMeshThermoIf_AddvecFAll((IntPtr) _thisArray[phSceneIf.sceneForStep], (uint) id, (double) dqdt);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemMeshThermoIf_AddvecFAll((IntPtr) _thisArray[phSceneIf.sceneForGet], (uint) id, (double) dqdt);
				}
			}
		} else {
	    SprExport.Spr_PHFemMeshThermoIf_AddvecFAll((IntPtr) _thisArray[0], (uint) id, (double) dqdt);
		}
		throw new InvalidOperationException();
	}
	public void SetvecFAll(uint id, double dqdt) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemMeshThermoIf_SetvecFAll((IntPtr) _thisArray[phSceneIf.sceneForStep], (uint) id, (double) dqdt);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemMeshThermoIf_SetvecFAll((IntPtr) _thisArray[phSceneIf.sceneForGet], (uint) id, (double) dqdt);
				}
			}
		} else {
	    SprExport.Spr_PHFemMeshThermoIf_SetvecFAll((IntPtr) _thisArray[0], (uint) id, (double) dqdt);
		}
		throw new InvalidOperationException();
	}
	public void SetRhoSpheat(double rho, double Cp) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemMeshThermoIf_SetRhoSpheat((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) rho, (double) Cp);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemMeshThermoIf_SetRhoSpheat((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) rho, (double) Cp);
				}
			}
		} else {
	    SprExport.Spr_PHFemMeshThermoIf_SetRhoSpheat((IntPtr) _thisArray[0], (double) rho, (double) Cp);
		}
		throw new InvalidOperationException();
	}
	public uint GetNFace() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    uint result = (uint) SprExport.Spr_PHFemMeshThermoIf_GetNFace((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    uint result = (uint) SprExport.Spr_PHFemMeshThermoIf_GetNFace((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    uint result = (uint) SprExport.Spr_PHFemMeshThermoIf_GetNFace((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public vectorwrapper_Vec3d GetFaceEdgeVtx(uint id) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHFemMeshThermoIf_GetFaceEdgeVtx((IntPtr) _thisArray[phSceneIf.sceneForStep], (uint) id);
            return new vectorwrapper_Vec3d(ptr);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHFemMeshThermoIf_GetFaceEdgeVtx((IntPtr) _thisArray[phSceneIf.sceneForGet], (uint) id);
            return new vectorwrapper_Vec3d(ptr);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHFemMeshThermoIf_GetFaceEdgeVtx((IntPtr) _thisArray[0], (uint) id);
            return new vectorwrapper_Vec3d(ptr);
		}
		throw new InvalidOperationException();
	}
	public Vec3d GetFaceEdgeVtx(uint id, uint vtx) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHFemMeshThermoIf_GetFaceEdgeVtx_1((IntPtr) _thisArray[phSceneIf.sceneForStep], (uint) id, (uint) vtx);
            return new Vec3d(ptr, true);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHFemMeshThermoIf_GetFaceEdgeVtx_1((IntPtr) _thisArray[phSceneIf.sceneForGet], (uint) id, (uint) vtx);
            return new Vec3d(ptr, true);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHFemMeshThermoIf_GetFaceEdgeVtx_1((IntPtr) _thisArray[0], (uint) id, (uint) vtx);
            return new Vec3d(ptr, true);
		}
		throw new InvalidOperationException();
	}
	public Vec2d GetIHbandDrawVtx() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHFemMeshThermoIf_GetIHbandDrawVtx((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new Vec2d(ptr, true);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHFemMeshThermoIf_GetIHbandDrawVtx((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new Vec2d(ptr, true);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHFemMeshThermoIf_GetIHbandDrawVtx((IntPtr) _thisArray[0]);
            return new Vec2d(ptr, true);
		}
		throw new InvalidOperationException();
	}
	public void CalcIHdqdt_atleast(double r, double R, double dqdtAll, uint num) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemMeshThermoIf_CalcIHdqdt_atleast((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) r, (double) R, (double) dqdtAll, (uint) num);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemMeshThermoIf_CalcIHdqdt_atleast((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) r, (double) R, (double) dqdtAll, (uint) num);
				}
			}
		} else {
	    SprExport.Spr_PHFemMeshThermoIf_CalcIHdqdt_atleast((IntPtr) _thisArray[0], (double) r, (double) R, (double) dqdtAll, (uint) num);
		}
		throw new InvalidOperationException();
	}
	public void UpdateIHheatband(double xS, double xE, uint heatingMODE) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemMeshThermoIf_UpdateIHheatband((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) xS, (double) xE, (uint) heatingMODE);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemMeshThermoIf_UpdateIHheatband((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) xS, (double) xE, (uint) heatingMODE);
				}
			}
		} else {
	    SprExport.Spr_PHFemMeshThermoIf_UpdateIHheatband((IntPtr) _thisArray[0], (double) xS, (double) xE, (uint) heatingMODE);
		}
		throw new InvalidOperationException();
	}
	public void UpdateIHheat(uint heating) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemMeshThermoIf_UpdateIHheat((IntPtr) _thisArray[phSceneIf.sceneForStep], (uint) heating);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemMeshThermoIf_UpdateIHheat((IntPtr) _thisArray[phSceneIf.sceneForGet], (uint) heating);
				}
			}
		} else {
	    SprExport.Spr_PHFemMeshThermoIf_UpdateIHheat((IntPtr) _thisArray[0], (uint) heating);
		}
		throw new InvalidOperationException();
	}
	public void UpdateVecF() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemMeshThermoIf_UpdateVecF((IntPtr) _thisArray[phSceneIf.sceneForStep]);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemMeshThermoIf_UpdateVecF((IntPtr) _thisArray[phSceneIf.sceneForGet]);
				}
			}
		} else {
	    SprExport.Spr_PHFemMeshThermoIf_UpdateVecF((IntPtr) _thisArray[0]);
		}
		throw new InvalidOperationException();
	}
	public void UpdateVecF_frypan() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemMeshThermoIf_UpdateVecF_frypan((IntPtr) _thisArray[phSceneIf.sceneForStep]);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemMeshThermoIf_UpdateVecF_frypan((IntPtr) _thisArray[phSceneIf.sceneForGet]);
				}
			}
		} else {
	    SprExport.Spr_PHFemMeshThermoIf_UpdateVecF_frypan((IntPtr) _thisArray[0]);
		}
		throw new InvalidOperationException();
	}
	public void DecrMoist() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemMeshThermoIf_DecrMoist((IntPtr) _thisArray[phSceneIf.sceneForStep]);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemMeshThermoIf_DecrMoist((IntPtr) _thisArray[phSceneIf.sceneForGet]);
				}
			}
		} else {
	    SprExport.Spr_PHFemMeshThermoIf_DecrMoist((IntPtr) _thisArray[0]);
		}
		throw new InvalidOperationException();
	}
	public void DecrMoist_velo(double vel) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemMeshThermoIf_DecrMoist_velo((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) vel);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemMeshThermoIf_DecrMoist_velo((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) vel);
				}
			}
		} else {
	    SprExport.Spr_PHFemMeshThermoIf_DecrMoist_velo((IntPtr) _thisArray[0], (double) vel);
		}
		throw new InvalidOperationException();
	}
	public void DecrMoist_vel(double dt) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemMeshThermoIf_DecrMoist_vel((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) dt);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemMeshThermoIf_DecrMoist_vel((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) dt);
				}
			}
		} else {
	    SprExport.Spr_PHFemMeshThermoIf_DecrMoist_vel((IntPtr) _thisArray[0], (double) dt);
		}
		throw new InvalidOperationException();
	}
	public void InitAllVertexTemp() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemMeshThermoIf_InitAllVertexTemp((IntPtr) _thisArray[phSceneIf.sceneForStep]);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemMeshThermoIf_InitAllVertexTemp((IntPtr) _thisArray[phSceneIf.sceneForGet]);
				}
			}
		} else {
	    SprExport.Spr_PHFemMeshThermoIf_InitAllVertexTemp((IntPtr) _thisArray[0]);
		}
		throw new InvalidOperationException();
	}
	public void SetInitThermoConductionParam(double thConduct, double rho, double specificHeat, double heatTrans) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemMeshThermoIf_SetInitThermoConductionParam((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) thConduct, (double) rho, (double) specificHeat, (double) heatTrans);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemMeshThermoIf_SetInitThermoConductionParam((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) thConduct, (double) rho, (double) specificHeat, (double) heatTrans);
				}
			}
		} else {
	    SprExport.Spr_PHFemMeshThermoIf_SetInitThermoConductionParam((IntPtr) _thisArray[0], (double) thConduct, (double) rho, (double) specificHeat, (double) heatTrans);
		}
		throw new InvalidOperationException();
	}
	public void SetParamAndReCreateMatrix(double thConduct0, double roh0, double specificHeat0) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemMeshThermoIf_SetParamAndReCreateMatrix((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) thConduct0, (double) roh0, (double) specificHeat0);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemMeshThermoIf_SetParamAndReCreateMatrix((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) thConduct0, (double) roh0, (double) specificHeat0);
				}
			}
		} else {
	    SprExport.Spr_PHFemMeshThermoIf_SetParamAndReCreateMatrix((IntPtr) _thisArray[0], (double) thConduct0, (double) roh0, (double) specificHeat0);
		}
		throw new InvalidOperationException();
	}
	public double GetArbitraryPointTemp(Vec3d temppos) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    double result = (double) SprExport.Spr_PHFemMeshThermoIf_GetArbitraryPointTemp((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) temppos);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    double result = (double) SprExport.Spr_PHFemMeshThermoIf_GetArbitraryPointTemp((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) temppos);
	    return result;
				}
			}
		} else {
	    double result = (double) SprExport.Spr_PHFemMeshThermoIf_GetArbitraryPointTemp((IntPtr) _thisArray[0], (IntPtr) temppos);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public double GetVtxTempInTets(Vec3d temppos) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    double result = (double) SprExport.Spr_PHFemMeshThermoIf_GetVtxTempInTets((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) temppos);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    double result = (double) SprExport.Spr_PHFemMeshThermoIf_GetVtxTempInTets((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) temppos);
	    return result;
				}
			}
		} else {
	    double result = (double) SprExport.Spr_PHFemMeshThermoIf_GetVtxTempInTets((IntPtr) _thisArray[0], (IntPtr) temppos);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public void InitVecFAlls() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemMeshThermoIf_InitVecFAlls((IntPtr) _thisArray[phSceneIf.sceneForStep]);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemMeshThermoIf_InitVecFAlls((IntPtr) _thisArray[phSceneIf.sceneForGet]);
				}
			}
		} else {
	    SprExport.Spr_PHFemMeshThermoIf_InitVecFAlls((IntPtr) _thisArray[0]);
		}
		throw new InvalidOperationException();
	}
	public double Get_thConduct() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    double result = (double) SprExport.Spr_PHFemMeshThermoIf_Get_thConduct((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    double result = (double) SprExport.Spr_PHFemMeshThermoIf_Get_thConduct((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    double result = (double) SprExport.Spr_PHFemMeshThermoIf_Get_thConduct((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public bool SetConcentricHeatMap(vectorwrapper_double r, vectorwrapper_double temp, Vec2d origin) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    char ret = SprExport.Spr_PHFemMeshThermoIf_SetConcentricHeatMap((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) r, (IntPtr) temp, (IntPtr) origin);
	    return (ret == 0) ? false : true;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    char ret = SprExport.Spr_PHFemMeshThermoIf_SetConcentricHeatMap((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) r, (IntPtr) temp, (IntPtr) origin);
	    return (ret == 0) ? false : true;
				}
			}
		} else {
	    char ret = SprExport.Spr_PHFemMeshThermoIf_SetConcentricHeatMap((IntPtr) _thisArray[0], (IntPtr) r, (IntPtr) temp, (IntPtr) origin);
	    return (ret == 0) ? false : true;
		}
		throw new InvalidOperationException();
	}
	public void SetThermalEmissivityToVerticesAll(double thermalEmissivity, double thermalEmissivity_const) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemMeshThermoIf_SetThermalEmissivityToVerticesAll((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) thermalEmissivity, (double) thermalEmissivity_const);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemMeshThermoIf_SetThermalEmissivityToVerticesAll((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) thermalEmissivity, (double) thermalEmissivity_const);
				}
			}
		} else {
	    SprExport.Spr_PHFemMeshThermoIf_SetThermalEmissivityToVerticesAll((IntPtr) _thisArray[0], (double) thermalEmissivity, (double) thermalEmissivity_const);
		}
		throw new InvalidOperationException();
	}
	public void SetOuterTemp(double temp) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemMeshThermoIf_SetOuterTemp((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) temp);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemMeshThermoIf_SetOuterTemp((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) temp);
				}
			}
		} else {
	    SprExport.Spr_PHFemMeshThermoIf_SetOuterTemp((IntPtr) _thisArray[0], (double) temp);
		}
		throw new InvalidOperationException();
	}
	public void SetThermalRadiation(double ems, double ems_const) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemMeshThermoIf_SetThermalRadiation((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) ems, (double) ems_const);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemMeshThermoIf_SetThermalRadiation((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) ems, (double) ems_const);
				}
			}
		} else {
	    SprExport.Spr_PHFemMeshThermoIf_SetThermalRadiation((IntPtr) _thisArray[0], (double) ems, (double) ems_const);
		}
		throw new InvalidOperationException();
	}
	public void SetGaussCalcParam(uint cyc, double epsilon) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemMeshThermoIf_SetGaussCalcParam((IntPtr) _thisArray[phSceneIf.sceneForStep], (uint) cyc, (double) epsilon);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemMeshThermoIf_SetGaussCalcParam((IntPtr) _thisArray[phSceneIf.sceneForGet], (uint) cyc, (double) epsilon);
				}
			}
		} else {
	    SprExport.Spr_PHFemMeshThermoIf_SetGaussCalcParam((IntPtr) _thisArray[0], (uint) cyc, (double) epsilon);
		}
		throw new InvalidOperationException();
	}
	public void InitTcAll(double temp) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemMeshThermoIf_InitTcAll((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) temp);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemMeshThermoIf_InitTcAll((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) temp);
				}
			}
		} else {
	    SprExport.Spr_PHFemMeshThermoIf_InitTcAll((IntPtr) _thisArray[0], (double) temp);
		}
		throw new InvalidOperationException();
	}
	public void InitToutAll(double temp) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemMeshThermoIf_InitToutAll((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) temp);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemMeshThermoIf_InitToutAll((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) temp);
				}
			}
		} else {
	    SprExport.Spr_PHFemMeshThermoIf_InitToutAll((IntPtr) _thisArray[0], (double) temp);
		}
		throw new InvalidOperationException();
	}
	public void SetWeekPow(double weekPow_) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemMeshThermoIf_SetWeekPow((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) weekPow_);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemMeshThermoIf_SetWeekPow((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) weekPow_);
				}
			}
		} else {
	    SprExport.Spr_PHFemMeshThermoIf_SetWeekPow((IntPtr) _thisArray[0], (double) weekPow_);
		}
		throw new InvalidOperationException();
	}
	public void SetIHParamWEEK(double inr_, double outR_, double weekPow_) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemMeshThermoIf_SetIHParamWEEK((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) inr_, (double) outR_, (double) weekPow_);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemMeshThermoIf_SetIHParamWEEK((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) inr_, (double) outR_, (double) weekPow_);
				}
			}
		} else {
	    SprExport.Spr_PHFemMeshThermoIf_SetIHParamWEEK((IntPtr) _thisArray[0], (double) inr_, (double) outR_, (double) weekPow_);
		}
		throw new InvalidOperationException();
	}
	public void SetHeatTransRatioToAllVertex(double heatTransR_) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemMeshThermoIf_SetHeatTransRatioToAllVertex((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) heatTransR_);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemMeshThermoIf_SetHeatTransRatioToAllVertex((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) heatTransR_);
				}
			}
		} else {
	    SprExport.Spr_PHFemMeshThermoIf_SetHeatTransRatioToAllVertex((IntPtr) _thisArray[0], (double) heatTransR_);
		}
		throw new InvalidOperationException();
	}
	public void AfterSetDesc() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemMeshThermoIf_AfterSetDesc((IntPtr) _thisArray[phSceneIf.sceneForStep]);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemMeshThermoIf_AfterSetDesc((IntPtr) _thisArray[phSceneIf.sceneForGet]);
				}
			}
		} else {
	    SprExport.Spr_PHFemMeshThermoIf_AfterSetDesc((IntPtr) _thisArray[0]);
		}
		throw new InvalidOperationException();
	}
	public void SetStopTimespan(double timespan) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemMeshThermoIf_SetStopTimespan((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) timespan);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemMeshThermoIf_SetStopTimespan((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) timespan);
				}
			}
		} else {
	    SprExport.Spr_PHFemMeshThermoIf_SetStopTimespan((IntPtr) _thisArray[0], (double) timespan);
		}
		throw new InvalidOperationException();
	}
	public void UpdateMatk_RadiantHeatToAir() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemMeshThermoIf_UpdateMatk_RadiantHeatToAir((IntPtr) _thisArray[phSceneIf.sceneForStep]);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemMeshThermoIf_UpdateMatk_RadiantHeatToAir((IntPtr) _thisArray[phSceneIf.sceneForGet]);
				}
			}
		} else {
	    SprExport.Spr_PHFemMeshThermoIf_UpdateMatk_RadiantHeatToAir((IntPtr) _thisArray[0]);
		}
		throw new InvalidOperationException();
	}
	public void ActivateVtxbeRadiantHeat() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemMeshThermoIf_ActivateVtxbeRadiantHeat((IntPtr) _thisArray[phSceneIf.sceneForStep]);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemMeshThermoIf_ActivateVtxbeRadiantHeat((IntPtr) _thisArray[phSceneIf.sceneForGet]);
				}
			}
		} else {
	    SprExport.Spr_PHFemMeshThermoIf_ActivateVtxbeRadiantHeat((IntPtr) _thisArray[0]);
		}
		throw new InvalidOperationException();
	}
	public void OutputMatKall() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemMeshThermoIf_OutputMatKall((IntPtr) _thisArray[phSceneIf.sceneForStep]);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemMeshThermoIf_OutputMatKall((IntPtr) _thisArray[phSceneIf.sceneForGet]);
				}
			}
		} else {
	    SprExport.Spr_PHFemMeshThermoIf_OutputMatKall((IntPtr) _thisArray[0]);
		}
		throw new InvalidOperationException();
	}
	public void IfRadiantHeatTrans() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemMeshThermoIf_IfRadiantHeatTrans((IntPtr) _thisArray[phSceneIf.sceneForStep]);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemMeshThermoIf_IfRadiantHeatTrans((IntPtr) _thisArray[phSceneIf.sceneForGet]);
				}
			}
		} else {
	    SprExport.Spr_PHFemMeshThermoIf_IfRadiantHeatTrans((IntPtr) _thisArray[0]);
		}
		throw new InvalidOperationException();
	}
    }
    public partial class PHFemMeshNewIf : SceneObjectIf {
	public PHFemMeshNewIf() { _thisArray[0] = SprExport.Spr_new_PHFemMeshNewIf(); _flag = true; }
	public PHFemMeshNewIf(IntPtr ptr) : base(ptr) {}
	public PHFemMeshNewIf(IntPtr ptr, bool flag) : base(ptr, flag) {}
	public static implicit operator PHFemMeshNewIf(CsCastObject target) {
		return (target._info.Inherit(PHFemMeshNewIf.GetIfInfoStatic()) ? new PHFemMeshNewIf(target._thisArray[0], target._flag) : null);
	}
	~PHFemMeshNewIf() { if (_flag) { SprExport.Spr_delete_PHFemMeshNewIf(_thisArray[0]); _flag = false; } }
        public override string ToString() {
            IntPtr ptr = SprExport.Spr_PHFemMeshNewIf_ToString((IntPtr) _thisArray[0]);
            string bstr = Marshal.PtrToStringBSTR(ptr);
            SprExport.Spr_PHFemMeshNewIf_FreeString((IntPtr) ptr);
            return bstr;
        }
	public IfInfo GetIfInfo() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHFemMeshNewIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new IfInfo(ptr);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHFemMeshNewIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new IfInfo(ptr);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHFemMeshNewIf_GetIfInfo((IntPtr) _thisArray[0]);
            return new IfInfo(ptr);
		}
		throw new InvalidOperationException();
	}
	public static IfInfo GetIfInfoStatic() {
	    IntPtr ptr = SprExport.Spr_PHFemMeshNewIf_GetIfInfoStatic();
            return new IfInfo(ptr);
	}
	public void SetPHSolid(PHSolidIf s) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemMeshNewIf_SetPHSolid((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) s);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemMeshNewIf_SetPHSolid((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) s);
				}
			}
		} else {
	    SprExport.Spr_PHFemMeshNewIf_SetPHSolid((IntPtr) _thisArray[0], (IntPtr) s);
		}
		throw new InvalidOperationException();
	}
	public PHSolidIf GetPHSolid() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHFemMeshNewIf_GetPHSolid((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            if (ptr == IntPtr.Zero) { return null; } 
            PHSolidIf obj = new PHSolidIf(ptr);
            if (obj.GetIfInfo() == PHHapticPointerIf.GetIfInfoStatic()) { return new PHHapticPointerIf(ptr); }
            return obj;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHFemMeshNewIf_GetPHSolid((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            if (ptr == IntPtr.Zero) { return null; } 
            PHSolidIf obj = new PHSolidIf(ptr);
            if (obj.GetIfInfo() == PHHapticPointerIf.GetIfInfoStatic()) { return new PHHapticPointerIf(ptr); }
            return obj;
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHFemMeshNewIf_GetPHSolid((IntPtr) _thisArray[0]);
            if (ptr == IntPtr.Zero) { return null; } 
            PHSolidIf obj = new PHSolidIf(ptr);
            if (obj.GetIfInfo() == PHHapticPointerIf.GetIfInfoStatic()) { return new PHHapticPointerIf(ptr); }
            return obj;
		}
		throw new InvalidOperationException();
	}
	public PHFemVibrationIf GetPHFemVibration() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHFemMeshNewIf_GetPHFemVibration((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            if (ptr == IntPtr.Zero) { return null; } 
            PHFemVibrationIf obj = new PHFemVibrationIf(ptr);
            return obj;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHFemMeshNewIf_GetPHFemVibration((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            if (ptr == IntPtr.Zero) { return null; } 
            PHFemVibrationIf obj = new PHFemVibrationIf(ptr);
            return obj;
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHFemMeshNewIf_GetPHFemVibration((IntPtr) _thisArray[0]);
            if (ptr == IntPtr.Zero) { return null; } 
            PHFemVibrationIf obj = new PHFemVibrationIf(ptr);
            return obj;
		}
		throw new InvalidOperationException();
	}
	public PHFemThermoIf GetPHFemThermo() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHFemMeshNewIf_GetPHFemThermo((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            if (ptr == IntPtr.Zero) { return null; } 
            PHFemThermoIf obj = new PHFemThermoIf(ptr);
            return obj;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHFemMeshNewIf_GetPHFemThermo((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            if (ptr == IntPtr.Zero) { return null; } 
            PHFemThermoIf obj = new PHFemThermoIf(ptr);
            return obj;
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHFemMeshNewIf_GetPHFemThermo((IntPtr) _thisArray[0]);
            if (ptr == IntPtr.Zero) { return null; } 
            PHFemThermoIf obj = new PHFemThermoIf(ptr);
            return obj;
		}
		throw new InvalidOperationException();
	}
	public PHFemPorousWOMoveIf GetPHFemPorousWOMove() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHFemMeshNewIf_GetPHFemPorousWOMove((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            if (ptr == IntPtr.Zero) { return null; } 
            PHFemPorousWOMoveIf obj = new PHFemPorousWOMoveIf(ptr);
            return obj;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHFemMeshNewIf_GetPHFemPorousWOMove((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            if (ptr == IntPtr.Zero) { return null; } 
            PHFemPorousWOMoveIf obj = new PHFemPorousWOMoveIf(ptr);
            return obj;
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHFemMeshNewIf_GetPHFemPorousWOMove((IntPtr) _thisArray[0]);
            if (ptr == IntPtr.Zero) { return null; } 
            PHFemPorousWOMoveIf obj = new PHFemPorousWOMoveIf(ptr);
            return obj;
		}
		throw new InvalidOperationException();
	}
	public int NVertices() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    int result = (int) SprExport.Spr_PHFemMeshNewIf_NVertices((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    int result = (int) SprExport.Spr_PHFemMeshNewIf_NVertices((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    int result = (int) SprExport.Spr_PHFemMeshNewIf_NVertices((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public int NFaces() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    int result = (int) SprExport.Spr_PHFemMeshNewIf_NFaces((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    int result = (int) SprExport.Spr_PHFemMeshNewIf_NFaces((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    int result = (int) SprExport.Spr_PHFemMeshNewIf_NFaces((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public int NTets() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    int result = (int) SprExport.Spr_PHFemMeshNewIf_NTets((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    int result = (int) SprExport.Spr_PHFemMeshNewIf_NTets((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    int result = (int) SprExport.Spr_PHFemMeshNewIf_NTets((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public void SetVertexUpdateFlags(bool flg) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemMeshNewIf_SetVertexUpdateFlags((IntPtr) _thisArray[phSceneIf.sceneForStep], (bool) flg);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemMeshNewIf_SetVertexUpdateFlags((IntPtr) _thisArray[phSceneIf.sceneForGet], (bool) flg);
				}
			}
		} else {
	    SprExport.Spr_PHFemMeshNewIf_SetVertexUpdateFlags((IntPtr) _thisArray[0], (bool) flg);
		}
		throw new InvalidOperationException();
	}
	public void SetVertexUpateFlag(int vid, bool flg) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemMeshNewIf_SetVertexUpateFlag((IntPtr) _thisArray[phSceneIf.sceneForStep], (int) vid, (bool) flg);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemMeshNewIf_SetVertexUpateFlag((IntPtr) _thisArray[phSceneIf.sceneForGet], (int) vid, (bool) flg);
				}
			}
		} else {
	    SprExport.Spr_PHFemMeshNewIf_SetVertexUpateFlag((IntPtr) _thisArray[0], (int) vid, (bool) flg);
		}
		throw new InvalidOperationException();
	}
	public double CompTetVolume(int tetID, bool bDeform) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    double result = (double) SprExport.Spr_PHFemMeshNewIf_CompTetVolume((IntPtr) _thisArray[phSceneIf.sceneForStep], (int) tetID, (bool) bDeform);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    double result = (double) SprExport.Spr_PHFemMeshNewIf_CompTetVolume((IntPtr) _thisArray[phSceneIf.sceneForGet], (int) tetID, (bool) bDeform);
	    return result;
				}
			}
		} else {
	    double result = (double) SprExport.Spr_PHFemMeshNewIf_CompTetVolume((IntPtr) _thisArray[0], (int) tetID, (bool) bDeform);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public bool AddVertexDisplacementW(int vtxId, Vec3d disW) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    char ret = SprExport.Spr_PHFemMeshNewIf_AddVertexDisplacementW((IntPtr) _thisArray[phSceneIf.sceneForStep], (int) vtxId, (IntPtr) disW);
	    return (ret == 0) ? false : true;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    char ret = SprExport.Spr_PHFemMeshNewIf_AddVertexDisplacementW((IntPtr) _thisArray[phSceneIf.sceneForGet], (int) vtxId, (IntPtr) disW);
	    return (ret == 0) ? false : true;
				}
			}
		} else {
	    char ret = SprExport.Spr_PHFemMeshNewIf_AddVertexDisplacementW((IntPtr) _thisArray[0], (int) vtxId, (IntPtr) disW);
	    return (ret == 0) ? false : true;
		}
		throw new InvalidOperationException();
	}
	public bool AddVertexDisplacementL(int vtxId, Vec3d disL) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    char ret = SprExport.Spr_PHFemMeshNewIf_AddVertexDisplacementL((IntPtr) _thisArray[phSceneIf.sceneForStep], (int) vtxId, (IntPtr) disL);
	    return (ret == 0) ? false : true;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    char ret = SprExport.Spr_PHFemMeshNewIf_AddVertexDisplacementL((IntPtr) _thisArray[phSceneIf.sceneForGet], (int) vtxId, (IntPtr) disL);
	    return (ret == 0) ? false : true;
				}
			}
		} else {
	    char ret = SprExport.Spr_PHFemMeshNewIf_AddVertexDisplacementL((IntPtr) _thisArray[0], (int) vtxId, (IntPtr) disL);
	    return (ret == 0) ? false : true;
		}
		throw new InvalidOperationException();
	}
	public bool SetVertexPositionW(int vtxId, Vec3d posW) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    char ret = SprExport.Spr_PHFemMeshNewIf_SetVertexPositionW((IntPtr) _thisArray[phSceneIf.sceneForStep], (int) vtxId, (IntPtr) posW);
	    return (ret == 0) ? false : true;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    char ret = SprExport.Spr_PHFemMeshNewIf_SetVertexPositionW((IntPtr) _thisArray[phSceneIf.sceneForGet], (int) vtxId, (IntPtr) posW);
	    return (ret == 0) ? false : true;
				}
			}
		} else {
	    char ret = SprExport.Spr_PHFemMeshNewIf_SetVertexPositionW((IntPtr) _thisArray[0], (int) vtxId, (IntPtr) posW);
	    return (ret == 0) ? false : true;
		}
		throw new InvalidOperationException();
	}
	public bool SetVertexPositionL(int vtxId, Vec3d posL) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    char ret = SprExport.Spr_PHFemMeshNewIf_SetVertexPositionL((IntPtr) _thisArray[phSceneIf.sceneForStep], (int) vtxId, (IntPtr) posL);
	    return (ret == 0) ? false : true;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    char ret = SprExport.Spr_PHFemMeshNewIf_SetVertexPositionL((IntPtr) _thisArray[phSceneIf.sceneForGet], (int) vtxId, (IntPtr) posL);
	    return (ret == 0) ? false : true;
				}
			}
		} else {
	    char ret = SprExport.Spr_PHFemMeshNewIf_SetVertexPositionL((IntPtr) _thisArray[0], (int) vtxId, (IntPtr) posL);
	    return (ret == 0) ? false : true;
		}
		throw new InvalidOperationException();
	}
	public bool SetVertexVelocityL(int vtxId, Vec3d posL) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    char ret = SprExport.Spr_PHFemMeshNewIf_SetVertexVelocityL((IntPtr) _thisArray[phSceneIf.sceneForStep], (int) vtxId, (IntPtr) posL);
	    return (ret == 0) ? false : true;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    char ret = SprExport.Spr_PHFemMeshNewIf_SetVertexVelocityL((IntPtr) _thisArray[phSceneIf.sceneForGet], (int) vtxId, (IntPtr) posL);
	    return (ret == 0) ? false : true;
				}
			}
		} else {
	    char ret = SprExport.Spr_PHFemMeshNewIf_SetVertexVelocityL((IntPtr) _thisArray[0], (int) vtxId, (IntPtr) posL);
	    return (ret == 0) ? false : true;
		}
		throw new InvalidOperationException();
	}
	public Vec3d GetVertexVelocityL(int vtxId) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHFemMeshNewIf_GetVertexVelocityL((IntPtr) _thisArray[phSceneIf.sceneForStep], (int) vtxId);
            return new Vec3d(ptr, true);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHFemMeshNewIf_GetVertexVelocityL((IntPtr) _thisArray[phSceneIf.sceneForGet], (int) vtxId);
            return new Vec3d(ptr, true);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHFemMeshNewIf_GetVertexVelocityL((IntPtr) _thisArray[0], (int) vtxId);
            return new Vec3d(ptr, true);
		}
		throw new InvalidOperationException();
	}
	public Vec3d GetVertexPositionL(int vtxId) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHFemMeshNewIf_GetVertexPositionL((IntPtr) _thisArray[phSceneIf.sceneForStep], (int) vtxId);
            return new Vec3d(ptr, true);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHFemMeshNewIf_GetVertexPositionL((IntPtr) _thisArray[phSceneIf.sceneForGet], (int) vtxId);
            return new Vec3d(ptr, true);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHFemMeshNewIf_GetVertexPositionL((IntPtr) _thisArray[0], (int) vtxId);
            return new Vec3d(ptr, true);
		}
		throw new InvalidOperationException();
	}
	public Vec3d GetVertexDisplacementL(int vtxId) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHFemMeshNewIf_GetVertexDisplacementL((IntPtr) _thisArray[phSceneIf.sceneForStep], (int) vtxId);
            return new Vec3d(ptr, true);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHFemMeshNewIf_GetVertexDisplacementL((IntPtr) _thisArray[phSceneIf.sceneForGet], (int) vtxId);
            return new Vec3d(ptr, true);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHFemMeshNewIf_GetVertexDisplacementL((IntPtr) _thisArray[0], (int) vtxId);
            return new Vec3d(ptr, true);
		}
		throw new InvalidOperationException();
	}
	public Vec3d GetVertexInitalPositionL(int vtxId) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHFemMeshNewIf_GetVertexInitalPositionL((IntPtr) _thisArray[phSceneIf.sceneForStep], (int) vtxId);
            return new Vec3d(ptr, true);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHFemMeshNewIf_GetVertexInitalPositionL((IntPtr) _thisArray[phSceneIf.sceneForGet], (int) vtxId);
            return new Vec3d(ptr, true);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHFemMeshNewIf_GetVertexInitalPositionL((IntPtr) _thisArray[0], (int) vtxId);
            return new Vec3d(ptr, true);
		}
		throw new InvalidOperationException();
	}
	public void SetVelocity(Vec3d v) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemMeshNewIf_SetVelocity((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) v);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemMeshNewIf_SetVelocity((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) v);
				}
			}
		} else {
	    SprExport.Spr_PHFemMeshNewIf_SetVelocity((IntPtr) _thisArray[0], (IntPtr) v);
		}
		throw new InvalidOperationException();
	}
	public int GetTetVertexIds(int t) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    int result = (int) SprExport.Spr_PHFemMeshNewIf_GetTetVertexIds((IntPtr) _thisArray[phSceneIf.sceneForStep], (int) t);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    int result = (int) SprExport.Spr_PHFemMeshNewIf_GetTetVertexIds((IntPtr) _thisArray[phSceneIf.sceneForGet], (int) t);
	    return result;
				}
			}
		} else {
	    int result = (int) SprExport.Spr_PHFemMeshNewIf_GetTetVertexIds((IntPtr) _thisArray[0], (int) t);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public int GetFaceVertexIds(int f) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    int result = (int) SprExport.Spr_PHFemMeshNewIf_GetFaceVertexIds((IntPtr) _thisArray[phSceneIf.sceneForStep], (int) f);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    int result = (int) SprExport.Spr_PHFemMeshNewIf_GetFaceVertexIds((IntPtr) _thisArray[phSceneIf.sceneForGet], (int) f);
	    return result;
				}
			}
		} else {
	    int result = (int) SprExport.Spr_PHFemMeshNewIf_GetFaceVertexIds((IntPtr) _thisArray[0], (int) f);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public Vec3d GetFaceNormal(int f) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHFemMeshNewIf_GetFaceNormal((IntPtr) _thisArray[phSceneIf.sceneForStep], (int) f);
            return new Vec3d(ptr, true);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHFemMeshNewIf_GetFaceNormal((IntPtr) _thisArray[phSceneIf.sceneForGet], (int) f);
            return new Vec3d(ptr, true);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHFemMeshNewIf_GetFaceNormal((IntPtr) _thisArray[0], (int) f);
            return new Vec3d(ptr, true);
		}
		throw new InvalidOperationException();
	}
	public int GetSurfaceVertex(int i) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    int result = (int) SprExport.Spr_PHFemMeshNewIf_GetSurfaceVertex((IntPtr) _thisArray[phSceneIf.sceneForStep], (int) i);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    int result = (int) SprExport.Spr_PHFemMeshNewIf_GetSurfaceVertex((IntPtr) _thisArray[phSceneIf.sceneForGet], (int) i);
	    return result;
				}
			}
		} else {
	    int result = (int) SprExport.Spr_PHFemMeshNewIf_GetSurfaceVertex((IntPtr) _thisArray[0], (int) i);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public int NSurfaceVertices() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    int result = (int) SprExport.Spr_PHFemMeshNewIf_NSurfaceVertices((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    int result = (int) SprExport.Spr_PHFemMeshNewIf_NSurfaceVertices((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    int result = (int) SprExport.Spr_PHFemMeshNewIf_NSurfaceVertices((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public int NSurfaceFace() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    int result = (int) SprExport.Spr_PHFemMeshNewIf_NSurfaceFace((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    int result = (int) SprExport.Spr_PHFemMeshNewIf_NSurfaceFace((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    int result = (int) SprExport.Spr_PHFemMeshNewIf_NSurfaceFace((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public bool CompTetShapeFunctionValue(int tetId, Vec3d posL, Vec4d value, bool bDeform) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    char ret = SprExport.Spr_PHFemMeshNewIf_CompTetShapeFunctionValue((IntPtr) _thisArray[phSceneIf.sceneForStep], (int) tetId, (IntPtr) posL, (IntPtr) value, (bool) bDeform);
	    return (ret == 0) ? false : true;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    char ret = SprExport.Spr_PHFemMeshNewIf_CompTetShapeFunctionValue((IntPtr) _thisArray[phSceneIf.sceneForGet], (int) tetId, (IntPtr) posL, (IntPtr) value, (bool) bDeform);
	    return (ret == 0) ? false : true;
				}
			}
		} else {
	    char ret = SprExport.Spr_PHFemMeshNewIf_CompTetShapeFunctionValue((IntPtr) _thisArray[0], (int) tetId, (IntPtr) posL, (IntPtr) value, (bool) bDeform);
	    return (ret == 0) ? false : true;
		}
		throw new InvalidOperationException();
	}
	public int FindTetFromFace(int faceId) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    int result = (int) SprExport.Spr_PHFemMeshNewIf_FindTetFromFace((IntPtr) _thisArray[phSceneIf.sceneForStep], (int) faceId);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    int result = (int) SprExport.Spr_PHFemMeshNewIf_FindTetFromFace((IntPtr) _thisArray[phSceneIf.sceneForGet], (int) faceId);
	    return result;
				}
			}
		} else {
	    int result = (int) SprExport.Spr_PHFemMeshNewIf_FindTetFromFace((IntPtr) _thisArray[0], (int) faceId);
	    return result;
		}
		throw new InvalidOperationException();
	}
    }
    public partial class PHFemBaseIf : SceneObjectIf {
	public PHFemBaseIf() { _thisArray[0] = SprExport.Spr_new_PHFemBaseIf(); _flag = true; }
	public PHFemBaseIf(IntPtr ptr) : base(ptr) {}
	public PHFemBaseIf(IntPtr ptr, bool flag) : base(ptr, flag) {}
	public static implicit operator PHFemBaseIf(CsCastObject target) {
		return (target._info.Inherit(PHFemBaseIf.GetIfInfoStatic()) ? new PHFemBaseIf(target._thisArray[0], target._flag) : null);
	}
	~PHFemBaseIf() { if (_flag) { SprExport.Spr_delete_PHFemBaseIf(_thisArray[0]); _flag = false; } }
        public override string ToString() {
            IntPtr ptr = SprExport.Spr_PHFemBaseIf_ToString((IntPtr) _thisArray[0]);
            string bstr = Marshal.PtrToStringBSTR(ptr);
            SprExport.Spr_PHFemBaseIf_FreeString((IntPtr) ptr);
            return bstr;
        }
	public IfInfo GetIfInfo() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHFemBaseIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new IfInfo(ptr);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHFemBaseIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new IfInfo(ptr);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHFemBaseIf_GetIfInfo((IntPtr) _thisArray[0]);
            return new IfInfo(ptr);
		}
		throw new InvalidOperationException();
	}
	public static IfInfo GetIfInfoStatic() {
	    IntPtr ptr = SprExport.Spr_PHFemBaseIf_GetIfInfoStatic();
            return new IfInfo(ptr);
	}
	public PHFemMeshNewIf GetPHFemMesh() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHFemBaseIf_GetPHFemMesh((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            if (ptr == IntPtr.Zero) { return null; } 
            PHFemMeshNewIf obj = new PHFemMeshNewIf(ptr);
            return obj;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHFemBaseIf_GetPHFemMesh((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            if (ptr == IntPtr.Zero) { return null; } 
            PHFemMeshNewIf obj = new PHFemMeshNewIf(ptr);
            return obj;
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHFemBaseIf_GetPHFemMesh((IntPtr) _thisArray[0]);
            if (ptr == IntPtr.Zero) { return null; } 
            PHFemMeshNewIf obj = new PHFemMeshNewIf(ptr);
            return obj;
		}
		throw new InvalidOperationException();
	}
    }
    public partial class PHFemVibrationIf : PHFemBaseIf {
	public PHFemVibrationIf() { _thisArray[0] = SprExport.Spr_new_PHFemVibrationIf(); _flag = true; }
	public PHFemVibrationIf(IntPtr ptr) : base(ptr) {}
	public PHFemVibrationIf(IntPtr ptr, bool flag) : base(ptr, flag) {}
	public static implicit operator PHFemVibrationIf(CsCastObject target) {
		return (target._info.Inherit(PHFemVibrationIf.GetIfInfoStatic()) ? new PHFemVibrationIf(target._thisArray[0], target._flag) : null);
	}
	~PHFemVibrationIf() { if (_flag) { SprExport.Spr_delete_PHFemVibrationIf(_thisArray[0]); _flag = false; } }
        public override string ToString() {
            IntPtr ptr = SprExport.Spr_PHFemVibrationIf_ToString((IntPtr) _thisArray[0]);
            string bstr = Marshal.PtrToStringBSTR(ptr);
            SprExport.Spr_PHFemVibrationIf_FreeString((IntPtr) ptr);
            return bstr;
        }
	public IfInfo GetIfInfo() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHFemVibrationIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new IfInfo(ptr);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHFemVibrationIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new IfInfo(ptr);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHFemVibrationIf_GetIfInfo((IntPtr) _thisArray[0]);
            return new IfInfo(ptr);
		}
		throw new InvalidOperationException();
	}
	public static IfInfo GetIfInfoStatic() {
	    IntPtr ptr = SprExport.Spr_PHFemVibrationIf_GetIfInfoStatic();
            return new IfInfo(ptr);
	}
	public void SetTimeStep(double dt) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemVibrationIf_SetTimeStep((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) dt);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemVibrationIf_SetTimeStep((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) dt);
				}
			}
		} else {
	    SprExport.Spr_PHFemVibrationIf_SetTimeStep((IntPtr) _thisArray[0], (double) dt);
		}
		throw new InvalidOperationException();
	}
	public double GetTimeStep() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    double result = (double) SprExport.Spr_PHFemVibrationIf_GetTimeStep((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    double result = (double) SprExport.Spr_PHFemVibrationIf_GetTimeStep((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    double result = (double) SprExport.Spr_PHFemVibrationIf_GetTimeStep((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public void SetYoungModulus(double value) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemVibrationIf_SetYoungModulus((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) value);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemVibrationIf_SetYoungModulus((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) value);
				}
			}
		} else {
	    SprExport.Spr_PHFemVibrationIf_SetYoungModulus((IntPtr) _thisArray[0], (double) value);
		}
		throw new InvalidOperationException();
	}
	public double GetYoungModulus() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    double result = (double) SprExport.Spr_PHFemVibrationIf_GetYoungModulus((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    double result = (double) SprExport.Spr_PHFemVibrationIf_GetYoungModulus((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    double result = (double) SprExport.Spr_PHFemVibrationIf_GetYoungModulus((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public void SetPoissonsRatio(double value) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemVibrationIf_SetPoissonsRatio((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) value);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemVibrationIf_SetPoissonsRatio((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) value);
				}
			}
		} else {
	    SprExport.Spr_PHFemVibrationIf_SetPoissonsRatio((IntPtr) _thisArray[0], (double) value);
		}
		throw new InvalidOperationException();
	}
	public double GetPoissonsRatio() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    double result = (double) SprExport.Spr_PHFemVibrationIf_GetPoissonsRatio((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    double result = (double) SprExport.Spr_PHFemVibrationIf_GetPoissonsRatio((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    double result = (double) SprExport.Spr_PHFemVibrationIf_GetPoissonsRatio((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public void SetDensity(double value) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemVibrationIf_SetDensity((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) value);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemVibrationIf_SetDensity((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) value);
				}
			}
		} else {
	    SprExport.Spr_PHFemVibrationIf_SetDensity((IntPtr) _thisArray[0], (double) value);
		}
		throw new InvalidOperationException();
	}
	public double GetDensity() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    double result = (double) SprExport.Spr_PHFemVibrationIf_GetDensity((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    double result = (double) SprExport.Spr_PHFemVibrationIf_GetDensity((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    double result = (double) SprExport.Spr_PHFemVibrationIf_GetDensity((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public void SetAlpha(double value) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemVibrationIf_SetAlpha((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) value);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemVibrationIf_SetAlpha((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) value);
				}
			}
		} else {
	    SprExport.Spr_PHFemVibrationIf_SetAlpha((IntPtr) _thisArray[0], (double) value);
		}
		throw new InvalidOperationException();
	}
	public double GetAlpha() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    double result = (double) SprExport.Spr_PHFemVibrationIf_GetAlpha((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    double result = (double) SprExport.Spr_PHFemVibrationIf_GetAlpha((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    double result = (double) SprExport.Spr_PHFemVibrationIf_GetAlpha((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public void SetBeta(double value) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemVibrationIf_SetBeta((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) value);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemVibrationIf_SetBeta((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) value);
				}
			}
		} else {
	    SprExport.Spr_PHFemVibrationIf_SetBeta((IntPtr) _thisArray[0], (double) value);
		}
		throw new InvalidOperationException();
	}
	public double GetBeta() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    double result = (double) SprExport.Spr_PHFemVibrationIf_GetBeta((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    double result = (double) SprExport.Spr_PHFemVibrationIf_GetBeta((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    double result = (double) SprExport.Spr_PHFemVibrationIf_GetBeta((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public void SetBoundary(int vtxIds) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemVibrationIf_SetBoundary((IntPtr) _thisArray[phSceneIf.sceneForStep], (int) vtxIds);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemVibrationIf_SetBoundary((IntPtr) _thisArray[phSceneIf.sceneForGet], (int) vtxIds);
				}
			}
		} else {
	    SprExport.Spr_PHFemVibrationIf_SetBoundary((IntPtr) _thisArray[0], (int) vtxIds);
		}
		throw new InvalidOperationException();
	}
	public void ClearBoundary() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemVibrationIf_ClearBoundary((IntPtr) _thisArray[phSceneIf.sceneForStep]);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemVibrationIf_ClearBoundary((IntPtr) _thisArray[phSceneIf.sceneForGet]);
				}
			}
		} else {
	    SprExport.Spr_PHFemVibrationIf_ClearBoundary((IntPtr) _thisArray[0]);
		}
		throw new InvalidOperationException();
	}
	public vectorwrapper_int GetBoundary() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHFemVibrationIf_GetBoundary((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new vectorwrapper_int(ptr);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHFemVibrationIf_GetBoundary((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new vectorwrapper_int(ptr);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHFemVibrationIf_GetBoundary((IntPtr) _thisArray[0]);
            return new vectorwrapper_int(ptr);
		}
		throw new InvalidOperationException();
	}
	public void SetAnalysisMode(PHFemVibrationDesc.ANALYSIS_MODE mode) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemVibrationIf_SetAnalysisMode((IntPtr) _thisArray[phSceneIf.sceneForStep], (int) mode);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemVibrationIf_SetAnalysisMode((IntPtr) _thisArray[phSceneIf.sceneForGet], (int) mode);
				}
			}
		} else {
	    SprExport.Spr_PHFemVibrationIf_SetAnalysisMode((IntPtr) _thisArray[0], (int) mode);
		}
		throw new InvalidOperationException();
	}
	public void SetIntegrationMode(PHFemVibrationDesc.INTEGRATION_MODE mode) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemVibrationIf_SetIntegrationMode((IntPtr) _thisArray[phSceneIf.sceneForStep], (int) mode);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemVibrationIf_SetIntegrationMode((IntPtr) _thisArray[phSceneIf.sceneForGet], (int) mode);
				}
			}
		} else {
	    SprExport.Spr_PHFemVibrationIf_SetIntegrationMode((IntPtr) _thisArray[0], (int) mode);
		}
		throw new InvalidOperationException();
	}
	public bool AddBoundaryCondition(int vtxId, Vec3i dof) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    char ret = SprExport.Spr_PHFemVibrationIf_AddBoundaryCondition((IntPtr) _thisArray[phSceneIf.sceneForStep], (int) vtxId, (IntPtr) dof);
	    return (ret == 0) ? false : true;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    char ret = SprExport.Spr_PHFemVibrationIf_AddBoundaryCondition((IntPtr) _thisArray[phSceneIf.sceneForGet], (int) vtxId, (IntPtr) dof);
	    return (ret == 0) ? false : true;
				}
			}
		} else {
	    char ret = SprExport.Spr_PHFemVibrationIf_AddBoundaryCondition((IntPtr) _thisArray[0], (int) vtxId, (IntPtr) dof);
	    return (ret == 0) ? false : true;
		}
		throw new InvalidOperationException();
	}
	public void DeleteBoundaryCondition() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemVibrationIf_DeleteBoundaryCondition((IntPtr) _thisArray[phSceneIf.sceneForStep]);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemVibrationIf_DeleteBoundaryCondition((IntPtr) _thisArray[phSceneIf.sceneForGet]);
				}
			}
		} else {
	    SprExport.Spr_PHFemVibrationIf_DeleteBoundaryCondition((IntPtr) _thisArray[0]);
		}
		throw new InvalidOperationException();
	}
	public bool FindNeighborTetrahedron(Vec3d posW, int tetId, Vec3d cpW, bool bDeform) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    char ret = SprExport.Spr_PHFemVibrationIf_FindNeighborTetrahedron((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) posW, (int) tetId, (IntPtr) cpW, (bool) bDeform);
	    return (ret == 0) ? false : true;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    char ret = SprExport.Spr_PHFemVibrationIf_FindNeighborTetrahedron((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) posW, (int) tetId, (IntPtr) cpW, (bool) bDeform);
	    return (ret == 0) ? false : true;
				}
			}
		} else {
	    char ret = SprExport.Spr_PHFemVibrationIf_FindNeighborTetrahedron((IntPtr) _thisArray[0], (IntPtr) posW, (int) tetId, (IntPtr) cpW, (bool) bDeform);
	    return (ret == 0) ? false : true;
		}
		throw new InvalidOperationException();
	}
	public bool SetDamping(int tetId, Vec3d posW, double damp_ratio) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    char ret = SprExport.Spr_PHFemVibrationIf_SetDamping((IntPtr) _thisArray[phSceneIf.sceneForStep], (int) tetId, (IntPtr) posW, (double) damp_ratio);
	    return (ret == 0) ? false : true;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    char ret = SprExport.Spr_PHFemVibrationIf_SetDamping((IntPtr) _thisArray[phSceneIf.sceneForGet], (int) tetId, (IntPtr) posW, (double) damp_ratio);
	    return (ret == 0) ? false : true;
				}
			}
		} else {
	    char ret = SprExport.Spr_PHFemVibrationIf_SetDamping((IntPtr) _thisArray[0], (int) tetId, (IntPtr) posW, (double) damp_ratio);
	    return (ret == 0) ? false : true;
		}
		throw new InvalidOperationException();
	}
	public bool AddForce(int tetId, Vec3d posW, Vec3d fW) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    char ret = SprExport.Spr_PHFemVibrationIf_AddForce((IntPtr) _thisArray[phSceneIf.sceneForStep], (int) tetId, (IntPtr) posW, (IntPtr) fW);
	    return (ret == 0) ? false : true;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    char ret = SprExport.Spr_PHFemVibrationIf_AddForce((IntPtr) _thisArray[phSceneIf.sceneForGet], (int) tetId, (IntPtr) posW, (IntPtr) fW);
	    return (ret == 0) ? false : true;
				}
			}
		} else {
	    char ret = SprExport.Spr_PHFemVibrationIf_AddForce((IntPtr) _thisArray[0], (int) tetId, (IntPtr) posW, (IntPtr) fW);
	    return (ret == 0) ? false : true;
		}
		throw new InvalidOperationException();
	}
	public bool GetDisplacement(int tetId, Vec3d posW, Vec3d disp, bool bDeform) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    char ret = SprExport.Spr_PHFemVibrationIf_GetDisplacement((IntPtr) _thisArray[phSceneIf.sceneForStep], (int) tetId, (IntPtr) posW, (IntPtr) disp, (bool) bDeform);
	    return (ret == 0) ? false : true;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    char ret = SprExport.Spr_PHFemVibrationIf_GetDisplacement((IntPtr) _thisArray[phSceneIf.sceneForGet], (int) tetId, (IntPtr) posW, (IntPtr) disp, (bool) bDeform);
	    return (ret == 0) ? false : true;
				}
			}
		} else {
	    char ret = SprExport.Spr_PHFemVibrationIf_GetDisplacement((IntPtr) _thisArray[0], (int) tetId, (IntPtr) posW, (IntPtr) disp, (bool) bDeform);
	    return (ret == 0) ? false : true;
		}
		throw new InvalidOperationException();
	}
	public bool GetVelocity(int tetId, Vec3d posW, Vec3d vel, bool bDeform) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    char ret = SprExport.Spr_PHFemVibrationIf_GetVelocity((IntPtr) _thisArray[phSceneIf.sceneForStep], (int) tetId, (IntPtr) posW, (IntPtr) vel, (bool) bDeform);
	    return (ret == 0) ? false : true;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    char ret = SprExport.Spr_PHFemVibrationIf_GetVelocity((IntPtr) _thisArray[phSceneIf.sceneForGet], (int) tetId, (IntPtr) posW, (IntPtr) vel, (bool) bDeform);
	    return (ret == 0) ? false : true;
				}
			}
		} else {
	    char ret = SprExport.Spr_PHFemVibrationIf_GetVelocity((IntPtr) _thisArray[0], (int) tetId, (IntPtr) posW, (IntPtr) vel, (bool) bDeform);
	    return (ret == 0) ? false : true;
		}
		throw new InvalidOperationException();
	}
	public bool GetPosition(int tetId, Vec3d posW, Vec3d pos, bool bDeform) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    char ret = SprExport.Spr_PHFemVibrationIf_GetPosition((IntPtr) _thisArray[phSceneIf.sceneForStep], (int) tetId, (IntPtr) posW, (IntPtr) pos, (bool) bDeform);
	    return (ret == 0) ? false : true;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    char ret = SprExport.Spr_PHFemVibrationIf_GetPosition((IntPtr) _thisArray[phSceneIf.sceneForGet], (int) tetId, (IntPtr) posW, (IntPtr) pos, (bool) bDeform);
	    return (ret == 0) ? false : true;
				}
			}
		} else {
	    char ret = SprExport.Spr_PHFemVibrationIf_GetPosition((IntPtr) _thisArray[0], (int) tetId, (IntPtr) posW, (IntPtr) pos, (bool) bDeform);
	    return (ret == 0) ? false : true;
		}
		throw new InvalidOperationException();
	}
	public void SetbRecomp() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemVibrationIf_SetbRecomp((IntPtr) _thisArray[phSceneIf.sceneForStep]);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemVibrationIf_SetbRecomp((IntPtr) _thisArray[phSceneIf.sceneForGet]);
				}
			}
		} else {
	    SprExport.Spr_PHFemVibrationIf_SetbRecomp((IntPtr) _thisArray[0]);
		}
		throw new InvalidOperationException();
	}
	public void Init() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemVibrationIf_Init((IntPtr) _thisArray[phSceneIf.sceneForStep]);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemVibrationIf_Init((IntPtr) _thisArray[phSceneIf.sceneForGet]);
				}
			}
		} else {
	    SprExport.Spr_PHFemVibrationIf_Init((IntPtr) _thisArray[0]);
		}
		throw new InvalidOperationException();
	}
    }
    public partial class PHFemThermoIf : PHFemBaseIf {
	public PHFemThermoIf() { _thisArray[0] = SprExport.Spr_new_PHFemThermoIf(); _flag = true; }
	public PHFemThermoIf(IntPtr ptr) : base(ptr) {}
	public PHFemThermoIf(IntPtr ptr, bool flag) : base(ptr, flag) {}
	public static implicit operator PHFemThermoIf(CsCastObject target) {
		return (target._info.Inherit(PHFemThermoIf.GetIfInfoStatic()) ? new PHFemThermoIf(target._thisArray[0], target._flag) : null);
	}
	~PHFemThermoIf() { if (_flag) { SprExport.Spr_delete_PHFemThermoIf(_thisArray[0]); _flag = false; } }
        public override string ToString() {
            IntPtr ptr = SprExport.Spr_PHFemThermoIf_ToString((IntPtr) _thisArray[0]);
            string bstr = Marshal.PtrToStringBSTR(ptr);
            SprExport.Spr_PHFemThermoIf_FreeString((IntPtr) ptr);
            return bstr;
        }
	public IfInfo GetIfInfo() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHFemThermoIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new IfInfo(ptr);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHFemThermoIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new IfInfo(ptr);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHFemThermoIf_GetIfInfo((IntPtr) _thisArray[0]);
            return new IfInfo(ptr);
		}
		throw new InvalidOperationException();
	}
	public static IfInfo GetIfInfoStatic() {
	    IntPtr ptr = SprExport.Spr_PHFemThermoIf_GetIfInfoStatic();
            return new IfInfo(ptr);
	}
	public int GetSurfaceVertex(int id) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    int result = (int) SprExport.Spr_PHFemThermoIf_GetSurfaceVertex((IntPtr) _thisArray[phSceneIf.sceneForStep], (int) id);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    int result = (int) SprExport.Spr_PHFemThermoIf_GetSurfaceVertex((IntPtr) _thisArray[phSceneIf.sceneForGet], (int) id);
	    return result;
				}
			}
		} else {
	    int result = (int) SprExport.Spr_PHFemThermoIf_GetSurfaceVertex((IntPtr) _thisArray[0], (int) id);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public int NSurfaceVertices() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    int result = (int) SprExport.Spr_PHFemThermoIf_NSurfaceVertices((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    int result = (int) SprExport.Spr_PHFemThermoIf_NSurfaceVertices((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    int result = (int) SprExport.Spr_PHFemThermoIf_NSurfaceVertices((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public void SetVertexTc(int id, double temp) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemThermoIf_SetVertexTc((IntPtr) _thisArray[phSceneIf.sceneForStep], (int) id, (double) temp);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemThermoIf_SetVertexTc((IntPtr) _thisArray[phSceneIf.sceneForGet], (int) id, (double) temp);
				}
			}
		} else {
	    SprExport.Spr_PHFemThermoIf_SetVertexTc((IntPtr) _thisArray[0], (int) id, (double) temp);
		}
		throw new InvalidOperationException();
	}
	public void SetVertexTc(int id, double temp, double heatTrans) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemThermoIf_SetVertexTc_1((IntPtr) _thisArray[phSceneIf.sceneForStep], (int) id, (double) temp, (double) heatTrans);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemThermoIf_SetVertexTc_1((IntPtr) _thisArray[phSceneIf.sceneForGet], (int) id, (double) temp, (double) heatTrans);
				}
			}
		} else {
	    SprExport.Spr_PHFemThermoIf_SetVertexTc_1((IntPtr) _thisArray[0], (int) id, (double) temp, (double) heatTrans);
		}
		throw new InvalidOperationException();
	}
	public Vec3d GetPose(int id) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHFemThermoIf_GetPose((IntPtr) _thisArray[phSceneIf.sceneForStep], (int) id);
            return new Vec3d(ptr, true);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHFemThermoIf_GetPose((IntPtr) _thisArray[phSceneIf.sceneForGet], (int) id);
            return new Vec3d(ptr, true);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHFemThermoIf_GetPose((IntPtr) _thisArray[0], (int) id);
            return new Vec3d(ptr, true);
		}
		throw new InvalidOperationException();
	}
	public Vec3d GetSufVtxPose(uint id) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHFemThermoIf_GetSufVtxPose((IntPtr) _thisArray[phSceneIf.sceneForStep], (uint) id);
            return new Vec3d(ptr, true);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHFemThermoIf_GetSufVtxPose((IntPtr) _thisArray[phSceneIf.sceneForGet], (uint) id);
            return new Vec3d(ptr, true);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHFemThermoIf_GetSufVtxPose((IntPtr) _thisArray[0], (uint) id);
            return new Vec3d(ptr, true);
		}
		throw new InvalidOperationException();
	}
	public uint GetStepCount() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    uint result = (uint) SprExport.Spr_PHFemThermoIf_GetStepCount((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    uint result = (uint) SprExport.Spr_PHFemThermoIf_GetStepCount((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    uint result = (uint) SprExport.Spr_PHFemThermoIf_GetStepCount((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public uint GetStepCountCyc() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    uint result = (uint) SprExport.Spr_PHFemThermoIf_GetStepCountCyc((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    uint result = (uint) SprExport.Spr_PHFemThermoIf_GetStepCountCyc((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    uint result = (uint) SprExport.Spr_PHFemThermoIf_GetStepCountCyc((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public double GetVertexTemp(uint id) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    double result = (double) SprExport.Spr_PHFemThermoIf_GetVertexTemp((IntPtr) _thisArray[phSceneIf.sceneForStep], (uint) id);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    double result = (double) SprExport.Spr_PHFemThermoIf_GetVertexTemp((IntPtr) _thisArray[phSceneIf.sceneForGet], (uint) id);
	    return result;
				}
			}
		} else {
	    double result = (double) SprExport.Spr_PHFemThermoIf_GetVertexTemp((IntPtr) _thisArray[0], (uint) id);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public double GetSufVertexTemp(uint id) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    double result = (double) SprExport.Spr_PHFemThermoIf_GetSufVertexTemp((IntPtr) _thisArray[phSceneIf.sceneForStep], (uint) id);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    double result = (double) SprExport.Spr_PHFemThermoIf_GetSufVertexTemp((IntPtr) _thisArray[phSceneIf.sceneForGet], (uint) id);
	    return result;
				}
			}
		} else {
	    double result = (double) SprExport.Spr_PHFemThermoIf_GetSufVertexTemp((IntPtr) _thisArray[0], (uint) id);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public void SetVertexTemp(uint id, double temp) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemThermoIf_SetVertexTemp((IntPtr) _thisArray[phSceneIf.sceneForStep], (uint) id, (double) temp);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemThermoIf_SetVertexTemp((IntPtr) _thisArray[phSceneIf.sceneForGet], (uint) id, (double) temp);
				}
			}
		} else {
	    SprExport.Spr_PHFemThermoIf_SetVertexTemp((IntPtr) _thisArray[0], (uint) id, (double) temp);
		}
		throw new InvalidOperationException();
	}
	public void SetVerticesTempAll(double temp) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemThermoIf_SetVerticesTempAll((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) temp);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemThermoIf_SetVerticesTempAll((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) temp);
				}
			}
		} else {
	    SprExport.Spr_PHFemThermoIf_SetVerticesTempAll((IntPtr) _thisArray[0], (double) temp);
		}
		throw new InvalidOperationException();
	}
	public void AddvecFAll(uint id, double dqdt) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemThermoIf_AddvecFAll((IntPtr) _thisArray[phSceneIf.sceneForStep], (uint) id, (double) dqdt);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemThermoIf_AddvecFAll((IntPtr) _thisArray[phSceneIf.sceneForGet], (uint) id, (double) dqdt);
				}
			}
		} else {
	    SprExport.Spr_PHFemThermoIf_AddvecFAll((IntPtr) _thisArray[0], (uint) id, (double) dqdt);
		}
		throw new InvalidOperationException();
	}
	public void SetvecFAll(uint id, double dqdt) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemThermoIf_SetvecFAll((IntPtr) _thisArray[phSceneIf.sceneForStep], (uint) id, (double) dqdt);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemThermoIf_SetvecFAll((IntPtr) _thisArray[phSceneIf.sceneForGet], (uint) id, (double) dqdt);
				}
			}
		} else {
	    SprExport.Spr_PHFemThermoIf_SetvecFAll((IntPtr) _thisArray[0], (uint) id, (double) dqdt);
		}
		throw new InvalidOperationException();
	}
	public void SetRhoSpheat(double rho, double Cp) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemThermoIf_SetRhoSpheat((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) rho, (double) Cp);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemThermoIf_SetRhoSpheat((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) rho, (double) Cp);
				}
			}
		} else {
	    SprExport.Spr_PHFemThermoIf_SetRhoSpheat((IntPtr) _thisArray[0], (double) rho, (double) Cp);
		}
		throw new InvalidOperationException();
	}
	public Vec2d GetIHbandDrawVtx() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHFemThermoIf_GetIHbandDrawVtx((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new Vec2d(ptr, true);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHFemThermoIf_GetIHbandDrawVtx((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new Vec2d(ptr, true);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHFemThermoIf_GetIHbandDrawVtx((IntPtr) _thisArray[0]);
            return new Vec2d(ptr, true);
		}
		throw new InvalidOperationException();
	}
	public void CalcIHdqdt_atleast(double r, double R, double dqdtAll, uint num) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemThermoIf_CalcIHdqdt_atleast((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) r, (double) R, (double) dqdtAll, (uint) num);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemThermoIf_CalcIHdqdt_atleast((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) r, (double) R, (double) dqdtAll, (uint) num);
				}
			}
		} else {
	    SprExport.Spr_PHFemThermoIf_CalcIHdqdt_atleast((IntPtr) _thisArray[0], (double) r, (double) R, (double) dqdtAll, (uint) num);
		}
		throw new InvalidOperationException();
	}
	public void UpdateIHheatband(double xS, double xE, uint heatingMODE) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemThermoIf_UpdateIHheatband((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) xS, (double) xE, (uint) heatingMODE);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemThermoIf_UpdateIHheatband((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) xS, (double) xE, (uint) heatingMODE);
				}
			}
		} else {
	    SprExport.Spr_PHFemThermoIf_UpdateIHheatband((IntPtr) _thisArray[0], (double) xS, (double) xE, (uint) heatingMODE);
		}
		throw new InvalidOperationException();
	}
	public void UpdateIHheat(uint heating) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemThermoIf_UpdateIHheat((IntPtr) _thisArray[phSceneIf.sceneForStep], (uint) heating);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemThermoIf_UpdateIHheat((IntPtr) _thisArray[phSceneIf.sceneForGet], (uint) heating);
				}
			}
		} else {
	    SprExport.Spr_PHFemThermoIf_UpdateIHheat((IntPtr) _thisArray[0], (uint) heating);
		}
		throw new InvalidOperationException();
	}
	public void UpdateVecF() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemThermoIf_UpdateVecF((IntPtr) _thisArray[phSceneIf.sceneForStep]);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemThermoIf_UpdateVecF((IntPtr) _thisArray[phSceneIf.sceneForGet]);
				}
			}
		} else {
	    SprExport.Spr_PHFemThermoIf_UpdateVecF((IntPtr) _thisArray[0]);
		}
		throw new InvalidOperationException();
	}
	public void UpdateVecF_frypan() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemThermoIf_UpdateVecF_frypan((IntPtr) _thisArray[phSceneIf.sceneForStep]);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemThermoIf_UpdateVecF_frypan((IntPtr) _thisArray[phSceneIf.sceneForGet]);
				}
			}
		} else {
	    SprExport.Spr_PHFemThermoIf_UpdateVecF_frypan((IntPtr) _thisArray[0]);
		}
		throw new InvalidOperationException();
	}
	public void DecrMoist() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemThermoIf_DecrMoist((IntPtr) _thisArray[phSceneIf.sceneForStep]);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemThermoIf_DecrMoist((IntPtr) _thisArray[phSceneIf.sceneForGet]);
				}
			}
		} else {
	    SprExport.Spr_PHFemThermoIf_DecrMoist((IntPtr) _thisArray[0]);
		}
		throw new InvalidOperationException();
	}
	public void DecrMoist_velo(double vel) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemThermoIf_DecrMoist_velo((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) vel);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemThermoIf_DecrMoist_velo((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) vel);
				}
			}
		} else {
	    SprExport.Spr_PHFemThermoIf_DecrMoist_velo((IntPtr) _thisArray[0], (double) vel);
		}
		throw new InvalidOperationException();
	}
	public void DecrMoist_vel(double dt) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemThermoIf_DecrMoist_vel((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) dt);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemThermoIf_DecrMoist_vel((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) dt);
				}
			}
		} else {
	    SprExport.Spr_PHFemThermoIf_DecrMoist_vel((IntPtr) _thisArray[0], (double) dt);
		}
		throw new InvalidOperationException();
	}
	public void InitAllVertexTemp() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemThermoIf_InitAllVertexTemp((IntPtr) _thisArray[phSceneIf.sceneForStep]);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemThermoIf_InitAllVertexTemp((IntPtr) _thisArray[phSceneIf.sceneForGet]);
				}
			}
		} else {
	    SprExport.Spr_PHFemThermoIf_InitAllVertexTemp((IntPtr) _thisArray[0]);
		}
		throw new InvalidOperationException();
	}
	public void SetInitThermoConductionParam(double thConduct, double rho, double specificHeat, double heatTrans) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemThermoIf_SetInitThermoConductionParam((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) thConduct, (double) rho, (double) specificHeat, (double) heatTrans);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemThermoIf_SetInitThermoConductionParam((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) thConduct, (double) rho, (double) specificHeat, (double) heatTrans);
				}
			}
		} else {
	    SprExport.Spr_PHFemThermoIf_SetInitThermoConductionParam((IntPtr) _thisArray[0], (double) thConduct, (double) rho, (double) specificHeat, (double) heatTrans);
		}
		throw new InvalidOperationException();
	}
	public void SetParamAndReCreateMatrix(double thConduct0, double roh0, double specificHeat0) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemThermoIf_SetParamAndReCreateMatrix((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) thConduct0, (double) roh0, (double) specificHeat0);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemThermoIf_SetParamAndReCreateMatrix((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) thConduct0, (double) roh0, (double) specificHeat0);
				}
			}
		} else {
	    SprExport.Spr_PHFemThermoIf_SetParamAndReCreateMatrix((IntPtr) _thisArray[0], (double) thConduct0, (double) roh0, (double) specificHeat0);
		}
		throw new InvalidOperationException();
	}
	public double GetArbitraryPointTemp(Vec3d temppos) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    double result = (double) SprExport.Spr_PHFemThermoIf_GetArbitraryPointTemp((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) temppos);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    double result = (double) SprExport.Spr_PHFemThermoIf_GetArbitraryPointTemp((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) temppos);
	    return result;
				}
			}
		} else {
	    double result = (double) SprExport.Spr_PHFemThermoIf_GetArbitraryPointTemp((IntPtr) _thisArray[0], (IntPtr) temppos);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public double GetVtxTempInTets(Vec3d temppos) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    double result = (double) SprExport.Spr_PHFemThermoIf_GetVtxTempInTets((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) temppos);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    double result = (double) SprExport.Spr_PHFemThermoIf_GetVtxTempInTets((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) temppos);
	    return result;
				}
			}
		} else {
	    double result = (double) SprExport.Spr_PHFemThermoIf_GetVtxTempInTets((IntPtr) _thisArray[0], (IntPtr) temppos);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public void InitVecFAlls() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemThermoIf_InitVecFAlls((IntPtr) _thisArray[phSceneIf.sceneForStep]);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemThermoIf_InitVecFAlls((IntPtr) _thisArray[phSceneIf.sceneForGet]);
				}
			}
		} else {
	    SprExport.Spr_PHFemThermoIf_InitVecFAlls((IntPtr) _thisArray[0]);
		}
		throw new InvalidOperationException();
	}
	public double Get_thConduct() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    double result = (double) SprExport.Spr_PHFemThermoIf_Get_thConduct((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    double result = (double) SprExport.Spr_PHFemThermoIf_Get_thConduct((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    double result = (double) SprExport.Spr_PHFemThermoIf_Get_thConduct((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public bool SetConcentricHeatMap(vectorwrapper_double r, vectorwrapper_double temp, Vec2d origin) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    char ret = SprExport.Spr_PHFemThermoIf_SetConcentricHeatMap((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) r, (IntPtr) temp, (IntPtr) origin);
	    return (ret == 0) ? false : true;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    char ret = SprExport.Spr_PHFemThermoIf_SetConcentricHeatMap((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) r, (IntPtr) temp, (IntPtr) origin);
	    return (ret == 0) ? false : true;
				}
			}
		} else {
	    char ret = SprExport.Spr_PHFemThermoIf_SetConcentricHeatMap((IntPtr) _thisArray[0], (IntPtr) r, (IntPtr) temp, (IntPtr) origin);
	    return (ret == 0) ? false : true;
		}
		throw new InvalidOperationException();
	}
	public void SetThermalEmissivityToVerticesAll(double thermalEmissivity, double thermalEmissivity_const) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemThermoIf_SetThermalEmissivityToVerticesAll((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) thermalEmissivity, (double) thermalEmissivity_const);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemThermoIf_SetThermalEmissivityToVerticesAll((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) thermalEmissivity, (double) thermalEmissivity_const);
				}
			}
		} else {
	    SprExport.Spr_PHFemThermoIf_SetThermalEmissivityToVerticesAll((IntPtr) _thisArray[0], (double) thermalEmissivity, (double) thermalEmissivity_const);
		}
		throw new InvalidOperationException();
	}
	public void SetOuterTemp(double temp) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemThermoIf_SetOuterTemp((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) temp);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemThermoIf_SetOuterTemp((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) temp);
				}
			}
		} else {
	    SprExport.Spr_PHFemThermoIf_SetOuterTemp((IntPtr) _thisArray[0], (double) temp);
		}
		throw new InvalidOperationException();
	}
	public void SetThermalRadiation(double ems, double ems_const) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemThermoIf_SetThermalRadiation((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) ems, (double) ems_const);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemThermoIf_SetThermalRadiation((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) ems, (double) ems_const);
				}
			}
		} else {
	    SprExport.Spr_PHFemThermoIf_SetThermalRadiation((IntPtr) _thisArray[0], (double) ems, (double) ems_const);
		}
		throw new InvalidOperationException();
	}
	public void SetGaussCalcParam(uint cyc, double epsilon) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemThermoIf_SetGaussCalcParam((IntPtr) _thisArray[phSceneIf.sceneForStep], (uint) cyc, (double) epsilon);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemThermoIf_SetGaussCalcParam((IntPtr) _thisArray[phSceneIf.sceneForGet], (uint) cyc, (double) epsilon);
				}
			}
		} else {
	    SprExport.Spr_PHFemThermoIf_SetGaussCalcParam((IntPtr) _thisArray[0], (uint) cyc, (double) epsilon);
		}
		throw new InvalidOperationException();
	}
	public void InitTcAll(double temp) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemThermoIf_InitTcAll((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) temp);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemThermoIf_InitTcAll((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) temp);
				}
			}
		} else {
	    SprExport.Spr_PHFemThermoIf_InitTcAll((IntPtr) _thisArray[0], (double) temp);
		}
		throw new InvalidOperationException();
	}
	public void InitToutAll(double temp) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemThermoIf_InitToutAll((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) temp);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemThermoIf_InitToutAll((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) temp);
				}
			}
		} else {
	    SprExport.Spr_PHFemThermoIf_InitToutAll((IntPtr) _thisArray[0], (double) temp);
		}
		throw new InvalidOperationException();
	}
	public void SetWeekPow(double weekPow_) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemThermoIf_SetWeekPow((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) weekPow_);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemThermoIf_SetWeekPow((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) weekPow_);
				}
			}
		} else {
	    SprExport.Spr_PHFemThermoIf_SetWeekPow((IntPtr) _thisArray[0], (double) weekPow_);
		}
		throw new InvalidOperationException();
	}
	public void SetIHParamWEEK(double inr_, double outR_, double weekPow_) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemThermoIf_SetIHParamWEEK((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) inr_, (double) outR_, (double) weekPow_);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemThermoIf_SetIHParamWEEK((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) inr_, (double) outR_, (double) weekPow_);
				}
			}
		} else {
	    SprExport.Spr_PHFemThermoIf_SetIHParamWEEK((IntPtr) _thisArray[0], (double) inr_, (double) outR_, (double) weekPow_);
		}
		throw new InvalidOperationException();
	}
	public void SetHeatTransRatioToAllVertex(double heatTransR_) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemThermoIf_SetHeatTransRatioToAllVertex((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) heatTransR_);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemThermoIf_SetHeatTransRatioToAllVertex((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) heatTransR_);
				}
			}
		} else {
	    SprExport.Spr_PHFemThermoIf_SetHeatTransRatioToAllVertex((IntPtr) _thisArray[0], (double) heatTransR_);
		}
		throw new InvalidOperationException();
	}
	public void AfterSetDesc() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemThermoIf_AfterSetDesc((IntPtr) _thisArray[phSceneIf.sceneForStep]);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemThermoIf_AfterSetDesc((IntPtr) _thisArray[phSceneIf.sceneForGet]);
				}
			}
		} else {
	    SprExport.Spr_PHFemThermoIf_AfterSetDesc((IntPtr) _thisArray[0]);
		}
		throw new InvalidOperationException();
	}
	public void SetStopTimespan(double timespan) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemThermoIf_SetStopTimespan((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) timespan);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemThermoIf_SetStopTimespan((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) timespan);
				}
			}
		} else {
	    SprExport.Spr_PHFemThermoIf_SetStopTimespan((IntPtr) _thisArray[0], (double) timespan);
		}
		throw new InvalidOperationException();
	}
	public void UpdateMatk_RadiantHeatToAir() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemThermoIf_UpdateMatk_RadiantHeatToAir((IntPtr) _thisArray[phSceneIf.sceneForStep]);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemThermoIf_UpdateMatk_RadiantHeatToAir((IntPtr) _thisArray[phSceneIf.sceneForGet]);
				}
			}
		} else {
	    SprExport.Spr_PHFemThermoIf_UpdateMatk_RadiantHeatToAir((IntPtr) _thisArray[0]);
		}
		throw new InvalidOperationException();
	}
	public void ReCreateMatrix(double thConduct0) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemThermoIf_ReCreateMatrix((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) thConduct0);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemThermoIf_ReCreateMatrix((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) thConduct0);
				}
			}
		} else {
	    SprExport.Spr_PHFemThermoIf_ReCreateMatrix((IntPtr) _thisArray[0], (double) thConduct0);
		}
		throw new InvalidOperationException();
	}
	public void ActivateVtxbeRadiantHeat() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemThermoIf_ActivateVtxbeRadiantHeat((IntPtr) _thisArray[phSceneIf.sceneForStep]);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemThermoIf_ActivateVtxbeRadiantHeat((IntPtr) _thisArray[phSceneIf.sceneForGet]);
				}
			}
		} else {
	    SprExport.Spr_PHFemThermoIf_ActivateVtxbeRadiantHeat((IntPtr) _thisArray[0]);
		}
		throw new InvalidOperationException();
	}
	public void OutputMatKall() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemThermoIf_OutputMatKall((IntPtr) _thisArray[phSceneIf.sceneForStep]);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemThermoIf_OutputMatKall((IntPtr) _thisArray[phSceneIf.sceneForGet]);
				}
			}
		} else {
	    SprExport.Spr_PHFemThermoIf_OutputMatKall((IntPtr) _thisArray[0]);
		}
		throw new InvalidOperationException();
	}
	public void IfRadiantHeatTrans() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemThermoIf_IfRadiantHeatTrans((IntPtr) _thisArray[phSceneIf.sceneForStep]);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemThermoIf_IfRadiantHeatTrans((IntPtr) _thisArray[phSceneIf.sceneForGet]);
				}
			}
		} else {
	    SprExport.Spr_PHFemThermoIf_IfRadiantHeatTrans((IntPtr) _thisArray[0]);
		}
		throw new InvalidOperationException();
	}
	public void IfRadiantHeatTransSteak() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemThermoIf_IfRadiantHeatTransSteak((IntPtr) _thisArray[phSceneIf.sceneForStep]);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemThermoIf_IfRadiantHeatTransSteak((IntPtr) _thisArray[phSceneIf.sceneForGet]);
				}
			}
		} else {
	    SprExport.Spr_PHFemThermoIf_IfRadiantHeatTransSteak((IntPtr) _thisArray[0]);
		}
		throw new InvalidOperationException();
	}
	public float calcGvtx(string fwfood, int pv, uint texture_mode) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
            IntPtr remote1 = Marshal.StringToBSTR(fwfood);
	    float result = (float) SprExport.Spr_PHFemThermoIf_calcGvtx((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) remote1, (int) pv, (uint) texture_mode);
            Marshal.FreeBSTR(remote1);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
            IntPtr remote1 = Marshal.StringToBSTR(fwfood);
	    float result = (float) SprExport.Spr_PHFemThermoIf_calcGvtx((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) remote1, (int) pv, (uint) texture_mode);
            Marshal.FreeBSTR(remote1);
	    return result;
				}
			}
		} else {
            IntPtr remote1 = Marshal.StringToBSTR(fwfood);
	    float result = (float) SprExport.Spr_PHFemThermoIf_calcGvtx((IntPtr) _thisArray[0], (IntPtr) remote1, (int) pv, (uint) texture_mode);
            Marshal.FreeBSTR(remote1);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public void SetTimeStep(double dt) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemThermoIf_SetTimeStep((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) dt);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemThermoIf_SetTimeStep((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) dt);
				}
			}
		} else {
	    SprExport.Spr_PHFemThermoIf_SetTimeStep((IntPtr) _thisArray[0], (double) dt);
		}
		throw new InvalidOperationException();
	}
	public Vec3d GetVertexNormal(uint vtxid) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHFemThermoIf_GetVertexNormal((IntPtr) _thisArray[phSceneIf.sceneForStep], (uint) vtxid);
            return new Vec3d(ptr, true);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHFemThermoIf_GetVertexNormal((IntPtr) _thisArray[phSceneIf.sceneForGet], (uint) vtxid);
            return new Vec3d(ptr, true);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHFemThermoIf_GetVertexNormal((IntPtr) _thisArray[0], (uint) vtxid);
            return new Vec3d(ptr, true);
		}
		throw new InvalidOperationException();
	}
	public void SetVertexHeatTransRatio(uint vtxid, double heattransRatio) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemThermoIf_SetVertexHeatTransRatio((IntPtr) _thisArray[phSceneIf.sceneForStep], (uint) vtxid, (double) heattransRatio);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemThermoIf_SetVertexHeatTransRatio((IntPtr) _thisArray[phSceneIf.sceneForGet], (uint) vtxid, (double) heattransRatio);
				}
			}
		} else {
	    SprExport.Spr_PHFemThermoIf_SetVertexHeatTransRatio((IntPtr) _thisArray[0], (uint) vtxid, (double) heattransRatio);
		}
		throw new InvalidOperationException();
	}
	public void SetVertexBeRadiantHeat(uint vtxid, bool flag) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemThermoIf_SetVertexBeRadiantHeat((IntPtr) _thisArray[phSceneIf.sceneForStep], (uint) vtxid, (bool) flag);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemThermoIf_SetVertexBeRadiantHeat((IntPtr) _thisArray[phSceneIf.sceneForGet], (uint) vtxid, (bool) flag);
				}
			}
		} else {
	    SprExport.Spr_PHFemThermoIf_SetVertexBeRadiantHeat((IntPtr) _thisArray[0], (uint) vtxid, (bool) flag);
		}
		throw new InvalidOperationException();
	}
	public double GetVertexArea(uint vtxid) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    double result = (double) SprExport.Spr_PHFemThermoIf_GetVertexArea((IntPtr) _thisArray[phSceneIf.sceneForStep], (uint) vtxid);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    double result = (double) SprExport.Spr_PHFemThermoIf_GetVertexArea((IntPtr) _thisArray[phSceneIf.sceneForGet], (uint) vtxid);
	    return result;
				}
			}
		} else {
	    double result = (double) SprExport.Spr_PHFemThermoIf_GetVertexArea((IntPtr) _thisArray[0], (uint) vtxid);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public void SetVertexToofar(uint vtxid, bool tooFar) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemThermoIf_SetVertexToofar((IntPtr) _thisArray[phSceneIf.sceneForStep], (uint) vtxid, (bool) tooFar);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemThermoIf_SetVertexToofar((IntPtr) _thisArray[phSceneIf.sceneForGet], (uint) vtxid, (bool) tooFar);
				}
			}
		} else {
	    SprExport.Spr_PHFemThermoIf_SetVertexToofar((IntPtr) _thisArray[0], (uint) vtxid, (bool) tooFar);
		}
		throw new InvalidOperationException();
	}
	public bool GetVertexToofar(uint vtxid) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    char ret = SprExport.Spr_PHFemThermoIf_GetVertexToofar((IntPtr) _thisArray[phSceneIf.sceneForStep], (uint) vtxid);
	    return (ret == 0) ? false : true;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    char ret = SprExport.Spr_PHFemThermoIf_GetVertexToofar((IntPtr) _thisArray[phSceneIf.sceneForGet], (uint) vtxid);
	    return (ret == 0) ? false : true;
				}
			}
		} else {
	    char ret = SprExport.Spr_PHFemThermoIf_GetVertexToofar((IntPtr) _thisArray[0], (uint) vtxid);
	    return (ret == 0) ? false : true;
		}
		throw new InvalidOperationException();
	}
	public void SetVertexBeCondVtxs(uint vtxid, bool becondVtxs) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemThermoIf_SetVertexBeCondVtxs((IntPtr) _thisArray[phSceneIf.sceneForStep], (uint) vtxid, (bool) becondVtxs);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemThermoIf_SetVertexBeCondVtxs((IntPtr) _thisArray[phSceneIf.sceneForGet], (uint) vtxid, (bool) becondVtxs);
				}
			}
		} else {
	    SprExport.Spr_PHFemThermoIf_SetVertexBeCondVtxs((IntPtr) _thisArray[0], (uint) vtxid, (bool) becondVtxs);
		}
		throw new InvalidOperationException();
	}
	public void CreateVecFAll() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemThermoIf_CreateVecFAll((IntPtr) _thisArray[phSceneIf.sceneForStep]);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemThermoIf_CreateVecFAll((IntPtr) _thisArray[phSceneIf.sceneForGet]);
				}
			}
		} else {
	    SprExport.Spr_PHFemThermoIf_CreateVecFAll((IntPtr) _thisArray[0]);
		}
		throw new InvalidOperationException();
	}
	public void CalcFaceNormalAll() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemThermoIf_CalcFaceNormalAll((IntPtr) _thisArray[phSceneIf.sceneForStep]);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemThermoIf_CalcFaceNormalAll((IntPtr) _thisArray[phSceneIf.sceneForGet]);
				}
			}
		} else {
	    SprExport.Spr_PHFemThermoIf_CalcFaceNormalAll((IntPtr) _thisArray[0]);
		}
		throw new InvalidOperationException();
	}
	public void CalcVertexNormalAll() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemThermoIf_CalcVertexNormalAll((IntPtr) _thisArray[phSceneIf.sceneForStep]);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemThermoIf_CalcVertexNormalAll((IntPtr) _thisArray[phSceneIf.sceneForGet]);
				}
			}
		} else {
	    SprExport.Spr_PHFemThermoIf_CalcVertexNormalAll((IntPtr) _thisArray[0]);
		}
		throw new InvalidOperationException();
	}
	public void InitFaceNormalAll() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemThermoIf_InitFaceNormalAll((IntPtr) _thisArray[phSceneIf.sceneForStep]);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemThermoIf_InitFaceNormalAll((IntPtr) _thisArray[phSceneIf.sceneForGet]);
				}
			}
		} else {
	    SprExport.Spr_PHFemThermoIf_InitFaceNormalAll((IntPtr) _thisArray[0]);
		}
		throw new InvalidOperationException();
	}
	public void InitVertexNormalAll() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemThermoIf_InitVertexNormalAll((IntPtr) _thisArray[phSceneIf.sceneForStep]);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemThermoIf_InitVertexNormalAll((IntPtr) _thisArray[phSceneIf.sceneForGet]);
				}
			}
		} else {
	    SprExport.Spr_PHFemThermoIf_InitVertexNormalAll((IntPtr) _thisArray[0]);
		}
		throw new InvalidOperationException();
	}
	public void RevVertexNormalAll() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemThermoIf_RevVertexNormalAll((IntPtr) _thisArray[phSceneIf.sceneForStep]);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemThermoIf_RevVertexNormalAll((IntPtr) _thisArray[phSceneIf.sceneForGet]);
				}
			}
		} else {
	    SprExport.Spr_PHFemThermoIf_RevVertexNormalAll((IntPtr) _thisArray[0]);
		}
		throw new InvalidOperationException();
	}
	public void SetWeekPowFULL(double weekPow_full) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemThermoIf_SetWeekPowFULL((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) weekPow_full);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemThermoIf_SetWeekPowFULL((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) weekPow_full);
				}
			}
		} else {
	    SprExport.Spr_PHFemThermoIf_SetWeekPowFULL((IntPtr) _thisArray[0], (double) weekPow_full);
		}
		throw new InvalidOperationException();
	}
	public void SetweekPow_FULL(double setweekPow_FULL) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemThermoIf_SetweekPow_FULL((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) setweekPow_FULL);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemThermoIf_SetweekPow_FULL((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) setweekPow_FULL);
				}
			}
		} else {
	    SprExport.Spr_PHFemThermoIf_SetweekPow_FULL((IntPtr) _thisArray[0], (double) setweekPow_FULL);
		}
		throw new InvalidOperationException();
	}
	public void setIhRatio(double a) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemThermoIf_setIhRatio((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) a);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemThermoIf_setIhRatio((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) a);
				}
			}
		} else {
	    SprExport.Spr_PHFemThermoIf_setIhRatio((IntPtr) _thisArray[0], (double) a);
		}
		throw new InvalidOperationException();
	}
	public void Setems(double setems) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemThermoIf_Setems((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) setems);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemThermoIf_Setems((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) setems);
				}
			}
		} else {
	    SprExport.Spr_PHFemThermoIf_Setems((IntPtr) _thisArray[0], (double) setems);
		}
		throw new InvalidOperationException();
	}
	public void Setems_steak(double setems_steak) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemThermoIf_Setems_steak((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) setems_steak);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemThermoIf_Setems_steak((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) setems_steak);
				}
			}
		} else {
	    SprExport.Spr_PHFemThermoIf_Setems_steak((IntPtr) _thisArray[0], (double) setems_steak);
		}
		throw new InvalidOperationException();
	}
	public void SetthConduct(double thConduct) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemThermoIf_SetthConduct((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) thConduct);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemThermoIf_SetthConduct((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) thConduct);
				}
			}
		} else {
	    SprExport.Spr_PHFemThermoIf_SetthConduct((IntPtr) _thisArray[0], (double) thConduct);
		}
		throw new InvalidOperationException();
	}
	public double GetWeekPowFULL() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    double result = (double) SprExport.Spr_PHFemThermoIf_GetWeekPowFULL((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    double result = (double) SprExport.Spr_PHFemThermoIf_GetWeekPowFULL((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    double result = (double) SprExport.Spr_PHFemThermoIf_GetWeekPowFULL((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public Vec3d GetVertexPose(uint vtxid) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHFemThermoIf_GetVertexPose((IntPtr) _thisArray[phSceneIf.sceneForStep], (uint) vtxid);
            return new Vec3d(ptr, true);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHFemThermoIf_GetVertexPose((IntPtr) _thisArray[phSceneIf.sceneForGet], (uint) vtxid);
            return new Vec3d(ptr, true);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHFemThermoIf_GetVertexPose((IntPtr) _thisArray[0], (uint) vtxid);
            return new Vec3d(ptr, true);
		}
		throw new InvalidOperationException();
	}
	public void OutTetVolumeAll() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemThermoIf_OutTetVolumeAll((IntPtr) _thisArray[phSceneIf.sceneForStep]);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemThermoIf_OutTetVolumeAll((IntPtr) _thisArray[phSceneIf.sceneForGet]);
				}
			}
		} else {
	    SprExport.Spr_PHFemThermoIf_OutTetVolumeAll((IntPtr) _thisArray[0]);
		}
		throw new InvalidOperationException();
	}
	public int GetTetsV(uint tetid, uint vtxid) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    int result = (int) SprExport.Spr_PHFemThermoIf_GetTetsV((IntPtr) _thisArray[phSceneIf.sceneForStep], (uint) tetid, (uint) vtxid);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    int result = (int) SprExport.Spr_PHFemThermoIf_GetTetsV((IntPtr) _thisArray[phSceneIf.sceneForGet], (uint) tetid, (uint) vtxid);
	    return result;
				}
			}
		} else {
	    int result = (int) SprExport.Spr_PHFemThermoIf_GetTetsV((IntPtr) _thisArray[0], (uint) tetid, (uint) vtxid);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public void VecFNegativeCheck() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemThermoIf_VecFNegativeCheck((IntPtr) _thisArray[phSceneIf.sceneForStep]);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemThermoIf_VecFNegativeCheck((IntPtr) _thisArray[phSceneIf.sceneForGet]);
				}
			}
		} else {
	    SprExport.Spr_PHFemThermoIf_VecFNegativeCheck((IntPtr) _thisArray[0]);
		}
		throw new InvalidOperationException();
	}
	public double GetVecFElem(uint vtxid) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    double result = (double) SprExport.Spr_PHFemThermoIf_GetVecFElem((IntPtr) _thisArray[phSceneIf.sceneForStep], (uint) vtxid);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    double result = (double) SprExport.Spr_PHFemThermoIf_GetVecFElem((IntPtr) _thisArray[phSceneIf.sceneForGet], (uint) vtxid);
	    return result;
				}
			}
		} else {
	    double result = (double) SprExport.Spr_PHFemThermoIf_GetVecFElem((IntPtr) _thisArray[0], (uint) vtxid);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public int GetTetVNums(uint id, uint num) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    int result = (int) SprExport.Spr_PHFemThermoIf_GetTetVNums((IntPtr) _thisArray[phSceneIf.sceneForStep], (uint) id, (uint) num);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    int result = (int) SprExport.Spr_PHFemThermoIf_GetTetVNums((IntPtr) _thisArray[phSceneIf.sceneForGet], (uint) id, (uint) num);
	    return result;
				}
			}
		} else {
	    int result = (int) SprExport.Spr_PHFemThermoIf_GetTetVNums((IntPtr) _thisArray[0], (uint) id, (uint) num);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public double GetInitialTemp() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    double result = (double) SprExport.Spr_PHFemThermoIf_GetInitialTemp((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    double result = (double) SprExport.Spr_PHFemThermoIf_GetInitialTemp((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    double result = (double) SprExport.Spr_PHFemThermoIf_GetInitialTemp((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public void UpdateVertexTempAll() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemThermoIf_UpdateVertexTempAll((IntPtr) _thisArray[phSceneIf.sceneForStep]);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemThermoIf_UpdateVertexTempAll((IntPtr) _thisArray[phSceneIf.sceneForGet]);
				}
			}
		} else {
	    SprExport.Spr_PHFemThermoIf_UpdateVertexTempAll((IntPtr) _thisArray[0]);
		}
		throw new InvalidOperationException();
	}
	public void SetThermoCameraScale(double minTemp, double maxTemp) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemThermoIf_SetThermoCameraScale((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) minTemp, (double) maxTemp);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemThermoIf_SetThermoCameraScale((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) minTemp, (double) maxTemp);
				}
			}
		} else {
	    SprExport.Spr_PHFemThermoIf_SetThermoCameraScale((IntPtr) _thisArray[0], (double) minTemp, (double) maxTemp);
		}
		throw new InvalidOperationException();
	}
    }
    public partial class PHFemPorousWOMoveIf : PHFemBaseIf {
	public PHFemPorousWOMoveIf() { _thisArray[0] = SprExport.Spr_new_PHFemPorousWOMoveIf(); _flag = true; }
	public PHFemPorousWOMoveIf(IntPtr ptr) : base(ptr) {}
	public PHFemPorousWOMoveIf(IntPtr ptr, bool flag) : base(ptr, flag) {}
	public static implicit operator PHFemPorousWOMoveIf(CsCastObject target) {
		return (target._info.Inherit(PHFemPorousWOMoveIf.GetIfInfoStatic()) ? new PHFemPorousWOMoveIf(target._thisArray[0], target._flag) : null);
	}
	~PHFemPorousWOMoveIf() { if (_flag) { SprExport.Spr_delete_PHFemPorousWOMoveIf(_thisArray[0]); _flag = false; } }
        public override string ToString() {
            IntPtr ptr = SprExport.Spr_PHFemPorousWOMoveIf_ToString((IntPtr) _thisArray[0]);
            string bstr = Marshal.PtrToStringBSTR(ptr);
            SprExport.Spr_PHFemPorousWOMoveIf_FreeString((IntPtr) ptr);
            return bstr;
        }
	public IfInfo GetIfInfo() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHFemPorousWOMoveIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new IfInfo(ptr);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHFemPorousWOMoveIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new IfInfo(ptr);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHFemPorousWOMoveIf_GetIfInfo((IntPtr) _thisArray[0]);
            return new IfInfo(ptr);
		}
		throw new InvalidOperationException();
	}
	public static IfInfo GetIfInfoStatic() {
	    IntPtr ptr = SprExport.Spr_PHFemPorousWOMoveIf_GetIfInfoStatic();
            return new IfInfo(ptr);
	}
	public void SetTimeStep(double dt) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemPorousWOMoveIf_SetTimeStep((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) dt);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemPorousWOMoveIf_SetTimeStep((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) dt);
				}
			}
		} else {
	    SprExport.Spr_PHFemPorousWOMoveIf_SetTimeStep((IntPtr) _thisArray[0], (double) dt);
		}
		throw new InvalidOperationException();
	}
	public double GetTimeStep() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    double result = (double) SprExport.Spr_PHFemPorousWOMoveIf_GetTimeStep((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    double result = (double) SprExport.Spr_PHFemPorousWOMoveIf_GetTimeStep((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    double result = (double) SprExport.Spr_PHFemPorousWOMoveIf_GetTimeStep((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public void UpdateVertexRhoWAll() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemPorousWOMoveIf_UpdateVertexRhoWAll((IntPtr) _thisArray[phSceneIf.sceneForStep]);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemPorousWOMoveIf_UpdateVertexRhoWAll((IntPtr) _thisArray[phSceneIf.sceneForGet]);
				}
			}
		} else {
	    SprExport.Spr_PHFemPorousWOMoveIf_UpdateVertexRhoWAll((IntPtr) _thisArray[0]);
		}
		throw new InvalidOperationException();
	}
	public void UpdateVertexRhoOAll() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemPorousWOMoveIf_UpdateVertexRhoOAll((IntPtr) _thisArray[phSceneIf.sceneForStep]);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemPorousWOMoveIf_UpdateVertexRhoOAll((IntPtr) _thisArray[phSceneIf.sceneForGet]);
				}
			}
		} else {
	    SprExport.Spr_PHFemPorousWOMoveIf_UpdateVertexRhoOAll((IntPtr) _thisArray[0]);
		}
		throw new InvalidOperationException();
	}
	public void SetVertexMw(uint vtxid, double mw) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemPorousWOMoveIf_SetVertexMw((IntPtr) _thisArray[phSceneIf.sceneForStep], (uint) vtxid, (double) mw);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemPorousWOMoveIf_SetVertexMw((IntPtr) _thisArray[phSceneIf.sceneForGet], (uint) vtxid, (double) mw);
				}
			}
		} else {
	    SprExport.Spr_PHFemPorousWOMoveIf_SetVertexMw((IntPtr) _thisArray[0], (uint) vtxid, (double) mw);
		}
		throw new InvalidOperationException();
	}
	public void SetVertexMo(uint vtxid, double mo) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemPorousWOMoveIf_SetVertexMo((IntPtr) _thisArray[phSceneIf.sceneForStep], (uint) vtxid, (double) mo);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemPorousWOMoveIf_SetVertexMo((IntPtr) _thisArray[phSceneIf.sceneForGet], (uint) vtxid, (double) mo);
				}
			}
		} else {
	    SprExport.Spr_PHFemPorousWOMoveIf_SetVertexMo((IntPtr) _thisArray[0], (uint) vtxid, (double) mo);
		}
		throw new InvalidOperationException();
	}
	public double GetVertexMw(uint vtxid) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    double result = (double) SprExport.Spr_PHFemPorousWOMoveIf_GetVertexMw((IntPtr) _thisArray[phSceneIf.sceneForStep], (uint) vtxid);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    double result = (double) SprExport.Spr_PHFemPorousWOMoveIf_GetVertexMw((IntPtr) _thisArray[phSceneIf.sceneForGet], (uint) vtxid);
	    return result;
				}
			}
		} else {
	    double result = (double) SprExport.Spr_PHFemPorousWOMoveIf_GetVertexMw((IntPtr) _thisArray[0], (uint) vtxid);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public double GetVertexMo(uint vtxid) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    double result = (double) SprExport.Spr_PHFemPorousWOMoveIf_GetVertexMo((IntPtr) _thisArray[phSceneIf.sceneForStep], (uint) vtxid);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    double result = (double) SprExport.Spr_PHFemPorousWOMoveIf_GetVertexMo((IntPtr) _thisArray[phSceneIf.sceneForGet], (uint) vtxid);
	    return result;
				}
			}
		} else {
	    double result = (double) SprExport.Spr_PHFemPorousWOMoveIf_GetVertexMo((IntPtr) _thisArray[0], (uint) vtxid);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public double GetVtxWaterInTets(Vec3d temppos) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    double result = (double) SprExport.Spr_PHFemPorousWOMoveIf_GetVtxWaterInTets((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) temppos);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    double result = (double) SprExport.Spr_PHFemPorousWOMoveIf_GetVtxWaterInTets((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) temppos);
	    return result;
				}
			}
		} else {
	    double result = (double) SprExport.Spr_PHFemPorousWOMoveIf_GetVtxWaterInTets((IntPtr) _thisArray[0], (IntPtr) temppos);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public double GetVtxOilInTets(Vec3d temppos) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    double result = (double) SprExport.Spr_PHFemPorousWOMoveIf_GetVtxOilInTets((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) temppos);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    double result = (double) SprExport.Spr_PHFemPorousWOMoveIf_GetVtxOilInTets((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) temppos);
	    return result;
				}
			}
		} else {
	    double result = (double) SprExport.Spr_PHFemPorousWOMoveIf_GetVtxOilInTets((IntPtr) _thisArray[0], (IntPtr) temppos);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public double GetVertexRhoW(uint vtxid) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    double result = (double) SprExport.Spr_PHFemPorousWOMoveIf_GetVertexRhoW((IntPtr) _thisArray[phSceneIf.sceneForStep], (uint) vtxid);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    double result = (double) SprExport.Spr_PHFemPorousWOMoveIf_GetVertexRhoW((IntPtr) _thisArray[phSceneIf.sceneForGet], (uint) vtxid);
	    return result;
				}
			}
		} else {
	    double result = (double) SprExport.Spr_PHFemPorousWOMoveIf_GetVertexRhoW((IntPtr) _thisArray[0], (uint) vtxid);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public double GetVertexRhoO(uint vtxid) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    double result = (double) SprExport.Spr_PHFemPorousWOMoveIf_GetVertexRhoO((IntPtr) _thisArray[phSceneIf.sceneForStep], (uint) vtxid);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    double result = (double) SprExport.Spr_PHFemPorousWOMoveIf_GetVertexRhoO((IntPtr) _thisArray[phSceneIf.sceneForGet], (uint) vtxid);
	    return result;
				}
			}
		} else {
	    double result = (double) SprExport.Spr_PHFemPorousWOMoveIf_GetVertexRhoO((IntPtr) _thisArray[0], (uint) vtxid);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public float calcGvtx(string fwfood, int pv, uint texture_mode) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
            IntPtr remote1 = Marshal.StringToBSTR(fwfood);
	    float result = (float) SprExport.Spr_PHFemPorousWOMoveIf_calcGvtx((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) remote1, (int) pv, (uint) texture_mode);
            Marshal.FreeBSTR(remote1);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
            IntPtr remote1 = Marshal.StringToBSTR(fwfood);
	    float result = (float) SprExport.Spr_PHFemPorousWOMoveIf_calcGvtx((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) remote1, (int) pv, (uint) texture_mode);
            Marshal.FreeBSTR(remote1);
	    return result;
				}
			}
		} else {
            IntPtr remote1 = Marshal.StringToBSTR(fwfood);
	    float result = (float) SprExport.Spr_PHFemPorousWOMoveIf_calcGvtx((IntPtr) _thisArray[0], (IntPtr) remote1, (int) pv, (uint) texture_mode);
            Marshal.FreeBSTR(remote1);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public void setGravity(Vec3d g) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFemPorousWOMoveIf_setGravity((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) g);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFemPorousWOMoveIf_setGravity((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) g);
				}
			}
		} else {
	    SprExport.Spr_PHFemPorousWOMoveIf_setGravity((IntPtr) _thisArray[0], (IntPtr) g);
		}
		throw new InvalidOperationException();
	}
	public double decideWetValue(uint faceid) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    double result = (double) SprExport.Spr_PHFemPorousWOMoveIf_decideWetValue((IntPtr) _thisArray[phSceneIf.sceneForStep], (uint) faceid);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    double result = (double) SprExport.Spr_PHFemPorousWOMoveIf_decideWetValue((IntPtr) _thisArray[phSceneIf.sceneForGet], (uint) faceid);
	    return result;
				}
			}
		} else {
	    double result = (double) SprExport.Spr_PHFemPorousWOMoveIf_decideWetValue((IntPtr) _thisArray[0], (uint) faceid);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public double GetVtxSaturation(uint vtxid) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    double result = (double) SprExport.Spr_PHFemPorousWOMoveIf_GetVtxSaturation((IntPtr) _thisArray[phSceneIf.sceneForStep], (uint) vtxid);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    double result = (double) SprExport.Spr_PHFemPorousWOMoveIf_GetVtxSaturation((IntPtr) _thisArray[phSceneIf.sceneForGet], (uint) vtxid);
	    return result;
				}
			}
		} else {
	    double result = (double) SprExport.Spr_PHFemPorousWOMoveIf_GetVtxSaturation((IntPtr) _thisArray[0], (uint) vtxid);
	    return result;
		}
		throw new InvalidOperationException();
	}
    }
    public partial class PHFrameIf : SceneObjectIf {
	public PHFrameIf() { _thisArray[0] = SprExport.Spr_new_PHFrameIf(); _flag = true; }
	public PHFrameIf(IntPtr ptr) : base(ptr) {}
	public PHFrameIf(IntPtr ptr, bool flag) : base(ptr, flag) {}
	public static implicit operator PHFrameIf(CsCastObject target) {
		return (target._info.Inherit(PHFrameIf.GetIfInfoStatic()) ? new PHFrameIf(target._thisArray[0], target._flag) : null);
	}
	~PHFrameIf() { if (_flag) { SprExport.Spr_delete_PHFrameIf(_thisArray[0]); _flag = false; } }
        public override string ToString() {
            IntPtr ptr = SprExport.Spr_PHFrameIf_ToString((IntPtr) _thisArray[0]);
            string bstr = Marshal.PtrToStringBSTR(ptr);
            SprExport.Spr_PHFrameIf_FreeString((IntPtr) ptr);
            return bstr;
        }
	public IfInfo GetIfInfo() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHFrameIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new IfInfo(ptr);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHFrameIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new IfInfo(ptr);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHFrameIf_GetIfInfo((IntPtr) _thisArray[0]);
            return new IfInfo(ptr);
		}
		throw new InvalidOperationException();
	}
	public static IfInfo GetIfInfoStatic() {
	    IntPtr ptr = SprExport.Spr_PHFrameIf_GetIfInfoStatic();
            return new IfInfo(ptr);
	}
	public Posed GetPose() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHFrameIf_GetPose((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new Posed(ptr, true);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHFrameIf_GetPose((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new Posed(ptr, true);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHFrameIf_GetPose((IntPtr) _thisArray[0]);
            return new Posed(ptr, true);
		}
		throw new InvalidOperationException();
	}
	public void SetPose(Posed p) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHFrameIf_SetPose((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) p);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHFrameIf_SetPose((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) p);
				}
			}
		} else {
	    SprExport.Spr_PHFrameIf_SetPose((IntPtr) _thisArray[0], (IntPtr) p);
		}
		throw new InvalidOperationException();
	}
	public CDShapeIf GetShape() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHFrameIf_GetShape((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            if (ptr == IntPtr.Zero) { return null; } 
            CDShapeIf obj = new CDShapeIf(ptr);
            return obj;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHFrameIf_GetShape((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            if (ptr == IntPtr.Zero) { return null; } 
            CDShapeIf obj = new CDShapeIf(ptr);
            return obj;
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHFrameIf_GetShape((IntPtr) _thisArray[0]);
            if (ptr == IntPtr.Zero) { return null; } 
            CDShapeIf obj = new CDShapeIf(ptr);
            return obj;
		}
		throw new InvalidOperationException();
	}
    }
    public partial class PHBodyIf : SceneObjectIf {
	public PHBodyIf() { _thisArray[0] = SprExport.Spr_new_PHBodyIf(); _flag = true; }
	public PHBodyIf(IntPtr ptr) : base(ptr) {}
	public PHBodyIf(IntPtr ptr, bool flag) : base(ptr, flag) {}
	public static implicit operator PHBodyIf(CsCastObject target) {
		return (target._info.Inherit(PHBodyIf.GetIfInfoStatic()) ? new PHBodyIf(target._thisArray[0], target._flag) : null);
	}
	~PHBodyIf() { if (_flag) { SprExport.Spr_delete_PHBodyIf(_thisArray[0]); _flag = false; } }
        public override string ToString() {
            IntPtr ptr = SprExport.Spr_PHBodyIf_ToString((IntPtr) _thisArray[0]);
            string bstr = Marshal.PtrToStringBSTR(ptr);
            SprExport.Spr_PHBodyIf_FreeString((IntPtr) ptr);
            return bstr;
        }
	public IfInfo GetIfInfo() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHBodyIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new IfInfo(ptr);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHBodyIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new IfInfo(ptr);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHBodyIf_GetIfInfo((IntPtr) _thisArray[0]);
            return new IfInfo(ptr);
		}
		throw new InvalidOperationException();
	}
	public static IfInfo GetIfInfoStatic() {
	    IntPtr ptr = SprExport.Spr_PHBodyIf_GetIfInfoStatic();
            return new IfInfo(ptr);
	}
	public Posed GetPose() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHBodyIf_GetPose((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new Posed(ptr, true);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHBodyIf_GetPose((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new Posed(ptr, true);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHBodyIf_GetPose((IntPtr) _thisArray[0]);
            return new Posed(ptr, true);
		}
		throw new InvalidOperationException();
	}
	public Vec3d GetVelocity() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHBodyIf_GetVelocity((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new Vec3d(ptr, true);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHBodyIf_GetVelocity((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new Vec3d(ptr, true);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHBodyIf_GetVelocity((IntPtr) _thisArray[0]);
            return new Vec3d(ptr, true);
		}
		throw new InvalidOperationException();
	}
	public Vec3d GetAngularVelocity() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHBodyIf_GetAngularVelocity((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new Vec3d(ptr, true);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHBodyIf_GetAngularVelocity((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new Vec3d(ptr, true);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHBodyIf_GetAngularVelocity((IntPtr) _thisArray[0]);
            return new Vec3d(ptr, true);
		}
		throw new InvalidOperationException();
	}
	public Vec3d GetCenterOfMass() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHBodyIf_GetCenterOfMass((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new Vec3d(ptr, true);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHBodyIf_GetCenterOfMass((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new Vec3d(ptr, true);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHBodyIf_GetCenterOfMass((IntPtr) _thisArray[0]);
            return new Vec3d(ptr, true);
		}
		throw new InvalidOperationException();
	}
	public Vec3d GetFramePosition() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHBodyIf_GetFramePosition((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new Vec3d(ptr, true);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHBodyIf_GetFramePosition((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new Vec3d(ptr, true);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHBodyIf_GetFramePosition((IntPtr) _thisArray[0]);
            return new Vec3d(ptr, true);
		}
		throw new InvalidOperationException();
	}
	public Vec3d GetCenterPosition() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHBodyIf_GetCenterPosition((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new Vec3d(ptr, true);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHBodyIf_GetCenterPosition((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new Vec3d(ptr, true);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHBodyIf_GetCenterPosition((IntPtr) _thisArray[0]);
            return new Vec3d(ptr, true);
		}
		throw new InvalidOperationException();
	}
	public bool IsDynamical() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    char ret = SprExport.Spr_PHBodyIf_IsDynamical((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return (ret == 0) ? false : true;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    char ret = SprExport.Spr_PHBodyIf_IsDynamical((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return (ret == 0) ? false : true;
				}
			}
		} else {
	    char ret = SprExport.Spr_PHBodyIf_IsDynamical((IntPtr) _thisArray[0]);
	    return (ret == 0) ? false : true;
		}
		throw new InvalidOperationException();
	}
	public bool IsFrozen() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    char ret = SprExport.Spr_PHBodyIf_IsFrozen((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return (ret == 0) ? false : true;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    char ret = SprExport.Spr_PHBodyIf_IsFrozen((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return (ret == 0) ? false : true;
				}
			}
		} else {
	    char ret = SprExport.Spr_PHBodyIf_IsFrozen((IntPtr) _thisArray[0]);
	    return (ret == 0) ? false : true;
		}
		throw new InvalidOperationException();
	}
	public void AddShape(CDShapeIf shape) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHBodyIf_AddShape((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) shape);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHBodyIf_AddShape((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) shape);
				}
			}
		} else {
	    SprExport.Spr_PHBodyIf_AddShape((IntPtr) _thisArray[0], (IntPtr) shape);
		}
		throw new InvalidOperationException();
	}
	public void AddShapes(CDShapeIf shBegin, CDShapeIf shEnd) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHBodyIf_AddShapes((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) shBegin, (IntPtr) shEnd);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHBodyIf_AddShapes((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) shBegin, (IntPtr) shEnd);
				}
			}
		} else {
	    SprExport.Spr_PHBodyIf_AddShapes((IntPtr) _thisArray[0], (IntPtr) shBegin, (IntPtr) shEnd);
		}
		throw new InvalidOperationException();
	}
	public void RemoveShape(int index) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHBodyIf_RemoveShape((IntPtr) _thisArray[phSceneIf.sceneForStep], (int) index);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHBodyIf_RemoveShape((IntPtr) _thisArray[phSceneIf.sceneForGet], (int) index);
				}
			}
		} else {
	    SprExport.Spr_PHBodyIf_RemoveShape((IntPtr) _thisArray[0], (int) index);
		}
		throw new InvalidOperationException();
	}
	public void RemoveShapes(int idxBegin, int idxEnd) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHBodyIf_RemoveShapes((IntPtr) _thisArray[phSceneIf.sceneForStep], (int) idxBegin, (int) idxEnd);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHBodyIf_RemoveShapes((IntPtr) _thisArray[phSceneIf.sceneForGet], (int) idxBegin, (int) idxEnd);
				}
			}
		} else {
	    SprExport.Spr_PHBodyIf_RemoveShapes((IntPtr) _thisArray[0], (int) idxBegin, (int) idxEnd);
		}
		throw new InvalidOperationException();
	}
	public void RemoveShape(CDShapeIf shape) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHBodyIf_RemoveShape_1((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) shape);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHBodyIf_RemoveShape_1((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) shape);
				}
			}
		} else {
	    SprExport.Spr_PHBodyIf_RemoveShape_1((IntPtr) _thisArray[0], (IntPtr) shape);
		}
		throw new InvalidOperationException();
	}
	public int NShape() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    int result = (int) SprExport.Spr_PHBodyIf_NShape((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    int result = (int) SprExport.Spr_PHBodyIf_NShape((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    int result = (int) SprExport.Spr_PHBodyIf_NShape((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public CDShapeIf GetShape(int index) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHBodyIf_GetShape((IntPtr) _thisArray[phSceneIf.sceneForStep], (int) index);
            if (ptr == IntPtr.Zero) { return null; } 
            CDShapeIf obj = new CDShapeIf(ptr);
            return obj;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHBodyIf_GetShape((IntPtr) _thisArray[phSceneIf.sceneForGet], (int) index);
            if (ptr == IntPtr.Zero) { return null; } 
            CDShapeIf obj = new CDShapeIf(ptr);
            return obj;
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHBodyIf_GetShape((IntPtr) _thisArray[0], (int) index);
            if (ptr == IntPtr.Zero) { return null; } 
            CDShapeIf obj = new CDShapeIf(ptr);
            return obj;
		}
		throw new InvalidOperationException();
	}
	public Posed GetShapePose(int index) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHBodyIf_GetShapePose((IntPtr) _thisArray[phSceneIf.sceneForStep], (int) index);
            return new Posed(ptr, true);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHBodyIf_GetShapePose((IntPtr) _thisArray[phSceneIf.sceneForGet], (int) index);
            return new Posed(ptr, true);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHBodyIf_GetShapePose((IntPtr) _thisArray[0], (int) index);
            return new Posed(ptr, true);
		}
		throw new InvalidOperationException();
	}
	public void SetShapePose(int index, Posed pose) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHBodyIf_SetShapePose((IntPtr) _thisArray[phSceneIf.sceneForStep], (int) index, (IntPtr) pose);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHBodyIf_SetShapePose((IntPtr) _thisArray[phSceneIf.sceneForGet], (int) index, (IntPtr) pose);
				}
			}
		} else {
	    SprExport.Spr_PHBodyIf_SetShapePose((IntPtr) _thisArray[0], (int) index, (IntPtr) pose);
		}
		throw new InvalidOperationException();
	}
	public void ClearShape() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHBodyIf_ClearShape((IntPtr) _thisArray[phSceneIf.sceneForStep]);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHBodyIf_ClearShape((IntPtr) _thisArray[phSceneIf.sceneForGet]);
				}
			}
		} else {
	    SprExport.Spr_PHBodyIf_ClearShape((IntPtr) _thisArray[0]);
		}
		throw new InvalidOperationException();
	}
	public void GetBBox(Vec3d bbmin, Vec3d bbmax, bool world) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHBodyIf_GetBBox((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) bbmin, (IntPtr) bbmax, (bool) world);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHBodyIf_GetBBox((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) bbmin, (IntPtr) bbmax, (bool) world);
				}
			}
		} else {
	    SprExport.Spr_PHBodyIf_GetBBox((IntPtr) _thisArray[0], (IntPtr) bbmin, (IntPtr) bbmax, (bool) world);
		}
		throw new InvalidOperationException();
	}
    }
    public partial class PHSolidIf : PHBodyIf {
	public PHSolidIf() { _thisArray[0] = SprExport.Spr_new_PHSolidIf(); _flag = true; }
	public PHSolidIf(IntPtr ptr) : base(ptr) {}
	public PHSolidIf(IntPtr ptr, bool flag) : base(ptr, flag) {}
	public static implicit operator PHSolidIf(CsCastObject target) {
		return (target._info.Inherit(PHSolidIf.GetIfInfoStatic()) ? new PHSolidIf(target._thisArray[0], target._flag) : null);
	}
	~PHSolidIf() { if (_flag) { SprExport.Spr_delete_PHSolidIf(_thisArray[0]); _flag = false; } }
        public override string ToString() {
            IntPtr ptr = SprExport.Spr_PHSolidIf_ToString((IntPtr) _thisArray[0]);
            string bstr = Marshal.PtrToStringBSTR(ptr);
            SprExport.Spr_PHSolidIf_FreeString((IntPtr) ptr);
            return bstr;
        }
	public IfInfo GetIfInfo() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHSolidIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new IfInfo(ptr);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHSolidIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new IfInfo(ptr);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHSolidIf_GetIfInfo((IntPtr) _thisArray[0]);
            return new IfInfo(ptr);
		}
		throw new InvalidOperationException();
	}
	public static IfInfo GetIfInfoStatic() {
	    IntPtr ptr = SprExport.Spr_PHSolidIf_GetIfInfoStatic();
            return new IfInfo(ptr);
	}
	public void AddForce(Vec3d f) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHSolidIf_AddForce((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) f);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHSolidIf_AddForce((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) f);
				}
			}
		} else {
	    SprExport.Spr_PHSolidIf_AddForce((IntPtr) _thisArray[0], (IntPtr) f);
		}
		throw new InvalidOperationException();
	}
	public void AddTorque(Vec3d t) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHSolidIf_AddTorque((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) t);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHSolidIf_AddTorque((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) t);
				}
			}
		} else {
	    SprExport.Spr_PHSolidIf_AddTorque((IntPtr) _thisArray[0], (IntPtr) t);
		}
		throw new InvalidOperationException();
	}
	public void AddForce(Vec3d f, Vec3d r) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHSolidIf_AddForce_1((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) f, (IntPtr) r);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHSolidIf_AddForce_1((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) f, (IntPtr) r);
				}
			}
		} else {
	    SprExport.Spr_PHSolidIf_AddForce_1((IntPtr) _thisArray[0], (IntPtr) f, (IntPtr) r);
		}
		throw new InvalidOperationException();
	}
	public double GetMass() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    double result = (double) SprExport.Spr_PHSolidIf_GetMass((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    double result = (double) SprExport.Spr_PHSolidIf_GetMass((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    double result = (double) SprExport.Spr_PHSolidIf_GetMass((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public double GetMassInv() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    double result = (double) SprExport.Spr_PHSolidIf_GetMassInv((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    double result = (double) SprExport.Spr_PHSolidIf_GetMassInv((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    double result = (double) SprExport.Spr_PHSolidIf_GetMassInv((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public void SetMass(double m) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHSolidIf_SetMass((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) m);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHSolidIf_SetMass((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) m);
				}
			}
		} else {
	    SprExport.Spr_PHSolidIf_SetMass((IntPtr) _thisArray[0], (double) m);
		}
		throw new InvalidOperationException();
	}
	public void SetCenterOfMass(Vec3d center) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHSolidIf_SetCenterOfMass((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) center);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHSolidIf_SetCenterOfMass((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) center);
				}
			}
		} else {
	    SprExport.Spr_PHSolidIf_SetCenterOfMass((IntPtr) _thisArray[0], (IntPtr) center);
		}
		throw new InvalidOperationException();
	}
	public Matrix3d GetInertia() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHSolidIf_GetInertia((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new Matrix3d(ptr, true);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHSolidIf_GetInertia((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new Matrix3d(ptr, true);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHSolidIf_GetInertia((IntPtr) _thisArray[0]);
            return new Matrix3d(ptr, true);
		}
		throw new InvalidOperationException();
	}
	public Matrix3d GetInertiaInv() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHSolidIf_GetInertiaInv((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new Matrix3d(ptr, true);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHSolidIf_GetInertiaInv((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new Matrix3d(ptr, true);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHSolidIf_GetInertiaInv((IntPtr) _thisArray[0]);
            return new Matrix3d(ptr, true);
		}
		throw new InvalidOperationException();
	}
	public void SetInertia(Matrix3d I) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHSolidIf_SetInertia((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) I);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHSolidIf_SetInertia((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) I);
				}
			}
		} else {
	    SprExport.Spr_PHSolidIf_SetInertia((IntPtr) _thisArray[0], (IntPtr) I);
		}
		throw new InvalidOperationException();
	}
	public void CompInertia() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHSolidIf_CompInertia((IntPtr) _thisArray[phSceneIf.sceneForStep]);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHSolidIf_CompInertia((IntPtr) _thisArray[phSceneIf.sceneForGet]);
				}
			}
		} else {
	    SprExport.Spr_PHSolidIf_CompInertia((IntPtr) _thisArray[0]);
		}
		throw new InvalidOperationException();
	}
	public void SetFramePosition(Vec3d p) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHSolidIf_SetFramePosition((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) p);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHSolidIf_SetFramePosition((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) p);
				}
			}
		} else {
	    SprExport.Spr_PHSolidIf_SetFramePosition((IntPtr) _thisArray[0], (IntPtr) p);
		}
		throw new InvalidOperationException();
	}
	public void SetCenterPosition(Vec3d p) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHSolidIf_SetCenterPosition((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) p);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHSolidIf_SetCenterPosition((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) p);
				}
			}
		} else {
	    SprExport.Spr_PHSolidIf_SetCenterPosition((IntPtr) _thisArray[0], (IntPtr) p);
		}
		throw new InvalidOperationException();
	}
	public Vec3d GetDeltaPosition() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHSolidIf_GetDeltaPosition((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new Vec3d(ptr, true);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHSolidIf_GetDeltaPosition((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new Vec3d(ptr, true);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHSolidIf_GetDeltaPosition((IntPtr) _thisArray[0]);
            return new Vec3d(ptr, true);
		}
		throw new InvalidOperationException();
	}
	public Vec3d GetDeltaPosition(Vec3d p) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHSolidIf_GetDeltaPosition_1((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) p);
            return new Vec3d(ptr, true);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHSolidIf_GetDeltaPosition_1((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) p);
            return new Vec3d(ptr, true);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHSolidIf_GetDeltaPosition_1((IntPtr) _thisArray[0], (IntPtr) p);
            return new Vec3d(ptr, true);
		}
		throw new InvalidOperationException();
	}
	public Quaterniond GetOrientation() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHSolidIf_GetOrientation((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new Quaterniond(ptr, true);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHSolidIf_GetOrientation((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new Quaterniond(ptr, true);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHSolidIf_GetOrientation((IntPtr) _thisArray[0]);
            return new Quaterniond(ptr, true);
		}
		throw new InvalidOperationException();
	}
	public void SetOrientation(Quaterniond q) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHSolidIf_SetOrientation((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) q);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHSolidIf_SetOrientation((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) q);
				}
			}
		} else {
	    SprExport.Spr_PHSolidIf_SetOrientation((IntPtr) _thisArray[0], (IntPtr) q);
		}
		throw new InvalidOperationException();
	}
	public void SetPose(Posed p) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHSolidIf_SetPose((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) p);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHSolidIf_SetPose((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) p);
				}
			}
		} else {
	    SprExport.Spr_PHSolidIf_SetPose((IntPtr) _thisArray[0], (IntPtr) p);
		}
		throw new InvalidOperationException();
	}
	public void SetVelocity(Vec3d v) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHSolidIf_SetVelocity((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) v);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHSolidIf_SetVelocity((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) v);
				}
			}
		} else {
	    SprExport.Spr_PHSolidIf_SetVelocity((IntPtr) _thisArray[0], (IntPtr) v);
		}
		throw new InvalidOperationException();
	}
	public void SetAngularVelocity(Vec3d av) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHSolidIf_SetAngularVelocity((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) av);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHSolidIf_SetAngularVelocity((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) av);
				}
			}
		} else {
	    SprExport.Spr_PHSolidIf_SetAngularVelocity((IntPtr) _thisArray[0], (IntPtr) av);
		}
		throw new InvalidOperationException();
	}
	public Vec3d GetForce() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHSolidIf_GetForce((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new Vec3d(ptr, true);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHSolidIf_GetForce((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new Vec3d(ptr, true);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHSolidIf_GetForce((IntPtr) _thisArray[0]);
            return new Vec3d(ptr, true);
		}
		throw new InvalidOperationException();
	}
	public Vec3d GetTorque() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHSolidIf_GetTorque((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new Vec3d(ptr, true);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHSolidIf_GetTorque((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new Vec3d(ptr, true);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHSolidIf_GetTorque((IntPtr) _thisArray[0]);
            return new Vec3d(ptr, true);
		}
		throw new InvalidOperationException();
	}
	public void SetGravity(bool bOn) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHSolidIf_SetGravity((IntPtr) _thisArray[phSceneIf.sceneForStep], (bool) bOn);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHSolidIf_SetGravity((IntPtr) _thisArray[phSceneIf.sceneForGet], (bool) bOn);
				}
			}
		} else {
	    SprExport.Spr_PHSolidIf_SetGravity((IntPtr) _thisArray[0], (bool) bOn);
		}
		throw new InvalidOperationException();
	}
	public void SetDynamical(bool bOn) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHSolidIf_SetDynamical((IntPtr) _thisArray[phSceneIf.sceneForStep], (bool) bOn);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHSolidIf_SetDynamical((IntPtr) _thisArray[phSceneIf.sceneForGet], (bool) bOn);
				}
			}
		} else {
	    SprExport.Spr_PHSolidIf_SetDynamical((IntPtr) _thisArray[0], (bool) bOn);
		}
		throw new InvalidOperationException();
	}
	public bool IsDynamical() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    char ret = SprExport.Spr_PHSolidIf_IsDynamical((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return (ret == 0) ? false : true;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    char ret = SprExport.Spr_PHSolidIf_IsDynamical((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return (ret == 0) ? false : true;
				}
			}
		} else {
	    char ret = SprExport.Spr_PHSolidIf_IsDynamical((IntPtr) _thisArray[0]);
	    return (ret == 0) ? false : true;
		}
		throw new InvalidOperationException();
	}
	public void SetStationary(bool bOn) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHSolidIf_SetStationary((IntPtr) _thisArray[phSceneIf.sceneForStep], (bool) bOn);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHSolidIf_SetStationary((IntPtr) _thisArray[phSceneIf.sceneForGet], (bool) bOn);
				}
			}
		} else {
	    SprExport.Spr_PHSolidIf_SetStationary((IntPtr) _thisArray[0], (bool) bOn);
		}
		throw new InvalidOperationException();
	}
	public bool IsStationary() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    char ret = SprExport.Spr_PHSolidIf_IsStationary((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return (ret == 0) ? false : true;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    char ret = SprExport.Spr_PHSolidIf_IsStationary((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return (ret == 0) ? false : true;
				}
			}
		} else {
	    char ret = SprExport.Spr_PHSolidIf_IsStationary((IntPtr) _thisArray[0]);
	    return (ret == 0) ? false : true;
		}
		throw new InvalidOperationException();
	}
	public PHTreeNodeIf GetTreeNode() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHSolidIf_GetTreeNode((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            if (ptr == IntPtr.Zero) { return null; } 
            PHTreeNodeIf obj = new PHTreeNodeIf(ptr);
            if (obj.GetIfInfo() == PHRootNodeIf.GetIfInfoStatic()) { return new PHRootNodeIf(ptr); }
            if (obj.GetIfInfo() == PHTreeNode1DIf.GetIfInfoStatic()) { return new PHTreeNode1DIf(ptr); }
            if (obj.GetIfInfo() == PHBallJointNodeIf.GetIfInfoStatic()) { return new PHBallJointNodeIf(ptr); }
            if (obj.GetIfInfo() == PHFixJointNodeIf.GetIfInfoStatic()) { return new PHFixJointNodeIf(ptr); }
            if (obj.GetIfInfo() == PHHingeJointNodeIf.GetIfInfoStatic()) { return new PHHingeJointNodeIf(ptr); }
            if (obj.GetIfInfo() == PHSliderJointNodeIf.GetIfInfoStatic()) { return new PHSliderJointNodeIf(ptr); }
            if (obj.GetIfInfo() == PHPathJointNodeIf.GetIfInfoStatic()) { return new PHPathJointNodeIf(ptr); }
            if (obj.GetIfInfo() == PHGenericJointNodeIf.GetIfInfoStatic()) { return new PHGenericJointNodeIf(ptr); }
            return obj;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHSolidIf_GetTreeNode((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            if (ptr == IntPtr.Zero) { return null; } 
            PHTreeNodeIf obj = new PHTreeNodeIf(ptr);
            if (obj.GetIfInfo() == PHRootNodeIf.GetIfInfoStatic()) { return new PHRootNodeIf(ptr); }
            if (obj.GetIfInfo() == PHTreeNode1DIf.GetIfInfoStatic()) { return new PHTreeNode1DIf(ptr); }
            if (obj.GetIfInfo() == PHBallJointNodeIf.GetIfInfoStatic()) { return new PHBallJointNodeIf(ptr); }
            if (obj.GetIfInfo() == PHFixJointNodeIf.GetIfInfoStatic()) { return new PHFixJointNodeIf(ptr); }
            if (obj.GetIfInfo() == PHHingeJointNodeIf.GetIfInfoStatic()) { return new PHHingeJointNodeIf(ptr); }
            if (obj.GetIfInfo() == PHSliderJointNodeIf.GetIfInfoStatic()) { return new PHSliderJointNodeIf(ptr); }
            if (obj.GetIfInfo() == PHPathJointNodeIf.GetIfInfoStatic()) { return new PHPathJointNodeIf(ptr); }
            if (obj.GetIfInfo() == PHGenericJointNodeIf.GetIfInfoStatic()) { return new PHGenericJointNodeIf(ptr); }
            return obj;
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHSolidIf_GetTreeNode((IntPtr) _thisArray[0]);
            if (ptr == IntPtr.Zero) { return null; } 
            PHTreeNodeIf obj = new PHTreeNodeIf(ptr);
            if (obj.GetIfInfo() == PHRootNodeIf.GetIfInfoStatic()) { return new PHRootNodeIf(ptr); }
            if (obj.GetIfInfo() == PHTreeNode1DIf.GetIfInfoStatic()) { return new PHTreeNode1DIf(ptr); }
            if (obj.GetIfInfo() == PHBallJointNodeIf.GetIfInfoStatic()) { return new PHBallJointNodeIf(ptr); }
            if (obj.GetIfInfo() == PHFixJointNodeIf.GetIfInfoStatic()) { return new PHFixJointNodeIf(ptr); }
            if (obj.GetIfInfo() == PHHingeJointNodeIf.GetIfInfoStatic()) { return new PHHingeJointNodeIf(ptr); }
            if (obj.GetIfInfo() == PHSliderJointNodeIf.GetIfInfoStatic()) { return new PHSliderJointNodeIf(ptr); }
            if (obj.GetIfInfo() == PHPathJointNodeIf.GetIfInfoStatic()) { return new PHPathJointNodeIf(ptr); }
            if (obj.GetIfInfo() == PHGenericJointNodeIf.GetIfInfoStatic()) { return new PHGenericJointNodeIf(ptr); }
            return obj;
		}
		throw new InvalidOperationException();
	}
    }
    public partial class PHShapePairForLCPIf : CDShapePairIf {
	public PHShapePairForLCPIf() { _thisArray[0] = SprExport.Spr_new_PHShapePairForLCPIf(); _flag = true; }
	public PHShapePairForLCPIf(IntPtr ptr) : base(ptr) {}
	public PHShapePairForLCPIf(IntPtr ptr, bool flag) : base(ptr, flag) {}
	public static implicit operator PHShapePairForLCPIf(CsCastObject target) {
		return (target._info.Inherit(PHShapePairForLCPIf.GetIfInfoStatic()) ? new PHShapePairForLCPIf(target._thisArray[0], target._flag) : null);
	}
	~PHShapePairForLCPIf() { if (_flag) { SprExport.Spr_delete_PHShapePairForLCPIf(_thisArray[0]); _flag = false; } }
        public override string ToString() {
            IntPtr ptr = SprExport.Spr_PHShapePairForLCPIf_ToString((IntPtr) _thisArray[0]);
            string bstr = Marshal.PtrToStringBSTR(ptr);
            SprExport.Spr_PHShapePairForLCPIf_FreeString((IntPtr) ptr);
            return bstr;
        }
	public IfInfo GetIfInfo() {
	    IntPtr ptr = SprExport.Spr_PHShapePairForLCPIf_GetIfInfo((IntPtr) _thisArray[0]);
            return new IfInfo(ptr);
	}
	public static IfInfo GetIfInfoStatic() {
	    IntPtr ptr = SprExport.Spr_PHShapePairForLCPIf_GetIfInfoStatic();
            return new IfInfo(ptr);
	}
	public int NSectionVertexes() {
	    int result = (int) SprExport.Spr_PHShapePairForLCPIf_NSectionVertexes((IntPtr) _thisArray[0]);
	    return result;
	}
	public Vec3d GetSectionVertex(int i) {
	    IntPtr ptr = SprExport.Spr_PHShapePairForLCPIf_GetSectionVertex((IntPtr) _thisArray[0], (int) i);
            return new Vec3d(ptr, true);
	}
	public double GetContactDimension() {
	    double result = (double) SprExport.Spr_PHShapePairForLCPIf_GetContactDimension((IntPtr) _thisArray[0]);
	    return result;
	}
	public Vec3d GetNormalVector() {
	    IntPtr ptr = SprExport.Spr_PHShapePairForLCPIf_GetNormalVector((IntPtr) _thisArray[0]);
            return new Vec3d(ptr, true);
	}
	public void GetClosestPoints(Vec3d pa, Vec3d pb) {
	    SprExport.Spr_PHShapePairForLCPIf_GetClosestPoints((IntPtr) _thisArray[0], (IntPtr) pa, (IntPtr) pb);
	}
	public CDShapeIf GetShape(int i) {
	    IntPtr ptr = SprExport.Spr_PHShapePairForLCPIf_GetShape((IntPtr) _thisArray[0], (int) i);
            if (ptr == IntPtr.Zero) { return null; } 
            CDShapeIf obj = new CDShapeIf(ptr);
            return obj;
	}
    }
    public partial class PHSolidPairIf : ObjectIf {
	public PHSolidPairIf() { _thisArray[0] = SprExport.Spr_new_PHSolidPairIf(); _flag = true; }
	public PHSolidPairIf(IntPtr ptr) : base(ptr) {}
	public PHSolidPairIf(IntPtr ptr, bool flag) : base(ptr, flag) {}
	public static implicit operator PHSolidPairIf(CsCastObject target) {
		return (target._info.Inherit(PHSolidPairIf.GetIfInfoStatic()) ? new PHSolidPairIf(target._thisArray[0], target._flag) : null);
	}
	~PHSolidPairIf() { if (_flag) { SprExport.Spr_delete_PHSolidPairIf(_thisArray[0]); _flag = false; } }
        public override string ToString() {
            IntPtr ptr = SprExport.Spr_PHSolidPairIf_ToString((IntPtr) _thisArray[0]);
            string bstr = Marshal.PtrToStringBSTR(ptr);
            SprExport.Spr_PHSolidPairIf_FreeString((IntPtr) ptr);
            return bstr;
        }
	public IfInfo GetIfInfo() {
	    IntPtr ptr = SprExport.Spr_PHSolidPairIf_GetIfInfo((IntPtr) _thisArray[0]);
            return new IfInfo(ptr);
	}
	public static IfInfo GetIfInfoStatic() {
	    IntPtr ptr = SprExport.Spr_PHSolidPairIf_GetIfInfoStatic();
            return new IfInfo(ptr);
	}
	public PHSolidIf GetSolid(int i) {
	    IntPtr ptr = SprExport.Spr_PHSolidPairIf_GetSolid((IntPtr) _thisArray[0], (int) i);
            if (ptr == IntPtr.Zero) { return null; } 
            PHSolidIf obj = new PHSolidIf(ptr);
            if (obj.GetIfInfo() == PHHapticPointerIf.GetIfInfoStatic()) { return new PHHapticPointerIf(ptr); }
            return obj;
	}
	public int NListener() {
	    int result = (int) SprExport.Spr_PHSolidPairIf_NListener((IntPtr) _thisArray[0]);
	    return result;
	}
	public PHCollisionListener GetListener(int i) {
	    IntPtr ptr = SprExport.Spr_PHSolidPairIf_GetListener((IntPtr) _thisArray[0], (int) i);
            return new PHCollisionListener(ptr);
	}
	public void RemoveListener(int i) {
	    SprExport.Spr_PHSolidPairIf_RemoveListener((IntPtr) _thisArray[0], (int) i);
	}
	public void AddListener(PHCollisionListener l, int pos) {
	    SprExport.Spr_PHSolidPairIf_AddListener((IntPtr) _thisArray[0], (IntPtr) l, (int) pos);
	}
	public void AddListener(PHCollisionListener l) {
	    SprExport.Spr_PHSolidPairIf_AddListener_1((IntPtr) _thisArray[0], (IntPtr) l);
	}
    }
    public partial class PHSolidPairForLCPIf : PHSolidPairIf {
	public PHSolidPairForLCPIf() { _thisArray[0] = SprExport.Spr_new_PHSolidPairForLCPIf(); _flag = true; }
	public PHSolidPairForLCPIf(IntPtr ptr) : base(ptr) {}
	public PHSolidPairForLCPIf(IntPtr ptr, bool flag) : base(ptr, flag) {}
	public static implicit operator PHSolidPairForLCPIf(CsCastObject target) {
		return (target._info.Inherit(PHSolidPairForLCPIf.GetIfInfoStatic()) ? new PHSolidPairForLCPIf(target._thisArray[0], target._flag) : null);
	}
	~PHSolidPairForLCPIf() { if (_flag) { SprExport.Spr_delete_PHSolidPairForLCPIf(_thisArray[0]); _flag = false; } }
        public override string ToString() {
            IntPtr ptr = SprExport.Spr_PHSolidPairForLCPIf_ToString((IntPtr) _thisArray[0]);
            string bstr = Marshal.PtrToStringBSTR(ptr);
            SprExport.Spr_PHSolidPairForLCPIf_FreeString((IntPtr) ptr);
            return bstr;
        }
	public IfInfo GetIfInfo() {
	    IntPtr ptr = SprExport.Spr_PHSolidPairForLCPIf_GetIfInfo((IntPtr) _thisArray[0]);
            return new IfInfo(ptr);
	}
	public static IfInfo GetIfInfoStatic() {
	    IntPtr ptr = SprExport.Spr_PHSolidPairForLCPIf_GetIfInfoStatic();
            return new IfInfo(ptr);
	}
	public bool IsContactEnabled() {
	    char ret = SprExport.Spr_PHSolidPairForLCPIf_IsContactEnabled((IntPtr) _thisArray[0]);
	    return (ret == 0) ? false : true;
	}
	public void EnableContact(bool enable) {
	    SprExport.Spr_PHSolidPairForLCPIf_EnableContact((IntPtr) _thisArray[0], (bool) enable);
	}
	public int GetContactState(int i, int j) {
	    int result = (int) SprExport.Spr_PHSolidPairForLCPIf_GetContactState((IntPtr) _thisArray[0], (int) i, (int) j);
	    return result;
	}
	public Vec3d GetCommonPoint(int i, int j) {
	    IntPtr ptr = SprExport.Spr_PHSolidPairForLCPIf_GetCommonPoint((IntPtr) _thisArray[0], (int) i, (int) j);
            return new Vec3d(ptr, true);
	}
	public uint GetLastContactCount(int i, int j) {
	    uint result = (uint) SprExport.Spr_PHSolidPairForLCPIf_GetLastContactCount((IntPtr) _thisArray[0], (int) i, (int) j);
	    return result;
	}
	public double GetContactDepth(int i, int j) {
	    double result = (double) SprExport.Spr_PHSolidPairForLCPIf_GetContactDepth((IntPtr) _thisArray[0], (int) i, (int) j);
	    return result;
	}
	public PHShapePairForLCPIf GetShapePair(int i, int j) {
	    IntPtr ptr = SprExport.Spr_PHSolidPairForLCPIf_GetShapePair((IntPtr) _thisArray[0], (int) i, (int) j);
            if (ptr == IntPtr.Zero) { return null; } 
            PHShapePairForLCPIf obj = new PHShapePairForLCPIf(ptr);
            return obj;
	}
    }
    public partial class PHHapticPointerIf : PHSolidIf {
	public PHHapticPointerIf() { _thisArray[0] = SprExport.Spr_new_PHHapticPointerIf(); _flag = true; }
	public PHHapticPointerIf(IntPtr ptr) : base(ptr) {}
	public PHHapticPointerIf(IntPtr ptr, bool flag) : base(ptr, flag) {}
	public static implicit operator PHHapticPointerIf(CsCastObject target) {
		return (target._info.Inherit(PHHapticPointerIf.GetIfInfoStatic()) ? new PHHapticPointerIf(target._thisArray[0], target._flag) : null);
	}
	~PHHapticPointerIf() { if (_flag) { SprExport.Spr_delete_PHHapticPointerIf(_thisArray[0]); _flag = false; } }
        public override string ToString() {
            IntPtr ptr = SprExport.Spr_PHHapticPointerIf_ToString((IntPtr) _thisArray[0]);
            string bstr = Marshal.PtrToStringBSTR(ptr);
            SprExport.Spr_PHHapticPointerIf_FreeString((IntPtr) ptr);
            return bstr;
        }
	public IfInfo GetIfInfo() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHHapticPointerIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new IfInfo(ptr);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHHapticPointerIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new IfInfo(ptr);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHHapticPointerIf_GetIfInfo((IntPtr) _thisArray[0]);
            return new IfInfo(ptr);
		}
		throw new InvalidOperationException();
	}
	public static IfInfo GetIfInfoStatic() {
	    IntPtr ptr = SprExport.Spr_PHHapticPointerIf_GetIfInfoStatic();
            return new IfInfo(ptr);
	}
	public void SetHapticRenderMode(PHHapticPointerDesc.HapticRenderMode m) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHHapticPointerIf_SetHapticRenderMode((IntPtr) _thisArray[phSceneIf.sceneForStep], (int) m);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHHapticPointerIf_SetHapticRenderMode((IntPtr) _thisArray[phSceneIf.sceneForGet], (int) m);
				}
			}
		} else {
	    SprExport.Spr_PHHapticPointerIf_SetHapticRenderMode((IntPtr) _thisArray[0], (int) m);
		}
		throw new InvalidOperationException();
	}
	public PHHapticPointerDesc.HapticRenderMode GetHapticRenderMode() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    int result = SprExport.Spr_PHHapticPointerIf_GetHapticRenderMode((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return (PHHapticPointerDesc.HapticRenderMode) result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    int result = SprExport.Spr_PHHapticPointerIf_GetHapticRenderMode((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return (PHHapticPointerDesc.HapticRenderMode) result;
				}
			}
		} else {
	    int result = SprExport.Spr_PHHapticPointerIf_GetHapticRenderMode((IntPtr) _thisArray[0]);
            return (PHHapticPointerDesc.HapticRenderMode) result;
		}
		throw new InvalidOperationException();
	}
	public void EnableRotation(bool b) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHHapticPointerIf_EnableRotation((IntPtr) _thisArray[phSceneIf.sceneForStep], (bool) b);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHHapticPointerIf_EnableRotation((IntPtr) _thisArray[phSceneIf.sceneForGet], (bool) b);
				}
			}
		} else {
	    SprExport.Spr_PHHapticPointerIf_EnableRotation((IntPtr) _thisArray[0], (bool) b);
		}
		throw new InvalidOperationException();
	}
	public bool IsRotation() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    char ret = SprExport.Spr_PHHapticPointerIf_IsRotation((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return (ret == 0) ? false : true;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    char ret = SprExport.Spr_PHHapticPointerIf_IsRotation((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return (ret == 0) ? false : true;
				}
			}
		} else {
	    char ret = SprExport.Spr_PHHapticPointerIf_IsRotation((IntPtr) _thisArray[0]);
	    return (ret == 0) ? false : true;
		}
		throw new InvalidOperationException();
	}
	public void EnableForce(bool b) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHHapticPointerIf_EnableForce((IntPtr) _thisArray[phSceneIf.sceneForStep], (bool) b);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHHapticPointerIf_EnableForce((IntPtr) _thisArray[phSceneIf.sceneForGet], (bool) b);
				}
			}
		} else {
	    SprExport.Spr_PHHapticPointerIf_EnableForce((IntPtr) _thisArray[0], (bool) b);
		}
		throw new InvalidOperationException();
	}
	public bool IsForce() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    char ret = SprExport.Spr_PHHapticPointerIf_IsForce((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return (ret == 0) ? false : true;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    char ret = SprExport.Spr_PHHapticPointerIf_IsForce((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return (ret == 0) ? false : true;
				}
			}
		} else {
	    char ret = SprExport.Spr_PHHapticPointerIf_IsForce((IntPtr) _thisArray[0]);
	    return (ret == 0) ? false : true;
		}
		throw new InvalidOperationException();
	}
	public void EnableFriction(bool b) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHHapticPointerIf_EnableFriction((IntPtr) _thisArray[phSceneIf.sceneForStep], (bool) b);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHHapticPointerIf_EnableFriction((IntPtr) _thisArray[phSceneIf.sceneForGet], (bool) b);
				}
			}
		} else {
	    SprExport.Spr_PHHapticPointerIf_EnableFriction((IntPtr) _thisArray[0], (bool) b);
		}
		throw new InvalidOperationException();
	}
	public bool IsFriction() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    char ret = SprExport.Spr_PHHapticPointerIf_IsFriction((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return (ret == 0) ? false : true;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    char ret = SprExport.Spr_PHHapticPointerIf_IsFriction((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return (ret == 0) ? false : true;
				}
			}
		} else {
	    char ret = SprExport.Spr_PHHapticPointerIf_IsFriction((IntPtr) _thisArray[0]);
	    return (ret == 0) ? false : true;
		}
		throw new InvalidOperationException();
	}
	public void EnableTimeVaryFriction(bool b) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHHapticPointerIf_EnableTimeVaryFriction((IntPtr) _thisArray[phSceneIf.sceneForStep], (bool) b);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHHapticPointerIf_EnableTimeVaryFriction((IntPtr) _thisArray[phSceneIf.sceneForGet], (bool) b);
				}
			}
		} else {
	    SprExport.Spr_PHHapticPointerIf_EnableTimeVaryFriction((IntPtr) _thisArray[0], (bool) b);
		}
		throw new InvalidOperationException();
	}
	public bool IsTimeVaryFriction() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    char ret = SprExport.Spr_PHHapticPointerIf_IsTimeVaryFriction((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return (ret == 0) ? false : true;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    char ret = SprExport.Spr_PHHapticPointerIf_IsTimeVaryFriction((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return (ret == 0) ? false : true;
				}
			}
		} else {
	    char ret = SprExport.Spr_PHHapticPointerIf_IsTimeVaryFriction((IntPtr) _thisArray[0]);
	    return (ret == 0) ? false : true;
		}
		throw new InvalidOperationException();
	}
	public void EnableVibration(bool b) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHHapticPointerIf_EnableVibration((IntPtr) _thisArray[phSceneIf.sceneForStep], (bool) b);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHHapticPointerIf_EnableVibration((IntPtr) _thisArray[phSceneIf.sceneForGet], (bool) b);
				}
			}
		} else {
	    SprExport.Spr_PHHapticPointerIf_EnableVibration((IntPtr) _thisArray[0], (bool) b);
		}
		throw new InvalidOperationException();
	}
	public bool IsVibration() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    char ret = SprExport.Spr_PHHapticPointerIf_IsVibration((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return (ret == 0) ? false : true;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    char ret = SprExport.Spr_PHHapticPointerIf_IsVibration((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return (ret == 0) ? false : true;
				}
			}
		} else {
	    char ret = SprExport.Spr_PHHapticPointerIf_IsVibration((IntPtr) _thisArray[0]);
	    return (ret == 0) ? false : true;
		}
		throw new InvalidOperationException();
	}
	public void EnableMultiPoints(bool b) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHHapticPointerIf_EnableMultiPoints((IntPtr) _thisArray[phSceneIf.sceneForStep], (bool) b);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHHapticPointerIf_EnableMultiPoints((IntPtr) _thisArray[phSceneIf.sceneForGet], (bool) b);
				}
			}
		} else {
	    SprExport.Spr_PHHapticPointerIf_EnableMultiPoints((IntPtr) _thisArray[0], (bool) b);
		}
		throw new InvalidOperationException();
	}
	public bool IsMultiPoints() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    char ret = SprExport.Spr_PHHapticPointerIf_IsMultiPoints((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return (ret == 0) ? false : true;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    char ret = SprExport.Spr_PHHapticPointerIf_IsMultiPoints((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return (ret == 0) ? false : true;
				}
			}
		} else {
	    char ret = SprExport.Spr_PHHapticPointerIf_IsMultiPoints((IntPtr) _thisArray[0]);
	    return (ret == 0) ? false : true;
		}
		throw new InvalidOperationException();
	}
	public void EnableMultiProxy(bool b) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHHapticPointerIf_EnableMultiProxy((IntPtr) _thisArray[phSceneIf.sceneForStep], (bool) b);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHHapticPointerIf_EnableMultiProxy((IntPtr) _thisArray[phSceneIf.sceneForGet], (bool) b);
				}
			}
		} else {
	    SprExport.Spr_PHHapticPointerIf_EnableMultiProxy((IntPtr) _thisArray[0], (bool) b);
		}
		throw new InvalidOperationException();
	}
	public bool IsMultiProxy() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    char ret = SprExport.Spr_PHHapticPointerIf_IsMultiProxy((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return (ret == 0) ? false : true;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    char ret = SprExport.Spr_PHHapticPointerIf_IsMultiProxy((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return (ret == 0) ? false : true;
				}
			}
		} else {
	    char ret = SprExport.Spr_PHHapticPointerIf_IsMultiProxy((IntPtr) _thisArray[0]);
	    return (ret == 0) ? false : true;
		}
		throw new InvalidOperationException();
	}
	public void EnableSimulation(bool b) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHHapticPointerIf_EnableSimulation((IntPtr) _thisArray[phSceneIf.sceneForStep], (bool) b);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHHapticPointerIf_EnableSimulation((IntPtr) _thisArray[phSceneIf.sceneForGet], (bool) b);
				}
			}
		} else {
	    SprExport.Spr_PHHapticPointerIf_EnableSimulation((IntPtr) _thisArray[0], (bool) b);
		}
		throw new InvalidOperationException();
	}
	public bool IsSimulation() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    char ret = SprExport.Spr_PHHapticPointerIf_IsSimulation((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return (ret == 0) ? false : true;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    char ret = SprExport.Spr_PHHapticPointerIf_IsSimulation((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return (ret == 0) ? false : true;
				}
			}
		} else {
	    char ret = SprExport.Spr_PHHapticPointerIf_IsSimulation((IntPtr) _thisArray[0]);
	    return (ret == 0) ? false : true;
		}
		throw new InvalidOperationException();
	}
	public void SetFrictionSpring(float s) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHHapticPointerIf_SetFrictionSpring((IntPtr) _thisArray[phSceneIf.sceneForStep], (float) s);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHHapticPointerIf_SetFrictionSpring((IntPtr) _thisArray[phSceneIf.sceneForGet], (float) s);
				}
			}
		} else {
	    SprExport.Spr_PHHapticPointerIf_SetFrictionSpring((IntPtr) _thisArray[0], (float) s);
		}
		throw new InvalidOperationException();
	}
	public float GetFrictionSpring() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    float result = (float) SprExport.Spr_PHHapticPointerIf_GetFrictionSpring((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    float result = (float) SprExport.Spr_PHHapticPointerIf_GetFrictionSpring((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    float result = (float) SprExport.Spr_PHHapticPointerIf_GetFrictionSpring((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public void SetFrictionDamper(float s) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHHapticPointerIf_SetFrictionDamper((IntPtr) _thisArray[phSceneIf.sceneForStep], (float) s);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHHapticPointerIf_SetFrictionDamper((IntPtr) _thisArray[phSceneIf.sceneForGet], (float) s);
				}
			}
		} else {
	    SprExport.Spr_PHHapticPointerIf_SetFrictionDamper((IntPtr) _thisArray[0], (float) s);
		}
		throw new InvalidOperationException();
	}
	public float GetFrictionDamper() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    float result = (float) SprExport.Spr_PHHapticPointerIf_GetFrictionDamper((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    float result = (float) SprExport.Spr_PHHapticPointerIf_GetFrictionDamper((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    float result = (float) SprExport.Spr_PHHapticPointerIf_GetFrictionDamper((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public void SetReflexSpring(float s) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHHapticPointerIf_SetReflexSpring((IntPtr) _thisArray[phSceneIf.sceneForStep], (float) s);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHHapticPointerIf_SetReflexSpring((IntPtr) _thisArray[phSceneIf.sceneForGet], (float) s);
				}
			}
		} else {
	    SprExport.Spr_PHHapticPointerIf_SetReflexSpring((IntPtr) _thisArray[0], (float) s);
		}
		throw new InvalidOperationException();
	}
	public float GetReflexSpring() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    float result = (float) SprExport.Spr_PHHapticPointerIf_GetReflexSpring((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    float result = (float) SprExport.Spr_PHHapticPointerIf_GetReflexSpring((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    float result = (float) SprExport.Spr_PHHapticPointerIf_GetReflexSpring((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public void SetReflexDamper(float d) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHHapticPointerIf_SetReflexDamper((IntPtr) _thisArray[phSceneIf.sceneForStep], (float) d);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHHapticPointerIf_SetReflexDamper((IntPtr) _thisArray[phSceneIf.sceneForGet], (float) d);
				}
			}
		} else {
	    SprExport.Spr_PHHapticPointerIf_SetReflexDamper((IntPtr) _thisArray[0], (float) d);
		}
		throw new InvalidOperationException();
	}
	public float GetReflexDamper() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    float result = (float) SprExport.Spr_PHHapticPointerIf_GetReflexDamper((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    float result = (float) SprExport.Spr_PHHapticPointerIf_GetReflexDamper((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    float result = (float) SprExport.Spr_PHHapticPointerIf_GetReflexDamper((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public void SetRotationReflexSpring(float s) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHHapticPointerIf_SetRotationReflexSpring((IntPtr) _thisArray[phSceneIf.sceneForStep], (float) s);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHHapticPointerIf_SetRotationReflexSpring((IntPtr) _thisArray[phSceneIf.sceneForGet], (float) s);
				}
			}
		} else {
	    SprExport.Spr_PHHapticPointerIf_SetRotationReflexSpring((IntPtr) _thisArray[0], (float) s);
		}
		throw new InvalidOperationException();
	}
	public float GetRotationReflexSpring() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    float result = (float) SprExport.Spr_PHHapticPointerIf_GetRotationReflexSpring((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    float result = (float) SprExport.Spr_PHHapticPointerIf_GetRotationReflexSpring((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    float result = (float) SprExport.Spr_PHHapticPointerIf_GetRotationReflexSpring((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public void SetRotationReflexDamper(float d) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHHapticPointerIf_SetRotationReflexDamper((IntPtr) _thisArray[phSceneIf.sceneForStep], (float) d);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHHapticPointerIf_SetRotationReflexDamper((IntPtr) _thisArray[phSceneIf.sceneForGet], (float) d);
				}
			}
		} else {
	    SprExport.Spr_PHHapticPointerIf_SetRotationReflexDamper((IntPtr) _thisArray[0], (float) d);
		}
		throw new InvalidOperationException();
	}
	public float GetRotationReflexDamper() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    float result = (float) SprExport.Spr_PHHapticPointerIf_GetRotationReflexDamper((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    float result = (float) SprExport.Spr_PHHapticPointerIf_GetRotationReflexDamper((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    float result = (float) SprExport.Spr_PHHapticPointerIf_GetRotationReflexDamper((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public void SetLocalRange(float r) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHHapticPointerIf_SetLocalRange((IntPtr) _thisArray[phSceneIf.sceneForStep], (float) r);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHHapticPointerIf_SetLocalRange((IntPtr) _thisArray[phSceneIf.sceneForGet], (float) r);
				}
			}
		} else {
	    SprExport.Spr_PHHapticPointerIf_SetLocalRange((IntPtr) _thisArray[0], (float) r);
		}
		throw new InvalidOperationException();
	}
	public float GetLocalRange() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    float result = (float) SprExport.Spr_PHHapticPointerIf_GetLocalRange((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    float result = (float) SprExport.Spr_PHHapticPointerIf_GetLocalRange((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    float result = (float) SprExport.Spr_PHHapticPointerIf_GetLocalRange((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public void SetPosScale(double scale) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHHapticPointerIf_SetPosScale((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) scale);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHHapticPointerIf_SetPosScale((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) scale);
				}
			}
		} else {
	    SprExport.Spr_PHHapticPointerIf_SetPosScale((IntPtr) _thisArray[0], (double) scale);
		}
		throw new InvalidOperationException();
	}
	public double GetPosScale() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    double result = (double) SprExport.Spr_PHHapticPointerIf_GetPosScale((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    double result = (double) SprExport.Spr_PHHapticPointerIf_GetPosScale((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    double result = (double) SprExport.Spr_PHHapticPointerIf_GetPosScale((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public void SetRotationalWeight(double w) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHHapticPointerIf_SetRotationalWeight((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) w);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHHapticPointerIf_SetRotationalWeight((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) w);
				}
			}
		} else {
	    SprExport.Spr_PHHapticPointerIf_SetRotationalWeight((IntPtr) _thisArray[0], (double) w);
		}
		throw new InvalidOperationException();
	}
	public double GetRotationalWeight() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    double result = (double) SprExport.Spr_PHHapticPointerIf_GetRotationalWeight((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    double result = (double) SprExport.Spr_PHHapticPointerIf_GetRotationalWeight((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    double result = (double) SprExport.Spr_PHHapticPointerIf_GetRotationalWeight((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public void SetDefaultPose(Posed p) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHHapticPointerIf_SetDefaultPose((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) p);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHHapticPointerIf_SetDefaultPose((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) p);
				}
			}
		} else {
	    SprExport.Spr_PHHapticPointerIf_SetDefaultPose((IntPtr) _thisArray[0], (IntPtr) p);
		}
		throw new InvalidOperationException();
	}
	public Posed GetDefaultPose() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHHapticPointerIf_GetDefaultPose((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new Posed(ptr, true);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHHapticPointerIf_GetDefaultPose((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new Posed(ptr, true);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHHapticPointerIf_GetDefaultPose((IntPtr) _thisArray[0]);
            return new Posed(ptr, true);
		}
		throw new InvalidOperationException();
	}
	public int NNeighborSolids() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    int result = (int) SprExport.Spr_PHHapticPointerIf_NNeighborSolids((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    int result = (int) SprExport.Spr_PHHapticPointerIf_NNeighborSolids((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    int result = (int) SprExport.Spr_PHHapticPointerIf_NNeighborSolids((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public int GetNeighborSolidId(int i) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    int result = (int) SprExport.Spr_PHHapticPointerIf_GetNeighborSolidId((IntPtr) _thisArray[phSceneIf.sceneForStep], (int) i);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    int result = (int) SprExport.Spr_PHHapticPointerIf_GetNeighborSolidId((IntPtr) _thisArray[phSceneIf.sceneForGet], (int) i);
	    return result;
				}
			}
		} else {
	    int result = (int) SprExport.Spr_PHHapticPointerIf_GetNeighborSolidId((IntPtr) _thisArray[0], (int) i);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public PHSolidIf GetNeighborSolid(int i) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHHapticPointerIf_GetNeighborSolid((IntPtr) _thisArray[phSceneIf.sceneForStep], (int) i);
            if (ptr == IntPtr.Zero) { return null; } 
            PHSolidIf obj = new PHSolidIf(ptr);
            if (obj.GetIfInfo() == PHHapticPointerIf.GetIfInfoStatic()) { return new PHHapticPointerIf(ptr); }
            return obj;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHHapticPointerIf_GetNeighborSolid((IntPtr) _thisArray[phSceneIf.sceneForGet], (int) i);
            if (ptr == IntPtr.Zero) { return null; } 
            PHSolidIf obj = new PHSolidIf(ptr);
            if (obj.GetIfInfo() == PHHapticPointerIf.GetIfInfoStatic()) { return new PHHapticPointerIf(ptr); }
            return obj;
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHHapticPointerIf_GetNeighborSolid((IntPtr) _thisArray[0], (int) i);
            if (ptr == IntPtr.Zero) { return null; } 
            PHSolidIf obj = new PHSolidIf(ptr);
            if (obj.GetIfInfo() == PHHapticPointerIf.GetIfInfoStatic()) { return new PHHapticPointerIf(ptr); }
            return obj;
		}
		throw new InvalidOperationException();
	}
	public float GetContactForce(int i) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    float result = (float) SprExport.Spr_PHHapticPointerIf_GetContactForce((IntPtr) _thisArray[phSceneIf.sceneForStep], (int) i);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    float result = (float) SprExport.Spr_PHHapticPointerIf_GetContactForce((IntPtr) _thisArray[phSceneIf.sceneForGet], (int) i);
	    return result;
				}
			}
		} else {
	    float result = (float) SprExport.Spr_PHHapticPointerIf_GetContactForce((IntPtr) _thisArray[0], (int) i);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public SpatialVector GetHapticForce() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHHapticPointerIf_GetHapticForce((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new SpatialVector(ptr, true);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHHapticPointerIf_GetHapticForce((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new SpatialVector(ptr, true);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHHapticPointerIf_GetHapticForce((IntPtr) _thisArray[0]);
            return new SpatialVector(ptr, true);
		}
		throw new InvalidOperationException();
	}
	public SpatialVector GetProxyVelocity() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHHapticPointerIf_GetProxyVelocity((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new SpatialVector(ptr, true);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHHapticPointerIf_GetProxyVelocity((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new SpatialVector(ptr, true);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHHapticPointerIf_GetProxyVelocity((IntPtr) _thisArray[0]);
            return new SpatialVector(ptr, true);
		}
		throw new InvalidOperationException();
	}
	public void SetProxyN(int n) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHHapticPointerIf_SetProxyN((IntPtr) _thisArray[phSceneIf.sceneForStep], (int) n);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHHapticPointerIf_SetProxyN((IntPtr) _thisArray[phSceneIf.sceneForGet], (int) n);
				}
			}
		} else {
	    SprExport.Spr_PHHapticPointerIf_SetProxyN((IntPtr) _thisArray[0], (int) n);
		}
		throw new InvalidOperationException();
	}
	public int GetProxyN() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    int result = (int) SprExport.Spr_PHHapticPointerIf_GetProxyN((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    int result = (int) SprExport.Spr_PHHapticPointerIf_GetProxyN((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    int result = (int) SprExport.Spr_PHHapticPointerIf_GetProxyN((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public int GetTotalSlipState() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    int result = (int) SprExport.Spr_PHHapticPointerIf_GetTotalSlipState((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    int result = (int) SprExport.Spr_PHHapticPointerIf_GetTotalSlipState((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    int result = (int) SprExport.Spr_PHHapticPointerIf_GetTotalSlipState((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public int GetSlipState(int i) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    int result = (int) SprExport.Spr_PHHapticPointerIf_GetSlipState((IntPtr) _thisArray[phSceneIf.sceneForStep], (int) i);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    int result = (int) SprExport.Spr_PHHapticPointerIf_GetSlipState((IntPtr) _thisArray[phSceneIf.sceneForGet], (int) i);
	    return result;
				}
			}
		} else {
	    int result = (int) SprExport.Spr_PHHapticPointerIf_GetSlipState((IntPtr) _thisArray[0], (int) i);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public void SetProxyVelocity(SpatialVector spv) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHHapticPointerIf_SetProxyVelocity((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) spv);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHHapticPointerIf_SetProxyVelocity((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) spv);
				}
			}
		} else {
	    SprExport.Spr_PHHapticPointerIf_SetProxyVelocity((IntPtr) _thisArray[0], (IntPtr) spv);
		}
		throw new InvalidOperationException();
	}
	public void AddHapticForce(SpatialVector f) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHHapticPointerIf_AddHapticForce((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) f);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHHapticPointerIf_AddHapticForce((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) f);
				}
			}
		} else {
	    SprExport.Spr_PHHapticPointerIf_AddHapticForce((IntPtr) _thisArray[0], (IntPtr) f);
		}
		throw new InvalidOperationException();
	}
	public void ClearHapticForce() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHHapticPointerIf_ClearHapticForce((IntPtr) _thisArray[phSceneIf.sceneForStep]);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHHapticPointerIf_ClearHapticForce((IntPtr) _thisArray[phSceneIf.sceneForGet]);
				}
			}
		} else {
	    SprExport.Spr_PHHapticPointerIf_ClearHapticForce((IntPtr) _thisArray[0]);
		}
		throw new InvalidOperationException();
	}
	public void UpdateHumanInterface(Posed pose, SpatialVector vel) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHHapticPointerIf_UpdateHumanInterface((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) pose, (IntPtr) vel);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHHapticPointerIf_UpdateHumanInterface((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) pose, (IntPtr) vel);
				}
			}
		} else {
	    SprExport.Spr_PHHapticPointerIf_UpdateHumanInterface((IntPtr) _thisArray[0], (IntPtr) pose, (IntPtr) vel);
		}
		throw new InvalidOperationException();
	}
    }
    public partial class PHShapePairForHapticIf : CDShapePairIf {
	public PHShapePairForHapticIf() { _thisArray[0] = SprExport.Spr_new_PHShapePairForHapticIf(); _flag = true; }
	public PHShapePairForHapticIf(IntPtr ptr) : base(ptr) {}
	public PHShapePairForHapticIf(IntPtr ptr, bool flag) : base(ptr, flag) {}
	public static implicit operator PHShapePairForHapticIf(CsCastObject target) {
		return (target._info.Inherit(PHShapePairForHapticIf.GetIfInfoStatic()) ? new PHShapePairForHapticIf(target._thisArray[0], target._flag) : null);
	}
	~PHShapePairForHapticIf() { if (_flag) { SprExport.Spr_delete_PHShapePairForHapticIf(_thisArray[0]); _flag = false; } }
        public override string ToString() {
            IntPtr ptr = SprExport.Spr_PHShapePairForHapticIf_ToString((IntPtr) _thisArray[0]);
            string bstr = Marshal.PtrToStringBSTR(ptr);
            SprExport.Spr_PHShapePairForHapticIf_FreeString((IntPtr) ptr);
            return bstr;
        }
	public IfInfo GetIfInfo() {
	    IntPtr ptr = SprExport.Spr_PHShapePairForHapticIf_GetIfInfo((IntPtr) _thisArray[0]);
            return new IfInfo(ptr);
	}
	public static IfInfo GetIfInfoStatic() {
	    IntPtr ptr = SprExport.Spr_PHShapePairForHapticIf_GetIfInfoStatic();
            return new IfInfo(ptr);
	}
	public int NIrs() {
	    int result = (int) SprExport.Spr_PHShapePairForHapticIf_NIrs((IntPtr) _thisArray[0]);
	    return result;
	}
	public int NIrsNormal() {
	    int result = (int) SprExport.Spr_PHShapePairForHapticIf_NIrsNormal((IntPtr) _thisArray[0]);
	    return result;
	}
	public Vec3d GetIrForce(int i) {
	    IntPtr ptr = SprExport.Spr_PHShapePairForHapticIf_GetIrForce((IntPtr) _thisArray[0], (int) i);
            return new Vec3d(ptr, true);
	}
	public double GetMu() {
	    double result = (double) SprExport.Spr_PHShapePairForHapticIf_GetMu((IntPtr) _thisArray[0]);
	    return result;
	}
	public PHFrameIf GetFrame(int i) {
	    IntPtr ptr = SprExport.Spr_PHShapePairForHapticIf_GetFrame((IntPtr) _thisArray[0], (int) i);
            if (ptr == IntPtr.Zero) { return null; } 
            PHFrameIf obj = new PHFrameIf(ptr);
            return obj;
	}
	public void UpdateCache() {
	    SprExport.Spr_PHShapePairForHapticIf_UpdateCache((IntPtr) _thisArray[0]);
	}
	public double GetMus(int id) {
	    double result = (double) SprExport.Spr_PHShapePairForHapticIf_GetMus((IntPtr) _thisArray[0], (int) id);
	    return result;
	}
    }
    public partial class PHSolidPairForHapticIf : PHSolidPairIf {
	public PHSolidPairForHapticIf() { _thisArray[0] = SprExport.Spr_new_PHSolidPairForHapticIf(); _flag = true; }
	public PHSolidPairForHapticIf(IntPtr ptr) : base(ptr) {}
	public PHSolidPairForHapticIf(IntPtr ptr, bool flag) : base(ptr, flag) {}
	public static implicit operator PHSolidPairForHapticIf(CsCastObject target) {
		return (target._info.Inherit(PHSolidPairForHapticIf.GetIfInfoStatic()) ? new PHSolidPairForHapticIf(target._thisArray[0], target._flag) : null);
	}
	~PHSolidPairForHapticIf() { if (_flag) { SprExport.Spr_delete_PHSolidPairForHapticIf(_thisArray[0]); _flag = false; } }
        public override string ToString() {
            IntPtr ptr = SprExport.Spr_PHSolidPairForHapticIf_ToString((IntPtr) _thisArray[0]);
            string bstr = Marshal.PtrToStringBSTR(ptr);
            SprExport.Spr_PHSolidPairForHapticIf_FreeString((IntPtr) ptr);
            return bstr;
        }
	public IfInfo GetIfInfo() {
	    IntPtr ptr = SprExport.Spr_PHSolidPairForHapticIf_GetIfInfo((IntPtr) _thisArray[0]);
            return new IfInfo(ptr);
	}
	public static IfInfo GetIfInfoStatic() {
	    IntPtr ptr = SprExport.Spr_PHSolidPairForHapticIf_GetIfInfoStatic();
            return new IfInfo(ptr);
	}
	public PHShapePairForHapticIf GetShapePair(int i, int j) {
	    IntPtr ptr = SprExport.Spr_PHSolidPairForHapticIf_GetShapePair((IntPtr) _thisArray[0], (int) i, (int) j);
            if (ptr == IntPtr.Zero) { return null; } 
            PHShapePairForHapticIf obj = new PHShapePairForHapticIf(ptr);
            return obj;
	}
	public FrictionState GetFrictionState() {
	    int result = SprExport.Spr_PHSolidPairForHapticIf_GetFrictionState((IntPtr) _thisArray[0]);
            return (PHSolidPairForHapticIf.FrictionState) result;
	}
	public uint GetContactCount() {
	    uint result = (uint) SprExport.Spr_PHSolidPairForHapticIf_GetContactCount((IntPtr) _thisArray[0]);
	    return result;
	}
	public uint GetFrictionCount() {
	    uint result = (uint) SprExport.Spr_PHSolidPairForHapticIf_GetFrictionCount((IntPtr) _thisArray[0]);
	    return result;
	}
	public void InitFrictionState(int n) {
	    SprExport.Spr_PHSolidPairForHapticIf_InitFrictionState((IntPtr) _thisArray[0], (int) n);
	}
	public void InitFrictionCount(int n) {
	    SprExport.Spr_PHSolidPairForHapticIf_InitFrictionCount((IntPtr) _thisArray[0], (int) n);
	}
	public void InitContactCount(int n) {
	    SprExport.Spr_PHSolidPairForHapticIf_InitContactCount((IntPtr) _thisArray[0], (int) n);
	}
	public void InitSlipState(int n) {
	    SprExport.Spr_PHSolidPairForHapticIf_InitSlipState((IntPtr) _thisArray[0], (int) n);
	}
	public int GetSlipState(int i) {
	    int result = (int) SprExport.Spr_PHSolidPairForHapticIf_GetSlipState((IntPtr) _thisArray[0], (int) i);
	    return result;
	}
	public Vec3d GetForce() {
	    IntPtr ptr = SprExport.Spr_PHSolidPairForHapticIf_GetForce((IntPtr) _thisArray[0]);
            return new Vec3d(ptr, true);
	}
	public Vec3d GetTorque() {
	    IntPtr ptr = SprExport.Spr_PHSolidPairForHapticIf_GetTorque((IntPtr) _thisArray[0]);
            return new Vec3d(ptr, true);
	}
	public FrictionState GetFrictionStates(int i) {
	    int result = SprExport.Spr_PHSolidPairForHapticIf_GetFrictionStates((IntPtr) _thisArray[0], (int) i);
            return (PHSolidPairForHapticIf.FrictionState) result;
	}
	public enum FrictionState : int {
	    FREE = 0, STATIC = FREE + 1, DYNAMIC = STATIC + 1
	}
    }
    public partial class PHHapticEngineIf : PHEngineIf {
	public PHHapticEngineIf() { _thisArray[0] = SprExport.Spr_new_PHHapticEngineIf(); _flag = true; }
	public PHHapticEngineIf(IntPtr ptr) : base(ptr) {}
	public PHHapticEngineIf(IntPtr ptr, bool flag) : base(ptr, flag) {}
	public static implicit operator PHHapticEngineIf(CsCastObject target) {
		return (target._info.Inherit(PHHapticEngineIf.GetIfInfoStatic()) ? new PHHapticEngineIf(target._thisArray[0], target._flag) : null);
	}
	~PHHapticEngineIf() { if (_flag) { SprExport.Spr_delete_PHHapticEngineIf(_thisArray[0]); _flag = false; } }
        public override string ToString() {
            IntPtr ptr = SprExport.Spr_PHHapticEngineIf_ToString((IntPtr) _thisArray[0]);
            string bstr = Marshal.PtrToStringBSTR(ptr);
            SprExport.Spr_PHHapticEngineIf_FreeString((IntPtr) ptr);
            return bstr;
        }
	public IfInfo GetIfInfo() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHHapticEngineIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new IfInfo(ptr);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHHapticEngineIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new IfInfo(ptr);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHHapticEngineIf_GetIfInfo((IntPtr) _thisArray[0]);
            return new IfInfo(ptr);
		}
		throw new InvalidOperationException();
	}
	public static IfInfo GetIfInfoStatic() {
	    IntPtr ptr = SprExport.Spr_PHHapticEngineIf_GetIfInfoStatic();
            return new IfInfo(ptr);
	}
	public void SetHapticStepMode(PHHapticEngineDesc.HapticStepMode mode) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHHapticEngineIf_SetHapticStepMode((IntPtr) _thisArray[phSceneIf.sceneForStep], (int) mode);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHHapticEngineIf_SetHapticStepMode((IntPtr) _thisArray[phSceneIf.sceneForGet], (int) mode);
				}
			}
		} else {
	    SprExport.Spr_PHHapticEngineIf_SetHapticStepMode((IntPtr) _thisArray[0], (int) mode);
		}
		throw new InvalidOperationException();
	}
	public PHHapticEngineDesc.HapticStepMode GetHapticStepMode() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    int result = SprExport.Spr_PHHapticEngineIf_GetHapticStepMode((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return (PHHapticEngineDesc.HapticStepMode) result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    int result = SprExport.Spr_PHHapticEngineIf_GetHapticStepMode((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return (PHHapticEngineDesc.HapticStepMode) result;
				}
			}
		} else {
	    int result = SprExport.Spr_PHHapticEngineIf_GetHapticStepMode((IntPtr) _thisArray[0]);
            return (PHHapticEngineDesc.HapticStepMode) result;
		}
		throw new InvalidOperationException();
	}
	public int NSolids() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    int result = (int) SprExport.Spr_PHHapticEngineIf_NSolids((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    int result = (int) SprExport.Spr_PHHapticEngineIf_NSolids((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    int result = (int) SprExport.Spr_PHHapticEngineIf_NSolids((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public int NPointers() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    int result = (int) SprExport.Spr_PHHapticEngineIf_NPointers((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    int result = (int) SprExport.Spr_PHHapticEngineIf_NPointers((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    int result = (int) SprExport.Spr_PHHapticEngineIf_NPointers((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public PHHapticPointerIf GetPointer(int i) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHHapticEngineIf_GetPointer((IntPtr) _thisArray[phSceneIf.sceneForStep], (int) i);
            if (ptr == IntPtr.Zero) { return null; } 
            PHHapticPointerIf obj = new PHHapticPointerIf(ptr);
            return obj;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHHapticEngineIf_GetPointer((IntPtr) _thisArray[phSceneIf.sceneForGet], (int) i);
            if (ptr == IntPtr.Zero) { return null; } 
            PHHapticPointerIf obj = new PHHapticPointerIf(ptr);
            return obj;
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHHapticEngineIf_GetPointer((IntPtr) _thisArray[0], (int) i);
            if (ptr == IntPtr.Zero) { return null; } 
            PHHapticPointerIf obj = new PHHapticPointerIf(ptr);
            return obj;
		}
		throw new InvalidOperationException();
	}
	public PHSolidPairForHapticIf GetSolidPair(int i, int j) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHHapticEngineIf_GetSolidPair((IntPtr) _thisArray[phSceneIf.sceneForStep], (int) i, (int) j);
            if (ptr == IntPtr.Zero) { return null; } 
            PHSolidPairForHapticIf obj = new PHSolidPairForHapticIf(ptr);
            return obj;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHHapticEngineIf_GetSolidPair((IntPtr) _thisArray[phSceneIf.sceneForGet], (int) i, (int) j);
            if (ptr == IntPtr.Zero) { return null; } 
            PHSolidPairForHapticIf obj = new PHSolidPairForHapticIf(ptr);
            return obj;
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHHapticEngineIf_GetSolidPair((IntPtr) _thisArray[0], (int) i, (int) j);
            if (ptr == IntPtr.Zero) { return null; } 
            PHSolidPairForHapticIf obj = new PHSolidPairForHapticIf(ptr);
            return obj;
		}
		throw new InvalidOperationException();
	}
	public int NSolidsInHaptic() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    int result = (int) SprExport.Spr_PHHapticEngineIf_NSolidsInHaptic((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    int result = (int) SprExport.Spr_PHHapticEngineIf_NSolidsInHaptic((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    int result = (int) SprExport.Spr_PHHapticEngineIf_NSolidsInHaptic((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public int NPointersInHaptic() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    int result = (int) SprExport.Spr_PHHapticEngineIf_NPointersInHaptic((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    int result = (int) SprExport.Spr_PHHapticEngineIf_NPointersInHaptic((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    int result = (int) SprExport.Spr_PHHapticEngineIf_NPointersInHaptic((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public PHHapticPointerIf GetPointerInHaptic(int i) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHHapticEngineIf_GetPointerInHaptic((IntPtr) _thisArray[phSceneIf.sceneForStep], (int) i);
            if (ptr == IntPtr.Zero) { return null; } 
            PHHapticPointerIf obj = new PHHapticPointerIf(ptr);
            return obj;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHHapticEngineIf_GetPointerInHaptic((IntPtr) _thisArray[phSceneIf.sceneForGet], (int) i);
            if (ptr == IntPtr.Zero) { return null; } 
            PHHapticPointerIf obj = new PHHapticPointerIf(ptr);
            return obj;
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHHapticEngineIf_GetPointerInHaptic((IntPtr) _thisArray[0], (int) i);
            if (ptr == IntPtr.Zero) { return null; } 
            PHHapticPointerIf obj = new PHHapticPointerIf(ptr);
            return obj;
		}
		throw new InvalidOperationException();
	}
	public PHSolidPairForHapticIf GetSolidPairInHaptic(int i, int j) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHHapticEngineIf_GetSolidPairInHaptic((IntPtr) _thisArray[phSceneIf.sceneForStep], (int) i, (int) j);
            if (ptr == IntPtr.Zero) { return null; } 
            PHSolidPairForHapticIf obj = new PHSolidPairForHapticIf(ptr);
            return obj;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHHapticEngineIf_GetSolidPairInHaptic((IntPtr) _thisArray[phSceneIf.sceneForGet], (int) i, (int) j);
            if (ptr == IntPtr.Zero) { return null; } 
            PHSolidPairForHapticIf obj = new PHSolidPairForHapticIf(ptr);
            return obj;
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHHapticEngineIf_GetSolidPairInHaptic((IntPtr) _thisArray[0], (int) i, (int) j);
            if (ptr == IntPtr.Zero) { return null; } 
            PHSolidPairForHapticIf obj = new PHSolidPairForHapticIf(ptr);
            return obj;
		}
		throw new InvalidOperationException();
	}
	public void StepPhysicsSimulation() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHHapticEngineIf_StepPhysicsSimulation((IntPtr) _thisArray[phSceneIf.sceneForStep]);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHHapticEngineIf_StepPhysicsSimulation((IntPtr) _thisArray[phSceneIf.sceneForGet]);
				}
			}
		} else {
	    SprExport.Spr_PHHapticEngineIf_StepPhysicsSimulation((IntPtr) _thisArray[0]);
		}
		throw new InvalidOperationException();
	}
	public void ReleaseState() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHHapticEngineIf_ReleaseState((IntPtr) _thisArray[phSceneIf.sceneForStep]);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHHapticEngineIf_ReleaseState((IntPtr) _thisArray[phSceneIf.sceneForGet]);
				}
			}
		} else {
	    SprExport.Spr_PHHapticEngineIf_ReleaseState((IntPtr) _thisArray[0]);
		}
		throw new InvalidOperationException();
	}
	public IntPtr Callback(CsObject arg) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr result = (IntPtr) SprExport.Spr_PHHapticEngineIf_Callback((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) arg);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr result = (IntPtr) SprExport.Spr_PHHapticEngineIf_Callback((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) arg);
	    return result;
				}
			}
		} else {
	    IntPtr result = (IntPtr) SprExport.Spr_PHHapticEngineIf_Callback((IntPtr) _thisArray[0], (IntPtr) arg);
	    return result;
		}
		throw new InvalidOperationException();
	}
    }
    public partial class PHIKEndEffectorIf : SceneObjectIf {
	public PHIKEndEffectorIf() { _thisArray[0] = SprExport.Spr_new_PHIKEndEffectorIf(); _flag = true; }
	public PHIKEndEffectorIf(IntPtr ptr) : base(ptr) {}
	public PHIKEndEffectorIf(IntPtr ptr, bool flag) : base(ptr, flag) {}
	public static implicit operator PHIKEndEffectorIf(CsCastObject target) {
		return (target._info.Inherit(PHIKEndEffectorIf.GetIfInfoStatic()) ? new PHIKEndEffectorIf(target._thisArray[0], target._flag) : null);
	}
	~PHIKEndEffectorIf() { if (_flag) { SprExport.Spr_delete_PHIKEndEffectorIf(_thisArray[0]); _flag = false; } }
        public override string ToString() {
            IntPtr ptr = SprExport.Spr_PHIKEndEffectorIf_ToString((IntPtr) _thisArray[0]);
            string bstr = Marshal.PtrToStringBSTR(ptr);
            SprExport.Spr_PHIKEndEffectorIf_FreeString((IntPtr) ptr);
            return bstr;
        }
	public IfInfo GetIfInfo() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHIKEndEffectorIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new IfInfo(ptr);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHIKEndEffectorIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new IfInfo(ptr);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHIKEndEffectorIf_GetIfInfo((IntPtr) _thisArray[0]);
            return new IfInfo(ptr);
		}
		throw new InvalidOperationException();
	}
	public static IfInfo GetIfInfoStatic() {
	    IntPtr ptr = SprExport.Spr_PHIKEndEffectorIf_GetIfInfoStatic();
            return new IfInfo(ptr);
	}
	public void SetSolid(PHSolidIf solid) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHIKEndEffectorIf_SetSolid((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) solid);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHIKEndEffectorIf_SetSolid((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) solid);
				}
			}
		} else {
	    SprExport.Spr_PHIKEndEffectorIf_SetSolid((IntPtr) _thisArray[0], (IntPtr) solid);
		}
		throw new InvalidOperationException();
	}
	public PHSolidIf GetSolid() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHIKEndEffectorIf_GetSolid((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            if (ptr == IntPtr.Zero) { return null; } 
            PHSolidIf obj = new PHSolidIf(ptr);
            if (obj.GetIfInfo() == PHHapticPointerIf.GetIfInfoStatic()) { return new PHHapticPointerIf(ptr); }
            return obj;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHIKEndEffectorIf_GetSolid((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            if (ptr == IntPtr.Zero) { return null; } 
            PHSolidIf obj = new PHSolidIf(ptr);
            if (obj.GetIfInfo() == PHHapticPointerIf.GetIfInfoStatic()) { return new PHHapticPointerIf(ptr); }
            return obj;
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHIKEndEffectorIf_GetSolid((IntPtr) _thisArray[0]);
            if (ptr == IntPtr.Zero) { return null; } 
            PHSolidIf obj = new PHSolidIf(ptr);
            if (obj.GetIfInfo() == PHHapticPointerIf.GetIfInfoStatic()) { return new PHHapticPointerIf(ptr); }
            return obj;
		}
		throw new InvalidOperationException();
	}
	public void SetParentActuator(PHIKActuatorIf ika) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHIKEndEffectorIf_SetParentActuator((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) ika);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHIKEndEffectorIf_SetParentActuator((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) ika);
				}
			}
		} else {
	    SprExport.Spr_PHIKEndEffectorIf_SetParentActuator((IntPtr) _thisArray[0], (IntPtr) ika);
		}
		throw new InvalidOperationException();
	}
	public PHIKActuatorIf GetParentActuator() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHIKEndEffectorIf_GetParentActuator((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            if (ptr == IntPtr.Zero) { return null; } 
            PHIKActuatorIf obj = new PHIKActuatorIf(ptr);
            if (obj.GetIfInfo() == PHIKBallActuatorIf.GetIfInfoStatic()) { return new PHIKBallActuatorIf(ptr); }
            if (obj.GetIfInfo() == PHIKHingeActuatorIf.GetIfInfoStatic()) { return new PHIKHingeActuatorIf(ptr); }
            if (obj.GetIfInfo() == PHIKSpringActuatorIf.GetIfInfoStatic()) { return new PHIKSpringActuatorIf(ptr); }
            return obj;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHIKEndEffectorIf_GetParentActuator((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            if (ptr == IntPtr.Zero) { return null; } 
            PHIKActuatorIf obj = new PHIKActuatorIf(ptr);
            if (obj.GetIfInfo() == PHIKBallActuatorIf.GetIfInfoStatic()) { return new PHIKBallActuatorIf(ptr); }
            if (obj.GetIfInfo() == PHIKHingeActuatorIf.GetIfInfoStatic()) { return new PHIKHingeActuatorIf(ptr); }
            if (obj.GetIfInfo() == PHIKSpringActuatorIf.GetIfInfoStatic()) { return new PHIKSpringActuatorIf(ptr); }
            return obj;
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHIKEndEffectorIf_GetParentActuator((IntPtr) _thisArray[0]);
            if (ptr == IntPtr.Zero) { return null; } 
            PHIKActuatorIf obj = new PHIKActuatorIf(ptr);
            if (obj.GetIfInfo() == PHIKBallActuatorIf.GetIfInfoStatic()) { return new PHIKBallActuatorIf(ptr); }
            if (obj.GetIfInfo() == PHIKHingeActuatorIf.GetIfInfoStatic()) { return new PHIKHingeActuatorIf(ptr); }
            if (obj.GetIfInfo() == PHIKSpringActuatorIf.GetIfInfoStatic()) { return new PHIKSpringActuatorIf(ptr); }
            return obj;
		}
		throw new InvalidOperationException();
	}
	public void Enable(bool enable) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHIKEndEffectorIf_Enable((IntPtr) _thisArray[phSceneIf.sceneForStep], (bool) enable);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHIKEndEffectorIf_Enable((IntPtr) _thisArray[phSceneIf.sceneForGet], (bool) enable);
				}
			}
		} else {
	    SprExport.Spr_PHIKEndEffectorIf_Enable((IntPtr) _thisArray[0], (bool) enable);
		}
		throw new InvalidOperationException();
	}
	public bool IsEnabled() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    char ret = SprExport.Spr_PHIKEndEffectorIf_IsEnabled((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return (ret == 0) ? false : true;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    char ret = SprExport.Spr_PHIKEndEffectorIf_IsEnabled((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return (ret == 0) ? false : true;
				}
			}
		} else {
	    char ret = SprExport.Spr_PHIKEndEffectorIf_IsEnabled((IntPtr) _thisArray[0]);
	    return (ret == 0) ? false : true;
		}
		throw new InvalidOperationException();
	}
	public void SetTargetLocalPosition(Vec3d localPosition) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHIKEndEffectorIf_SetTargetLocalPosition((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) localPosition);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHIKEndEffectorIf_SetTargetLocalPosition((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) localPosition);
				}
			}
		} else {
	    SprExport.Spr_PHIKEndEffectorIf_SetTargetLocalPosition((IntPtr) _thisArray[0], (IntPtr) localPosition);
		}
		throw new InvalidOperationException();
	}
	public Vec3d GetTargetLocalPosition() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHIKEndEffectorIf_GetTargetLocalPosition((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new Vec3d(ptr, true);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHIKEndEffectorIf_GetTargetLocalPosition((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new Vec3d(ptr, true);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHIKEndEffectorIf_GetTargetLocalPosition((IntPtr) _thisArray[0]);
            return new Vec3d(ptr, true);
		}
		throw new InvalidOperationException();
	}
	public void SetTargetLocalDirection(Vec3d localDirection) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHIKEndEffectorIf_SetTargetLocalDirection((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) localDirection);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHIKEndEffectorIf_SetTargetLocalDirection((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) localDirection);
				}
			}
		} else {
	    SprExport.Spr_PHIKEndEffectorIf_SetTargetLocalDirection((IntPtr) _thisArray[0], (IntPtr) localDirection);
		}
		throw new InvalidOperationException();
	}
	public Vec3d GetTargetLocalDirection() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHIKEndEffectorIf_GetTargetLocalDirection((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new Vec3d(ptr, true);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHIKEndEffectorIf_GetTargetLocalDirection((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new Vec3d(ptr, true);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHIKEndEffectorIf_GetTargetLocalDirection((IntPtr) _thisArray[0]);
            return new Vec3d(ptr, true);
		}
		throw new InvalidOperationException();
	}
	public void EnablePositionControl(bool enable) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHIKEndEffectorIf_EnablePositionControl((IntPtr) _thisArray[phSceneIf.sceneForStep], (bool) enable);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHIKEndEffectorIf_EnablePositionControl((IntPtr) _thisArray[phSceneIf.sceneForGet], (bool) enable);
				}
			}
		} else {
	    SprExport.Spr_PHIKEndEffectorIf_EnablePositionControl((IntPtr) _thisArray[0], (bool) enable);
		}
		throw new InvalidOperationException();
	}
	public bool IsPositionControlEnabled() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    char ret = SprExport.Spr_PHIKEndEffectorIf_IsPositionControlEnabled((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return (ret == 0) ? false : true;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    char ret = SprExport.Spr_PHIKEndEffectorIf_IsPositionControlEnabled((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return (ret == 0) ? false : true;
				}
			}
		} else {
	    char ret = SprExport.Spr_PHIKEndEffectorIf_IsPositionControlEnabled((IntPtr) _thisArray[0]);
	    return (ret == 0) ? false : true;
		}
		throw new InvalidOperationException();
	}
	public void SetPositionPriority(double priority) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHIKEndEffectorIf_SetPositionPriority((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) priority);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHIKEndEffectorIf_SetPositionPriority((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) priority);
				}
			}
		} else {
	    SprExport.Spr_PHIKEndEffectorIf_SetPositionPriority((IntPtr) _thisArray[0], (double) priority);
		}
		throw new InvalidOperationException();
	}
	public double GetPositionPriority() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    double result = (double) SprExport.Spr_PHIKEndEffectorIf_GetPositionPriority((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    double result = (double) SprExport.Spr_PHIKEndEffectorIf_GetPositionPriority((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    double result = (double) SprExport.Spr_PHIKEndEffectorIf_GetPositionPriority((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public void SetTargetPosition(Vec3d position) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHIKEndEffectorIf_SetTargetPosition((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) position);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHIKEndEffectorIf_SetTargetPosition((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) position);
				}
			}
		} else {
	    SprExport.Spr_PHIKEndEffectorIf_SetTargetPosition((IntPtr) _thisArray[0], (IntPtr) position);
		}
		throw new InvalidOperationException();
	}
	public Vec3d GetTargetPosition() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHIKEndEffectorIf_GetTargetPosition((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new Vec3d(ptr, true);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHIKEndEffectorIf_GetTargetPosition((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new Vec3d(ptr, true);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHIKEndEffectorIf_GetTargetPosition((IntPtr) _thisArray[0]);
            return new Vec3d(ptr, true);
		}
		throw new InvalidOperationException();
	}
	public void EnableOrientationControl(bool enable) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHIKEndEffectorIf_EnableOrientationControl((IntPtr) _thisArray[phSceneIf.sceneForStep], (bool) enable);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHIKEndEffectorIf_EnableOrientationControl((IntPtr) _thisArray[phSceneIf.sceneForGet], (bool) enable);
				}
			}
		} else {
	    SprExport.Spr_PHIKEndEffectorIf_EnableOrientationControl((IntPtr) _thisArray[0], (bool) enable);
		}
		throw new InvalidOperationException();
	}
	public bool IsOrientationControlEnabled() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    char ret = SprExport.Spr_PHIKEndEffectorIf_IsOrientationControlEnabled((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return (ret == 0) ? false : true;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    char ret = SprExport.Spr_PHIKEndEffectorIf_IsOrientationControlEnabled((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return (ret == 0) ? false : true;
				}
			}
		} else {
	    char ret = SprExport.Spr_PHIKEndEffectorIf_IsOrientationControlEnabled((IntPtr) _thisArray[0]);
	    return (ret == 0) ? false : true;
		}
		throw new InvalidOperationException();
	}
	public void SetOrientationPriority(double priority) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHIKEndEffectorIf_SetOrientationPriority((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) priority);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHIKEndEffectorIf_SetOrientationPriority((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) priority);
				}
			}
		} else {
	    SprExport.Spr_PHIKEndEffectorIf_SetOrientationPriority((IntPtr) _thisArray[0], (double) priority);
		}
		throw new InvalidOperationException();
	}
	public double GetOrientationPriority() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    double result = (double) SprExport.Spr_PHIKEndEffectorIf_GetOrientationPriority((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    double result = (double) SprExport.Spr_PHIKEndEffectorIf_GetOrientationPriority((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    double result = (double) SprExport.Spr_PHIKEndEffectorIf_GetOrientationPriority((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public void SetOriCtlMode(PHIKEndEffectorDesc.OriCtlMode mode) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHIKEndEffectorIf_SetOriCtlMode((IntPtr) _thisArray[phSceneIf.sceneForStep], (int) mode);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHIKEndEffectorIf_SetOriCtlMode((IntPtr) _thisArray[phSceneIf.sceneForGet], (int) mode);
				}
			}
		} else {
	    SprExport.Spr_PHIKEndEffectorIf_SetOriCtlMode((IntPtr) _thisArray[0], (int) mode);
		}
		throw new InvalidOperationException();
	}
	public PHIKEndEffectorDesc.OriCtlMode GetOriCtlMode() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    int result = SprExport.Spr_PHIKEndEffectorIf_GetOriCtlMode((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return (PHIKEndEffectorDesc.OriCtlMode) result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    int result = SprExport.Spr_PHIKEndEffectorIf_GetOriCtlMode((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return (PHIKEndEffectorDesc.OriCtlMode) result;
				}
			}
		} else {
	    int result = SprExport.Spr_PHIKEndEffectorIf_GetOriCtlMode((IntPtr) _thisArray[0]);
            return (PHIKEndEffectorDesc.OriCtlMode) result;
		}
		throw new InvalidOperationException();
	}
	public void SetTargetOrientation(Quaterniond orientation) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHIKEndEffectorIf_SetTargetOrientation((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) orientation);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHIKEndEffectorIf_SetTargetOrientation((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) orientation);
				}
			}
		} else {
	    SprExport.Spr_PHIKEndEffectorIf_SetTargetOrientation((IntPtr) _thisArray[0], (IntPtr) orientation);
		}
		throw new InvalidOperationException();
	}
	public Quaterniond GetTargetOrientation() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHIKEndEffectorIf_GetTargetOrientation((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new Quaterniond(ptr, true);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHIKEndEffectorIf_GetTargetOrientation((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new Quaterniond(ptr, true);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHIKEndEffectorIf_GetTargetOrientation((IntPtr) _thisArray[0]);
            return new Quaterniond(ptr, true);
		}
		throw new InvalidOperationException();
	}
	public void SetTargetDirection(Vec3d direction) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHIKEndEffectorIf_SetTargetDirection((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) direction);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHIKEndEffectorIf_SetTargetDirection((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) direction);
				}
			}
		} else {
	    SprExport.Spr_PHIKEndEffectorIf_SetTargetDirection((IntPtr) _thisArray[0], (IntPtr) direction);
		}
		throw new InvalidOperationException();
	}
	public Vec3d GetTargetDirection() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHIKEndEffectorIf_GetTargetDirection((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new Vec3d(ptr, true);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHIKEndEffectorIf_GetTargetDirection((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new Vec3d(ptr, true);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHIKEndEffectorIf_GetTargetDirection((IntPtr) _thisArray[0]);
            return new Vec3d(ptr, true);
		}
		throw new InvalidOperationException();
	}
	public void SetTargetLookat(Vec3d lookat) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHIKEndEffectorIf_SetTargetLookat((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) lookat);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHIKEndEffectorIf_SetTargetLookat((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) lookat);
				}
			}
		} else {
	    SprExport.Spr_PHIKEndEffectorIf_SetTargetLookat((IntPtr) _thisArray[0], (IntPtr) lookat);
		}
		throw new InvalidOperationException();
	}
	public Vec3d GetTargetLookat() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHIKEndEffectorIf_GetTargetLookat((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new Vec3d(ptr, true);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHIKEndEffectorIf_GetTargetLookat((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new Vec3d(ptr, true);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHIKEndEffectorIf_GetTargetLookat((IntPtr) _thisArray[0]);
            return new Vec3d(ptr, true);
		}
		throw new InvalidOperationException();
	}
	public void SetTargetVelocity(Vec3d velocity) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHIKEndEffectorIf_SetTargetVelocity((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) velocity);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHIKEndEffectorIf_SetTargetVelocity((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) velocity);
				}
			}
		} else {
	    SprExport.Spr_PHIKEndEffectorIf_SetTargetVelocity((IntPtr) _thisArray[0], (IntPtr) velocity);
		}
		throw new InvalidOperationException();
	}
	public Vec3d GetTargetVelocity() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHIKEndEffectorIf_GetTargetVelocity((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new Vec3d(ptr, true);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHIKEndEffectorIf_GetTargetVelocity((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new Vec3d(ptr, true);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHIKEndEffectorIf_GetTargetVelocity((IntPtr) _thisArray[0]);
            return new Vec3d(ptr, true);
		}
		throw new InvalidOperationException();
	}
	public void SetTargetAngularVelocity(Vec3d angVel) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHIKEndEffectorIf_SetTargetAngularVelocity((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) angVel);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHIKEndEffectorIf_SetTargetAngularVelocity((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) angVel);
				}
			}
		} else {
	    SprExport.Spr_PHIKEndEffectorIf_SetTargetAngularVelocity((IntPtr) _thisArray[0], (IntPtr) angVel);
		}
		throw new InvalidOperationException();
	}
	public Vec3d GetTargetAngularVelocity() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHIKEndEffectorIf_GetTargetAngularVelocity((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new Vec3d(ptr, true);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHIKEndEffectorIf_GetTargetAngularVelocity((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new Vec3d(ptr, true);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHIKEndEffectorIf_GetTargetAngularVelocity((IntPtr) _thisArray[0]);
            return new Vec3d(ptr, true);
		}
		throw new InvalidOperationException();
	}
	public void EnableForceControl(bool enable) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHIKEndEffectorIf_EnableForceControl((IntPtr) _thisArray[phSceneIf.sceneForStep], (bool) enable);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHIKEndEffectorIf_EnableForceControl((IntPtr) _thisArray[phSceneIf.sceneForGet], (bool) enable);
				}
			}
		} else {
	    SprExport.Spr_PHIKEndEffectorIf_EnableForceControl((IntPtr) _thisArray[0], (bool) enable);
		}
		throw new InvalidOperationException();
	}
	public void SetTargetForce(Vec3d force, Vec3d workingPoint) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHIKEndEffectorIf_SetTargetForce((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) force, (IntPtr) workingPoint);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHIKEndEffectorIf_SetTargetForce((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) force, (IntPtr) workingPoint);
				}
			}
		} else {
	    SprExport.Spr_PHIKEndEffectorIf_SetTargetForce((IntPtr) _thisArray[0], (IntPtr) force, (IntPtr) workingPoint);
		}
		throw new InvalidOperationException();
	}
	public void SetTargetForce(Vec3d force) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHIKEndEffectorIf_SetTargetForce_1((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) force);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHIKEndEffectorIf_SetTargetForce_1((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) force);
				}
			}
		} else {
	    SprExport.Spr_PHIKEndEffectorIf_SetTargetForce_1((IntPtr) _thisArray[0], (IntPtr) force);
		}
		throw new InvalidOperationException();
	}
	public Vec3d GetTargetForce() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHIKEndEffectorIf_GetTargetForce((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new Vec3d(ptr, true);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHIKEndEffectorIf_GetTargetForce((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new Vec3d(ptr, true);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHIKEndEffectorIf_GetTargetForce((IntPtr) _thisArray[0]);
            return new Vec3d(ptr, true);
		}
		throw new InvalidOperationException();
	}
	public Vec3d GetTargetForceWorkingPoint() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHIKEndEffectorIf_GetTargetForceWorkingPoint((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new Vec3d(ptr, true);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHIKEndEffectorIf_GetTargetForceWorkingPoint((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new Vec3d(ptr, true);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHIKEndEffectorIf_GetTargetForceWorkingPoint((IntPtr) _thisArray[0]);
            return new Vec3d(ptr, true);
		}
		throw new InvalidOperationException();
	}
	public void EnableTorqueControl(bool enable) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHIKEndEffectorIf_EnableTorqueControl((IntPtr) _thisArray[phSceneIf.sceneForStep], (bool) enable);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHIKEndEffectorIf_EnableTorqueControl((IntPtr) _thisArray[phSceneIf.sceneForGet], (bool) enable);
				}
			}
		} else {
	    SprExport.Spr_PHIKEndEffectorIf_EnableTorqueControl((IntPtr) _thisArray[0], (bool) enable);
		}
		throw new InvalidOperationException();
	}
	public void SetTargetTorque(Vec3d torque) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHIKEndEffectorIf_SetTargetTorque((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) torque);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHIKEndEffectorIf_SetTargetTorque((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) torque);
				}
			}
		} else {
	    SprExport.Spr_PHIKEndEffectorIf_SetTargetTorque((IntPtr) _thisArray[0], (IntPtr) torque);
		}
		throw new InvalidOperationException();
	}
	public Vec3d GetTargetTorque() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHIKEndEffectorIf_GetTargetTorque((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new Vec3d(ptr, true);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHIKEndEffectorIf_GetTargetTorque((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new Vec3d(ptr, true);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHIKEndEffectorIf_GetTargetTorque((IntPtr) _thisArray[0]);
            return new Vec3d(ptr, true);
		}
		throw new InvalidOperationException();
	}
	public Posed GetSolidTempPose() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHIKEndEffectorIf_GetSolidTempPose((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new Posed(ptr, true);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHIKEndEffectorIf_GetSolidTempPose((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new Posed(ptr, true);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHIKEndEffectorIf_GetSolidTempPose((IntPtr) _thisArray[0]);
            return new Posed(ptr, true);
		}
		throw new InvalidOperationException();
	}
	public void ApplyExactState() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHIKEndEffectorIf_ApplyExactState((IntPtr) _thisArray[phSceneIf.sceneForStep]);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHIKEndEffectorIf_ApplyExactState((IntPtr) _thisArray[phSceneIf.sceneForGet]);
				}
			}
		} else {
	    SprExport.Spr_PHIKEndEffectorIf_ApplyExactState((IntPtr) _thisArray[0]);
		}
		throw new InvalidOperationException();
	}
    }
    public partial class PHIKActuatorIf : SceneObjectIf {
	public PHIKActuatorIf() { _thisArray[0] = SprExport.Spr_new_PHIKActuatorIf(); _flag = true; }
	public PHIKActuatorIf(IntPtr ptr) : base(ptr) {}
	public PHIKActuatorIf(IntPtr ptr, bool flag) : base(ptr, flag) {}
	public static implicit operator PHIKActuatorIf(CsCastObject target) {
		return (target._info.Inherit(PHIKActuatorIf.GetIfInfoStatic()) ? new PHIKActuatorIf(target._thisArray[0], target._flag) : null);
	}
	~PHIKActuatorIf() { if (_flag) { SprExport.Spr_delete_PHIKActuatorIf(_thisArray[0]); _flag = false; } }
        public override string ToString() {
            IntPtr ptr = SprExport.Spr_PHIKActuatorIf_ToString((IntPtr) _thisArray[0]);
            string bstr = Marshal.PtrToStringBSTR(ptr);
            SprExport.Spr_PHIKActuatorIf_FreeString((IntPtr) ptr);
            return bstr;
        }
	public IfInfo GetIfInfo() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHIKActuatorIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new IfInfo(ptr);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHIKActuatorIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new IfInfo(ptr);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHIKActuatorIf_GetIfInfo((IntPtr) _thisArray[0]);
            return new IfInfo(ptr);
		}
		throw new InvalidOperationException();
	}
	public static IfInfo GetIfInfoStatic() {
	    IntPtr ptr = SprExport.Spr_PHIKActuatorIf_GetIfInfoStatic();
            return new IfInfo(ptr);
	}
	public void PrepareSolve() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHIKActuatorIf_PrepareSolve((IntPtr) _thisArray[phSceneIf.sceneForStep]);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHIKActuatorIf_PrepareSolve((IntPtr) _thisArray[phSceneIf.sceneForGet]);
				}
			}
		} else {
	    SprExport.Spr_PHIKActuatorIf_PrepareSolve((IntPtr) _thisArray[0]);
		}
		throw new InvalidOperationException();
	}
	public void ProceedSolve() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHIKActuatorIf_ProceedSolve((IntPtr) _thisArray[phSceneIf.sceneForStep]);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHIKActuatorIf_ProceedSolve((IntPtr) _thisArray[phSceneIf.sceneForGet]);
				}
			}
		} else {
	    SprExport.Spr_PHIKActuatorIf_ProceedSolve((IntPtr) _thisArray[0]);
		}
		throw new InvalidOperationException();
	}
	public void Move() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHIKActuatorIf_Move((IntPtr) _thisArray[phSceneIf.sceneForStep]);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHIKActuatorIf_Move((IntPtr) _thisArray[phSceneIf.sceneForGet]);
				}
			}
		} else {
	    SprExport.Spr_PHIKActuatorIf_Move((IntPtr) _thisArray[0]);
		}
		throw new InvalidOperationException();
	}
	public void ApplyExactState(bool reverse) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHIKActuatorIf_ApplyExactState((IntPtr) _thisArray[phSceneIf.sceneForStep], (bool) reverse);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHIKActuatorIf_ApplyExactState((IntPtr) _thisArray[phSceneIf.sceneForGet], (bool) reverse);
				}
			}
		} else {
	    SprExport.Spr_PHIKActuatorIf_ApplyExactState((IntPtr) _thisArray[0], (bool) reverse);
		}
		throw new InvalidOperationException();
	}
	public void ApplyExactState() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHIKActuatorIf_ApplyExactState_1((IntPtr) _thisArray[phSceneIf.sceneForStep]);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHIKActuatorIf_ApplyExactState_1((IntPtr) _thisArray[phSceneIf.sceneForGet]);
				}
			}
		} else {
	    SprExport.Spr_PHIKActuatorIf_ApplyExactState_1((IntPtr) _thisArray[0]);
		}
		throw new InvalidOperationException();
	}
	public void SetBias(float bias) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHIKActuatorIf_SetBias((IntPtr) _thisArray[phSceneIf.sceneForStep], (float) bias);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHIKActuatorIf_SetBias((IntPtr) _thisArray[phSceneIf.sceneForGet], (float) bias);
				}
			}
		} else {
	    SprExport.Spr_PHIKActuatorIf_SetBias((IntPtr) _thisArray[0], (float) bias);
		}
		throw new InvalidOperationException();
	}
	public float GetBias() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    float result = (float) SprExport.Spr_PHIKActuatorIf_GetBias((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    float result = (float) SprExport.Spr_PHIKActuatorIf_GetBias((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    float result = (float) SprExport.Spr_PHIKActuatorIf_GetBias((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public void SetPullbackRate(double pullbackRate) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHIKActuatorIf_SetPullbackRate((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) pullbackRate);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHIKActuatorIf_SetPullbackRate((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) pullbackRate);
				}
			}
		} else {
	    SprExport.Spr_PHIKActuatorIf_SetPullbackRate((IntPtr) _thisArray[0], (double) pullbackRate);
		}
		throw new InvalidOperationException();
	}
	public double GetPullbackRate() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    double result = (double) SprExport.Spr_PHIKActuatorIf_GetPullbackRate((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    double result = (double) SprExport.Spr_PHIKActuatorIf_GetPullbackRate((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    double result = (double) SprExport.Spr_PHIKActuatorIf_GetPullbackRate((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public void Enable(bool enable) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHIKActuatorIf_Enable((IntPtr) _thisArray[phSceneIf.sceneForStep], (bool) enable);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHIKActuatorIf_Enable((IntPtr) _thisArray[phSceneIf.sceneForGet], (bool) enable);
				}
			}
		} else {
	    SprExport.Spr_PHIKActuatorIf_Enable((IntPtr) _thisArray[0], (bool) enable);
		}
		throw new InvalidOperationException();
	}
	public bool IsEnabled() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    char ret = SprExport.Spr_PHIKActuatorIf_IsEnabled((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return (ret == 0) ? false : true;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    char ret = SprExport.Spr_PHIKActuatorIf_IsEnabled((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return (ret == 0) ? false : true;
				}
			}
		} else {
	    char ret = SprExport.Spr_PHIKActuatorIf_IsEnabled((IntPtr) _thisArray[0]);
	    return (ret == 0) ? false : true;
		}
		throw new InvalidOperationException();
	}
	public int NAncestors() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    int result = (int) SprExport.Spr_PHIKActuatorIf_NAncestors((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    int result = (int) SprExport.Spr_PHIKActuatorIf_NAncestors((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    int result = (int) SprExport.Spr_PHIKActuatorIf_NAncestors((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public PHIKActuatorIf GetAncestor(int i) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHIKActuatorIf_GetAncestor((IntPtr) _thisArray[phSceneIf.sceneForStep], (int) i);
            if (ptr == IntPtr.Zero) { return null; } 
            PHIKActuatorIf obj = new PHIKActuatorIf(ptr);
            if (obj.GetIfInfo() == PHIKBallActuatorIf.GetIfInfoStatic()) { return new PHIKBallActuatorIf(ptr); }
            if (obj.GetIfInfo() == PHIKHingeActuatorIf.GetIfInfoStatic()) { return new PHIKHingeActuatorIf(ptr); }
            if (obj.GetIfInfo() == PHIKSpringActuatorIf.GetIfInfoStatic()) { return new PHIKSpringActuatorIf(ptr); }
            return obj;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHIKActuatorIf_GetAncestor((IntPtr) _thisArray[phSceneIf.sceneForGet], (int) i);
            if (ptr == IntPtr.Zero) { return null; } 
            PHIKActuatorIf obj = new PHIKActuatorIf(ptr);
            if (obj.GetIfInfo() == PHIKBallActuatorIf.GetIfInfoStatic()) { return new PHIKBallActuatorIf(ptr); }
            if (obj.GetIfInfo() == PHIKHingeActuatorIf.GetIfInfoStatic()) { return new PHIKHingeActuatorIf(ptr); }
            if (obj.GetIfInfo() == PHIKSpringActuatorIf.GetIfInfoStatic()) { return new PHIKSpringActuatorIf(ptr); }
            return obj;
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHIKActuatorIf_GetAncestor((IntPtr) _thisArray[0], (int) i);
            if (ptr == IntPtr.Zero) { return null; } 
            PHIKActuatorIf obj = new PHIKActuatorIf(ptr);
            if (obj.GetIfInfo() == PHIKBallActuatorIf.GetIfInfoStatic()) { return new PHIKBallActuatorIf(ptr); }
            if (obj.GetIfInfo() == PHIKHingeActuatorIf.GetIfInfoStatic()) { return new PHIKHingeActuatorIf(ptr); }
            if (obj.GetIfInfo() == PHIKSpringActuatorIf.GetIfInfoStatic()) { return new PHIKSpringActuatorIf(ptr); }
            return obj;
		}
		throw new InvalidOperationException();
	}
	public PHIKActuatorIf GetParent() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHIKActuatorIf_GetParent((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            if (ptr == IntPtr.Zero) { return null; } 
            PHIKActuatorIf obj = new PHIKActuatorIf(ptr);
            if (obj.GetIfInfo() == PHIKBallActuatorIf.GetIfInfoStatic()) { return new PHIKBallActuatorIf(ptr); }
            if (obj.GetIfInfo() == PHIKHingeActuatorIf.GetIfInfoStatic()) { return new PHIKHingeActuatorIf(ptr); }
            if (obj.GetIfInfo() == PHIKSpringActuatorIf.GetIfInfoStatic()) { return new PHIKSpringActuatorIf(ptr); }
            return obj;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHIKActuatorIf_GetParent((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            if (ptr == IntPtr.Zero) { return null; } 
            PHIKActuatorIf obj = new PHIKActuatorIf(ptr);
            if (obj.GetIfInfo() == PHIKBallActuatorIf.GetIfInfoStatic()) { return new PHIKBallActuatorIf(ptr); }
            if (obj.GetIfInfo() == PHIKHingeActuatorIf.GetIfInfoStatic()) { return new PHIKHingeActuatorIf(ptr); }
            if (obj.GetIfInfo() == PHIKSpringActuatorIf.GetIfInfoStatic()) { return new PHIKSpringActuatorIf(ptr); }
            return obj;
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHIKActuatorIf_GetParent((IntPtr) _thisArray[0]);
            if (ptr == IntPtr.Zero) { return null; } 
            PHIKActuatorIf obj = new PHIKActuatorIf(ptr);
            if (obj.GetIfInfo() == PHIKBallActuatorIf.GetIfInfoStatic()) { return new PHIKBallActuatorIf(ptr); }
            if (obj.GetIfInfo() == PHIKHingeActuatorIf.GetIfInfoStatic()) { return new PHIKHingeActuatorIf(ptr); }
            if (obj.GetIfInfo() == PHIKSpringActuatorIf.GetIfInfoStatic()) { return new PHIKSpringActuatorIf(ptr); }
            return obj;
		}
		throw new InvalidOperationException();
	}
	public int NChildActuators() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    int result = (int) SprExport.Spr_PHIKActuatorIf_NChildActuators((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    int result = (int) SprExport.Spr_PHIKActuatorIf_NChildActuators((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    int result = (int) SprExport.Spr_PHIKActuatorIf_NChildActuators((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public PHIKActuatorIf GetChildActuator(int i) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHIKActuatorIf_GetChildActuator((IntPtr) _thisArray[phSceneIf.sceneForStep], (int) i);
            if (ptr == IntPtr.Zero) { return null; } 
            PHIKActuatorIf obj = new PHIKActuatorIf(ptr);
            if (obj.GetIfInfo() == PHIKBallActuatorIf.GetIfInfoStatic()) { return new PHIKBallActuatorIf(ptr); }
            if (obj.GetIfInfo() == PHIKHingeActuatorIf.GetIfInfoStatic()) { return new PHIKHingeActuatorIf(ptr); }
            if (obj.GetIfInfo() == PHIKSpringActuatorIf.GetIfInfoStatic()) { return new PHIKSpringActuatorIf(ptr); }
            return obj;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHIKActuatorIf_GetChildActuator((IntPtr) _thisArray[phSceneIf.sceneForGet], (int) i);
            if (ptr == IntPtr.Zero) { return null; } 
            PHIKActuatorIf obj = new PHIKActuatorIf(ptr);
            if (obj.GetIfInfo() == PHIKBallActuatorIf.GetIfInfoStatic()) { return new PHIKBallActuatorIf(ptr); }
            if (obj.GetIfInfo() == PHIKHingeActuatorIf.GetIfInfoStatic()) { return new PHIKHingeActuatorIf(ptr); }
            if (obj.GetIfInfo() == PHIKSpringActuatorIf.GetIfInfoStatic()) { return new PHIKSpringActuatorIf(ptr); }
            return obj;
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHIKActuatorIf_GetChildActuator((IntPtr) _thisArray[0], (int) i);
            if (ptr == IntPtr.Zero) { return null; } 
            PHIKActuatorIf obj = new PHIKActuatorIf(ptr);
            if (obj.GetIfInfo() == PHIKBallActuatorIf.GetIfInfoStatic()) { return new PHIKBallActuatorIf(ptr); }
            if (obj.GetIfInfo() == PHIKHingeActuatorIf.GetIfInfoStatic()) { return new PHIKHingeActuatorIf(ptr); }
            if (obj.GetIfInfo() == PHIKSpringActuatorIf.GetIfInfoStatic()) { return new PHIKSpringActuatorIf(ptr); }
            return obj;
		}
		throw new InvalidOperationException();
	}
	public PHIKEndEffectorIf GetChildEndEffector() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHIKActuatorIf_GetChildEndEffector((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            if (ptr == IntPtr.Zero) { return null; } 
            PHIKEndEffectorIf obj = new PHIKEndEffectorIf(ptr);
            return obj;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHIKActuatorIf_GetChildEndEffector((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            if (ptr == IntPtr.Zero) { return null; } 
            PHIKEndEffectorIf obj = new PHIKEndEffectorIf(ptr);
            return obj;
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHIKActuatorIf_GetChildEndEffector((IntPtr) _thisArray[0]);
            if (ptr == IntPtr.Zero) { return null; } 
            PHIKEndEffectorIf obj = new PHIKEndEffectorIf(ptr);
            return obj;
		}
		throw new InvalidOperationException();
	}
	public Posed GetSolidTempPose() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHIKActuatorIf_GetSolidTempPose((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new Posed(ptr, true);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHIKActuatorIf_GetSolidTempPose((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new Posed(ptr, true);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHIKActuatorIf_GetSolidTempPose((IntPtr) _thisArray[0]);
            return new Posed(ptr, true);
		}
		throw new InvalidOperationException();
	}
	public Posed GetSolidPullbackPose() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHIKActuatorIf_GetSolidPullbackPose((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new Posed(ptr, true);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHIKActuatorIf_GetSolidPullbackPose((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new Posed(ptr, true);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHIKActuatorIf_GetSolidPullbackPose((IntPtr) _thisArray[0]);
            return new Posed(ptr, true);
		}
		throw new InvalidOperationException();
	}
    }
    public partial class PHIKBallActuatorIf : PHIKActuatorIf {
	public PHIKBallActuatorIf() { _thisArray[0] = SprExport.Spr_new_PHIKBallActuatorIf(); _flag = true; }
	public PHIKBallActuatorIf(IntPtr ptr) : base(ptr) {}
	public PHIKBallActuatorIf(IntPtr ptr, bool flag) : base(ptr, flag) {}
	public static implicit operator PHIKBallActuatorIf(CsCastObject target) {
		return (target._info.Inherit(PHIKBallActuatorIf.GetIfInfoStatic()) ? new PHIKBallActuatorIf(target._thisArray[0], target._flag) : null);
	}
	~PHIKBallActuatorIf() { if (_flag) { SprExport.Spr_delete_PHIKBallActuatorIf(_thisArray[0]); _flag = false; } }
        public override string ToString() {
            IntPtr ptr = SprExport.Spr_PHIKBallActuatorIf_ToString((IntPtr) _thisArray[0]);
            string bstr = Marshal.PtrToStringBSTR(ptr);
            SprExport.Spr_PHIKBallActuatorIf_FreeString((IntPtr) ptr);
            return bstr;
        }
	public IfInfo GetIfInfo() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHIKBallActuatorIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new IfInfo(ptr);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHIKBallActuatorIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new IfInfo(ptr);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHIKBallActuatorIf_GetIfInfo((IntPtr) _thisArray[0]);
            return new IfInfo(ptr);
		}
		throw new InvalidOperationException();
	}
	public static IfInfo GetIfInfoStatic() {
	    IntPtr ptr = SprExport.Spr_PHIKBallActuatorIf_GetIfInfoStatic();
            return new IfInfo(ptr);
	}
	public void SetJoint(PHBallJointIf joint) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHIKBallActuatorIf_SetJoint((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) joint);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHIKBallActuatorIf_SetJoint((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) joint);
				}
			}
		} else {
	    SprExport.Spr_PHIKBallActuatorIf_SetJoint((IntPtr) _thisArray[0], (IntPtr) joint);
		}
		throw new InvalidOperationException();
	}
	public PHBallJointIf GetJoint() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHIKBallActuatorIf_GetJoint((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            if (ptr == IntPtr.Zero) { return null; } 
            PHBallJointIf obj = new PHBallJointIf(ptr);
            return obj;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHIKBallActuatorIf_GetJoint((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            if (ptr == IntPtr.Zero) { return null; } 
            PHBallJointIf obj = new PHBallJointIf(ptr);
            return obj;
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHIKBallActuatorIf_GetJoint((IntPtr) _thisArray[0]);
            if (ptr == IntPtr.Zero) { return null; } 
            PHBallJointIf obj = new PHBallJointIf(ptr);
            return obj;
		}
		throw new InvalidOperationException();
	}
	public void SetJointTempOri(Quaterniond ori) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHIKBallActuatorIf_SetJointTempOri((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) ori);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHIKBallActuatorIf_SetJointTempOri((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) ori);
				}
			}
		} else {
	    SprExport.Spr_PHIKBallActuatorIf_SetJointTempOri((IntPtr) _thisArray[0], (IntPtr) ori);
		}
		throw new InvalidOperationException();
	}
	public void SetPullbackTarget(Quaterniond ori) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHIKBallActuatorIf_SetPullbackTarget((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) ori);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHIKBallActuatorIf_SetPullbackTarget((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) ori);
				}
			}
		} else {
	    SprExport.Spr_PHIKBallActuatorIf_SetPullbackTarget((IntPtr) _thisArray[0], (IntPtr) ori);
		}
		throw new InvalidOperationException();
	}
	public Quaterniond GetJointTempOri() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHIKBallActuatorIf_GetJointTempOri((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new Quaterniond(ptr, true);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHIKBallActuatorIf_GetJointTempOri((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new Quaterniond(ptr, true);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHIKBallActuatorIf_GetJointTempOri((IntPtr) _thisArray[0]);
            return new Quaterniond(ptr, true);
		}
		throw new InvalidOperationException();
	}
	public Quaterniond GetPullbackTarget() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHIKBallActuatorIf_GetPullbackTarget((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new Quaterniond(ptr, true);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHIKBallActuatorIf_GetPullbackTarget((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new Quaterniond(ptr, true);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHIKBallActuatorIf_GetPullbackTarget((IntPtr) _thisArray[0]);
            return new Quaterniond(ptr, true);
		}
		throw new InvalidOperationException();
	}
    }
    public partial class PHIKHingeActuatorIf : PHIKActuatorIf {
	public PHIKHingeActuatorIf() { _thisArray[0] = SprExport.Spr_new_PHIKHingeActuatorIf(); _flag = true; }
	public PHIKHingeActuatorIf(IntPtr ptr) : base(ptr) {}
	public PHIKHingeActuatorIf(IntPtr ptr, bool flag) : base(ptr, flag) {}
	public static implicit operator PHIKHingeActuatorIf(CsCastObject target) {
		return (target._info.Inherit(PHIKHingeActuatorIf.GetIfInfoStatic()) ? new PHIKHingeActuatorIf(target._thisArray[0], target._flag) : null);
	}
	~PHIKHingeActuatorIf() { if (_flag) { SprExport.Spr_delete_PHIKHingeActuatorIf(_thisArray[0]); _flag = false; } }
        public override string ToString() {
            IntPtr ptr = SprExport.Spr_PHIKHingeActuatorIf_ToString((IntPtr) _thisArray[0]);
            string bstr = Marshal.PtrToStringBSTR(ptr);
            SprExport.Spr_PHIKHingeActuatorIf_FreeString((IntPtr) ptr);
            return bstr;
        }
	public IfInfo GetIfInfo() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHIKHingeActuatorIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new IfInfo(ptr);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHIKHingeActuatorIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new IfInfo(ptr);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHIKHingeActuatorIf_GetIfInfo((IntPtr) _thisArray[0]);
            return new IfInfo(ptr);
		}
		throw new InvalidOperationException();
	}
	public static IfInfo GetIfInfoStatic() {
	    IntPtr ptr = SprExport.Spr_PHIKHingeActuatorIf_GetIfInfoStatic();
            return new IfInfo(ptr);
	}
	public void SetJoint(PHHingeJointIf joint) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHIKHingeActuatorIf_SetJoint((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) joint);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHIKHingeActuatorIf_SetJoint((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) joint);
				}
			}
		} else {
	    SprExport.Spr_PHIKHingeActuatorIf_SetJoint((IntPtr) _thisArray[0], (IntPtr) joint);
		}
		throw new InvalidOperationException();
	}
	public PHHingeJointIf GetJoint() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHIKHingeActuatorIf_GetJoint((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            if (ptr == IntPtr.Zero) { return null; } 
            PHHingeJointIf obj = new PHHingeJointIf(ptr);
            return obj;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHIKHingeActuatorIf_GetJoint((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            if (ptr == IntPtr.Zero) { return null; } 
            PHHingeJointIf obj = new PHHingeJointIf(ptr);
            return obj;
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHIKHingeActuatorIf_GetJoint((IntPtr) _thisArray[0]);
            if (ptr == IntPtr.Zero) { return null; } 
            PHHingeJointIf obj = new PHHingeJointIf(ptr);
            return obj;
		}
		throw new InvalidOperationException();
	}
	public void SetJointTempAngle(double angle) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHIKHingeActuatorIf_SetJointTempAngle((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) angle);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHIKHingeActuatorIf_SetJointTempAngle((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) angle);
				}
			}
		} else {
	    SprExport.Spr_PHIKHingeActuatorIf_SetJointTempAngle((IntPtr) _thisArray[0], (double) angle);
		}
		throw new InvalidOperationException();
	}
	public void SetPullbackTarget(double angle) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHIKHingeActuatorIf_SetPullbackTarget((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) angle);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHIKHingeActuatorIf_SetPullbackTarget((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) angle);
				}
			}
		} else {
	    SprExport.Spr_PHIKHingeActuatorIf_SetPullbackTarget((IntPtr) _thisArray[0], (double) angle);
		}
		throw new InvalidOperationException();
	}
	public double GetJointTempAngle() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    double result = (double) SprExport.Spr_PHIKHingeActuatorIf_GetJointTempAngle((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    double result = (double) SprExport.Spr_PHIKHingeActuatorIf_GetJointTempAngle((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    double result = (double) SprExport.Spr_PHIKHingeActuatorIf_GetJointTempAngle((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public double GetPullbackTarget() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    double result = (double) SprExport.Spr_PHIKHingeActuatorIf_GetPullbackTarget((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    double result = (double) SprExport.Spr_PHIKHingeActuatorIf_GetPullbackTarget((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    double result = (double) SprExport.Spr_PHIKHingeActuatorIf_GetPullbackTarget((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
    }
    public partial class PHIKSpringActuatorIf : PHIKActuatorIf {
	public PHIKSpringActuatorIf() { _thisArray[0] = SprExport.Spr_new_PHIKSpringActuatorIf(); _flag = true; }
	public PHIKSpringActuatorIf(IntPtr ptr) : base(ptr) {}
	public PHIKSpringActuatorIf(IntPtr ptr, bool flag) : base(ptr, flag) {}
	public static implicit operator PHIKSpringActuatorIf(CsCastObject target) {
		return (target._info.Inherit(PHIKSpringActuatorIf.GetIfInfoStatic()) ? new PHIKSpringActuatorIf(target._thisArray[0], target._flag) : null);
	}
	~PHIKSpringActuatorIf() { if (_flag) { SprExport.Spr_delete_PHIKSpringActuatorIf(_thisArray[0]); _flag = false; } }
        public override string ToString() {
            IntPtr ptr = SprExport.Spr_PHIKSpringActuatorIf_ToString((IntPtr) _thisArray[0]);
            string bstr = Marshal.PtrToStringBSTR(ptr);
            SprExport.Spr_PHIKSpringActuatorIf_FreeString((IntPtr) ptr);
            return bstr;
        }
	public IfInfo GetIfInfo() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHIKSpringActuatorIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new IfInfo(ptr);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHIKSpringActuatorIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new IfInfo(ptr);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHIKSpringActuatorIf_GetIfInfo((IntPtr) _thisArray[0]);
            return new IfInfo(ptr);
		}
		throw new InvalidOperationException();
	}
	public static IfInfo GetIfInfoStatic() {
	    IntPtr ptr = SprExport.Spr_PHIKSpringActuatorIf_GetIfInfoStatic();
            return new IfInfo(ptr);
	}
	public void SetJoint(PHSpringIf joint) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHIKSpringActuatorIf_SetJoint((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) joint);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHIKSpringActuatorIf_SetJoint((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) joint);
				}
			}
		} else {
	    SprExport.Spr_PHIKSpringActuatorIf_SetJoint((IntPtr) _thisArray[0], (IntPtr) joint);
		}
		throw new InvalidOperationException();
	}
	public PHSpringIf GetJoint() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHIKSpringActuatorIf_GetJoint((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            if (ptr == IntPtr.Zero) { return null; } 
            PHSpringIf obj = new PHSpringIf(ptr);
            return obj;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHIKSpringActuatorIf_GetJoint((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            if (ptr == IntPtr.Zero) { return null; } 
            PHSpringIf obj = new PHSpringIf(ptr);
            return obj;
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHIKSpringActuatorIf_GetJoint((IntPtr) _thisArray[0]);
            if (ptr == IntPtr.Zero) { return null; } 
            PHSpringIf obj = new PHSpringIf(ptr);
            return obj;
		}
		throw new InvalidOperationException();
	}
	public void SetJointTempPose(Posed pose) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHIKSpringActuatorIf_SetJointTempPose((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) pose);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHIKSpringActuatorIf_SetJointTempPose((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) pose);
				}
			}
		} else {
	    SprExport.Spr_PHIKSpringActuatorIf_SetJointTempPose((IntPtr) _thisArray[0], (IntPtr) pose);
		}
		throw new InvalidOperationException();
	}
	public void SetPullbackTarget(Posed pose) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHIKSpringActuatorIf_SetPullbackTarget((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) pose);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHIKSpringActuatorIf_SetPullbackTarget((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) pose);
				}
			}
		} else {
	    SprExport.Spr_PHIKSpringActuatorIf_SetPullbackTarget((IntPtr) _thisArray[0], (IntPtr) pose);
		}
		throw new InvalidOperationException();
	}
	public Posed GetJointTempPose() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHIKSpringActuatorIf_GetJointTempPose((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new Posed(ptr, true);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHIKSpringActuatorIf_GetJointTempPose((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new Posed(ptr, true);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHIKSpringActuatorIf_GetJointTempPose((IntPtr) _thisArray[0]);
            return new Posed(ptr, true);
		}
		throw new InvalidOperationException();
	}
	public Posed GetPullbackTarget() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHIKSpringActuatorIf_GetPullbackTarget((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new Posed(ptr, true);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHIKSpringActuatorIf_GetPullbackTarget((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new Posed(ptr, true);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHIKSpringActuatorIf_GetPullbackTarget((IntPtr) _thisArray[0]);
            return new Posed(ptr, true);
		}
		throw new InvalidOperationException();
	}
    }
    public partial class PHConstraintIf : SceneObjectIf {
	public PHConstraintIf() { _thisArray[0] = SprExport.Spr_new_PHConstraintIf(); _flag = true; }
	public PHConstraintIf(IntPtr ptr) : base(ptr) {}
	public PHConstraintIf(IntPtr ptr, bool flag) : base(ptr, flag) {}
	public static implicit operator PHConstraintIf(CsCastObject target) {
		return (target._info.Inherit(PHConstraintIf.GetIfInfoStatic()) ? new PHConstraintIf(target._thisArray[0], target._flag) : null);
	}
	~PHConstraintIf() { if (_flag) { SprExport.Spr_delete_PHConstraintIf(_thisArray[0]); _flag = false; } }
        public override string ToString() {
            IntPtr ptr = SprExport.Spr_PHConstraintIf_ToString((IntPtr) _thisArray[0]);
            string bstr = Marshal.PtrToStringBSTR(ptr);
            SprExport.Spr_PHConstraintIf_FreeString((IntPtr) ptr);
            return bstr;
        }
	public IfInfo GetIfInfo() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHConstraintIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new IfInfo(ptr);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHConstraintIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new IfInfo(ptr);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHConstraintIf_GetIfInfo((IntPtr) _thisArray[0]);
            return new IfInfo(ptr);
		}
		throw new InvalidOperationException();
	}
	public static IfInfo GetIfInfoStatic() {
	    IntPtr ptr = SprExport.Spr_PHConstraintIf_GetIfInfoStatic();
            return new IfInfo(ptr);
	}
	public PHSolidIf GetSocketSolid() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHConstraintIf_GetSocketSolid((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            if (ptr == IntPtr.Zero) { return null; } 
            PHSolidIf obj = new PHSolidIf(ptr);
            if (obj.GetIfInfo() == PHHapticPointerIf.GetIfInfoStatic()) { return new PHHapticPointerIf(ptr); }
            return obj;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHConstraintIf_GetSocketSolid((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            if (ptr == IntPtr.Zero) { return null; } 
            PHSolidIf obj = new PHSolidIf(ptr);
            if (obj.GetIfInfo() == PHHapticPointerIf.GetIfInfoStatic()) { return new PHHapticPointerIf(ptr); }
            return obj;
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHConstraintIf_GetSocketSolid((IntPtr) _thisArray[0]);
            if (ptr == IntPtr.Zero) { return null; } 
            PHSolidIf obj = new PHSolidIf(ptr);
            if (obj.GetIfInfo() == PHHapticPointerIf.GetIfInfoStatic()) { return new PHHapticPointerIf(ptr); }
            return obj;
		}
		throw new InvalidOperationException();
	}
	public PHSolidIf GetPlugSolid() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHConstraintIf_GetPlugSolid((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            if (ptr == IntPtr.Zero) { return null; } 
            PHSolidIf obj = new PHSolidIf(ptr);
            if (obj.GetIfInfo() == PHHapticPointerIf.GetIfInfoStatic()) { return new PHHapticPointerIf(ptr); }
            return obj;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHConstraintIf_GetPlugSolid((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            if (ptr == IntPtr.Zero) { return null; } 
            PHSolidIf obj = new PHSolidIf(ptr);
            if (obj.GetIfInfo() == PHHapticPointerIf.GetIfInfoStatic()) { return new PHHapticPointerIf(ptr); }
            return obj;
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHConstraintIf_GetPlugSolid((IntPtr) _thisArray[0]);
            if (ptr == IntPtr.Zero) { return null; } 
            PHSolidIf obj = new PHSolidIf(ptr);
            if (obj.GetIfInfo() == PHHapticPointerIf.GetIfInfoStatic()) { return new PHHapticPointerIf(ptr); }
            return obj;
		}
		throw new InvalidOperationException();
	}
	public PHSceneIf GetScene() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHConstraintIf_GetScene((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            if (ptr == IntPtr.Zero) { return null; } 
            PHSceneIf obj = new PHSceneIf(ptr);
            return obj;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHConstraintIf_GetScene((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            if (ptr == IntPtr.Zero) { return null; } 
            PHSceneIf obj = new PHSceneIf(ptr);
            return obj;
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHConstraintIf_GetScene((IntPtr) _thisArray[0]);
            if (ptr == IntPtr.Zero) { return null; } 
            PHSceneIf obj = new PHSceneIf(ptr);
            return obj;
		}
		throw new InvalidOperationException();
	}
	public void Enable(bool bEnable) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHConstraintIf_Enable((IntPtr) _thisArray[phSceneIf.sceneForStep], (bool) bEnable);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHConstraintIf_Enable((IntPtr) _thisArray[phSceneIf.sceneForGet], (bool) bEnable);
				}
			}
		} else {
	    SprExport.Spr_PHConstraintIf_Enable((IntPtr) _thisArray[0], (bool) bEnable);
		}
		throw new InvalidOperationException();
	}
	public void Enable() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHConstraintIf_Enable_1((IntPtr) _thisArray[phSceneIf.sceneForStep]);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHConstraintIf_Enable_1((IntPtr) _thisArray[phSceneIf.sceneForGet]);
				}
			}
		} else {
	    SprExport.Spr_PHConstraintIf_Enable_1((IntPtr) _thisArray[0]);
		}
		throw new InvalidOperationException();
	}
	public bool IsEnabled() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    char ret = SprExport.Spr_PHConstraintIf_IsEnabled((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return (ret == 0) ? false : true;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    char ret = SprExport.Spr_PHConstraintIf_IsEnabled((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return (ret == 0) ? false : true;
				}
			}
		} else {
	    char ret = SprExport.Spr_PHConstraintIf_IsEnabled((IntPtr) _thisArray[0]);
	    return (ret == 0) ? false : true;
		}
		throw new InvalidOperationException();
	}
	public bool IsArticulated() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    char ret = SprExport.Spr_PHConstraintIf_IsArticulated((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return (ret == 0) ? false : true;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    char ret = SprExport.Spr_PHConstraintIf_IsArticulated((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return (ret == 0) ? false : true;
				}
			}
		} else {
	    char ret = SprExport.Spr_PHConstraintIf_IsArticulated((IntPtr) _thisArray[0]);
	    return (ret == 0) ? false : true;
		}
		throw new InvalidOperationException();
	}
	public void GetSocketPose(Posed pose) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHConstraintIf_GetSocketPose((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) pose);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHConstraintIf_GetSocketPose((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) pose);
				}
			}
		} else {
	    SprExport.Spr_PHConstraintIf_GetSocketPose((IntPtr) _thisArray[0], (IntPtr) pose);
		}
		throw new InvalidOperationException();
	}
	public void SetSocketPose(Posed pose) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHConstraintIf_SetSocketPose((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) pose);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHConstraintIf_SetSocketPose((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) pose);
				}
			}
		} else {
	    SprExport.Spr_PHConstraintIf_SetSocketPose((IntPtr) _thisArray[0], (IntPtr) pose);
		}
		throw new InvalidOperationException();
	}
	public void GetPlugPose(Posed pose) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHConstraintIf_GetPlugPose((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) pose);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHConstraintIf_GetPlugPose((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) pose);
				}
			}
		} else {
	    SprExport.Spr_PHConstraintIf_GetPlugPose((IntPtr) _thisArray[0], (IntPtr) pose);
		}
		throw new InvalidOperationException();
	}
	public void SetPlugPose(Posed pose) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHConstraintIf_SetPlugPose((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) pose);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHConstraintIf_SetPlugPose((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) pose);
				}
			}
		} else {
	    SprExport.Spr_PHConstraintIf_SetPlugPose((IntPtr) _thisArray[0], (IntPtr) pose);
		}
		throw new InvalidOperationException();
	}
	public void GetRelativePose(Posed p) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHConstraintIf_GetRelativePose((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) p);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHConstraintIf_GetRelativePose((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) p);
				}
			}
		} else {
	    SprExport.Spr_PHConstraintIf_GetRelativePose((IntPtr) _thisArray[0], (IntPtr) p);
		}
		throw new InvalidOperationException();
	}
	public Vec3d GetRelativePoseR() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHConstraintIf_GetRelativePoseR((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new Vec3d(ptr, true);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHConstraintIf_GetRelativePoseR((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new Vec3d(ptr, true);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHConstraintIf_GetRelativePoseR((IntPtr) _thisArray[0]);
            return new Vec3d(ptr, true);
		}
		throw new InvalidOperationException();
	}
	public Quaterniond GetRelativePoseQ() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHConstraintIf_GetRelativePoseQ((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new Quaterniond(ptr, true);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHConstraintIf_GetRelativePoseQ((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new Quaterniond(ptr, true);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHConstraintIf_GetRelativePoseQ((IntPtr) _thisArray[0]);
            return new Quaterniond(ptr, true);
		}
		throw new InvalidOperationException();
	}
	public Quaternionf GetAbsolutePoseQ() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHConstraintIf_GetAbsolutePoseQ((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new Quaternionf(ptr, true);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHConstraintIf_GetAbsolutePoseQ((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new Quaternionf(ptr, true);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHConstraintIf_GetAbsolutePoseQ((IntPtr) _thisArray[0]);
            return new Quaternionf(ptr, true);
		}
		throw new InvalidOperationException();
	}
	public void GetRelativeVelocity(Vec3d v, Vec3d w) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHConstraintIf_GetRelativeVelocity((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) v, (IntPtr) w);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHConstraintIf_GetRelativeVelocity((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) v, (IntPtr) w);
				}
			}
		} else {
	    SprExport.Spr_PHConstraintIf_GetRelativeVelocity((IntPtr) _thisArray[0], (IntPtr) v, (IntPtr) w);
		}
		throw new InvalidOperationException();
	}
	public void GetConstraintForce(Vec3d f, Vec3d t) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHConstraintIf_GetConstraintForce((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) f, (IntPtr) t);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHConstraintIf_GetConstraintForce((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) f, (IntPtr) t);
				}
			}
		} else {
	    SprExport.Spr_PHConstraintIf_GetConstraintForce((IntPtr) _thisArray[0], (IntPtr) f, (IntPtr) t);
		}
		throw new InvalidOperationException();
	}
	public bool IsYielded() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    char ret = SprExport.Spr_PHConstraintIf_IsYielded((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return (ret == 0) ? false : true;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    char ret = SprExport.Spr_PHConstraintIf_IsYielded((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return (ret == 0) ? false : true;
				}
			}
		} else {
	    char ret = SprExport.Spr_PHConstraintIf_IsYielded((IntPtr) _thisArray[0]);
	    return (ret == 0) ? false : true;
		}
		throw new InvalidOperationException();
	}
    }
    public partial class PHConstraintsIf : SceneObjectIf {
	public PHConstraintsIf() { _thisArray[0] = SprExport.Spr_new_PHConstraintsIf(); _flag = true; }
	public PHConstraintsIf(IntPtr ptr) : base(ptr) {}
	public PHConstraintsIf(IntPtr ptr, bool flag) : base(ptr, flag) {}
	public static implicit operator PHConstraintsIf(CsCastObject target) {
		return (target._info.Inherit(PHConstraintsIf.GetIfInfoStatic()) ? new PHConstraintsIf(target._thisArray[0], target._flag) : null);
	}
	~PHConstraintsIf() { if (_flag) { SprExport.Spr_delete_PHConstraintsIf(_thisArray[0]); _flag = false; } }
        public override string ToString() {
            IntPtr ptr = SprExport.Spr_PHConstraintsIf_ToString((IntPtr) _thisArray[0]);
            string bstr = Marshal.PtrToStringBSTR(ptr);
            SprExport.Spr_PHConstraintsIf_FreeString((IntPtr) ptr);
            return bstr;
        }
	public IfInfo GetIfInfo() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHConstraintsIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new IfInfo(ptr);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHConstraintsIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new IfInfo(ptr);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHConstraintsIf_GetIfInfo((IntPtr) _thisArray[0]);
            return new IfInfo(ptr);
		}
		throw new InvalidOperationException();
	}
	public static IfInfo GetIfInfoStatic() {
	    IntPtr ptr = SprExport.Spr_PHConstraintsIf_GetIfInfoStatic();
            return new IfInfo(ptr);
	}
	public PHConstraintIf FindBySolidPair(PHSolidIf lhs, PHSolidIf rhs) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHConstraintsIf_FindBySolidPair((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) lhs, (IntPtr) rhs);
            if (ptr == IntPtr.Zero) { return null; } 
            PHConstraintIf obj = new PHConstraintIf(ptr);
            if (obj.GetIfInfo() == PHContactPointIf.GetIfInfoStatic()) { return new PHContactPointIf(ptr); }
            if (obj.GetIfInfo() == PHJointIf.GetIfInfoStatic()) { return new PHJointIf(ptr); }
            if (obj.GetIfInfo() == PH1DJointIf.GetIfInfoStatic()) { return new PH1DJointIf(ptr); }
            if (obj.GetIfInfo() == PHBallJointIf.GetIfInfoStatic()) { return new PHBallJointIf(ptr); }
            if (obj.GetIfInfo() == PHFixJointIf.GetIfInfoStatic()) { return new PHFixJointIf(ptr); }
            if (obj.GetIfInfo() == PHSpringIf.GetIfInfoStatic()) { return new PHSpringIf(ptr); }
            if (obj.GetIfInfo() == PHMateIf.GetIfInfoStatic()) { return new PHMateIf(ptr); }
            if (obj.GetIfInfo() == PHHingeJointIf.GetIfInfoStatic()) { return new PHHingeJointIf(ptr); }
            if (obj.GetIfInfo() == PHSliderJointIf.GetIfInfoStatic()) { return new PHSliderJointIf(ptr); }
            if (obj.GetIfInfo() == PHPathJointIf.GetIfInfoStatic()) { return new PHPathJointIf(ptr); }
            if (obj.GetIfInfo() == PHGenericJointIf.GetIfInfoStatic()) { return new PHGenericJointIf(ptr); }
            if (obj.GetIfInfo() == PHPointToPointMateIf.GetIfInfoStatic()) { return new PHPointToPointMateIf(ptr); }
            if (obj.GetIfInfo() == PHPointToLineMateIf.GetIfInfoStatic()) { return new PHPointToLineMateIf(ptr); }
            if (obj.GetIfInfo() == PHPointToPlaneMateIf.GetIfInfoStatic()) { return new PHPointToPlaneMateIf(ptr); }
            if (obj.GetIfInfo() == PHLineToLineMateIf.GetIfInfoStatic()) { return new PHLineToLineMateIf(ptr); }
            if (obj.GetIfInfo() == PHPlaneToPlaneMateIf.GetIfInfoStatic()) { return new PHPlaneToPlaneMateIf(ptr); }
            return obj;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHConstraintsIf_FindBySolidPair((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) lhs, (IntPtr) rhs);
            if (ptr == IntPtr.Zero) { return null; } 
            PHConstraintIf obj = new PHConstraintIf(ptr);
            if (obj.GetIfInfo() == PHContactPointIf.GetIfInfoStatic()) { return new PHContactPointIf(ptr); }
            if (obj.GetIfInfo() == PHJointIf.GetIfInfoStatic()) { return new PHJointIf(ptr); }
            if (obj.GetIfInfo() == PH1DJointIf.GetIfInfoStatic()) { return new PH1DJointIf(ptr); }
            if (obj.GetIfInfo() == PHBallJointIf.GetIfInfoStatic()) { return new PHBallJointIf(ptr); }
            if (obj.GetIfInfo() == PHFixJointIf.GetIfInfoStatic()) { return new PHFixJointIf(ptr); }
            if (obj.GetIfInfo() == PHSpringIf.GetIfInfoStatic()) { return new PHSpringIf(ptr); }
            if (obj.GetIfInfo() == PHMateIf.GetIfInfoStatic()) { return new PHMateIf(ptr); }
            if (obj.GetIfInfo() == PHHingeJointIf.GetIfInfoStatic()) { return new PHHingeJointIf(ptr); }
            if (obj.GetIfInfo() == PHSliderJointIf.GetIfInfoStatic()) { return new PHSliderJointIf(ptr); }
            if (obj.GetIfInfo() == PHPathJointIf.GetIfInfoStatic()) { return new PHPathJointIf(ptr); }
            if (obj.GetIfInfo() == PHGenericJointIf.GetIfInfoStatic()) { return new PHGenericJointIf(ptr); }
            if (obj.GetIfInfo() == PHPointToPointMateIf.GetIfInfoStatic()) { return new PHPointToPointMateIf(ptr); }
            if (obj.GetIfInfo() == PHPointToLineMateIf.GetIfInfoStatic()) { return new PHPointToLineMateIf(ptr); }
            if (obj.GetIfInfo() == PHPointToPlaneMateIf.GetIfInfoStatic()) { return new PHPointToPlaneMateIf(ptr); }
            if (obj.GetIfInfo() == PHLineToLineMateIf.GetIfInfoStatic()) { return new PHLineToLineMateIf(ptr); }
            if (obj.GetIfInfo() == PHPlaneToPlaneMateIf.GetIfInfoStatic()) { return new PHPlaneToPlaneMateIf(ptr); }
            return obj;
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHConstraintsIf_FindBySolidPair((IntPtr) _thisArray[0], (IntPtr) lhs, (IntPtr) rhs);
            if (ptr == IntPtr.Zero) { return null; } 
            PHConstraintIf obj = new PHConstraintIf(ptr);
            if (obj.GetIfInfo() == PHContactPointIf.GetIfInfoStatic()) { return new PHContactPointIf(ptr); }
            if (obj.GetIfInfo() == PHJointIf.GetIfInfoStatic()) { return new PHJointIf(ptr); }
            if (obj.GetIfInfo() == PH1DJointIf.GetIfInfoStatic()) { return new PH1DJointIf(ptr); }
            if (obj.GetIfInfo() == PHBallJointIf.GetIfInfoStatic()) { return new PHBallJointIf(ptr); }
            if (obj.GetIfInfo() == PHFixJointIf.GetIfInfoStatic()) { return new PHFixJointIf(ptr); }
            if (obj.GetIfInfo() == PHSpringIf.GetIfInfoStatic()) { return new PHSpringIf(ptr); }
            if (obj.GetIfInfo() == PHMateIf.GetIfInfoStatic()) { return new PHMateIf(ptr); }
            if (obj.GetIfInfo() == PHHingeJointIf.GetIfInfoStatic()) { return new PHHingeJointIf(ptr); }
            if (obj.GetIfInfo() == PHSliderJointIf.GetIfInfoStatic()) { return new PHSliderJointIf(ptr); }
            if (obj.GetIfInfo() == PHPathJointIf.GetIfInfoStatic()) { return new PHPathJointIf(ptr); }
            if (obj.GetIfInfo() == PHGenericJointIf.GetIfInfoStatic()) { return new PHGenericJointIf(ptr); }
            if (obj.GetIfInfo() == PHPointToPointMateIf.GetIfInfoStatic()) { return new PHPointToPointMateIf(ptr); }
            if (obj.GetIfInfo() == PHPointToLineMateIf.GetIfInfoStatic()) { return new PHPointToLineMateIf(ptr); }
            if (obj.GetIfInfo() == PHPointToPlaneMateIf.GetIfInfoStatic()) { return new PHPointToPlaneMateIf(ptr); }
            if (obj.GetIfInfo() == PHLineToLineMateIf.GetIfInfoStatic()) { return new PHLineToLineMateIf(ptr); }
            if (obj.GetIfInfo() == PHPlaneToPlaneMateIf.GetIfInfoStatic()) { return new PHPlaneToPlaneMateIf(ptr); }
            return obj;
		}
		throw new InvalidOperationException();
	}
	public Vec3d GetTotalForce(PHSolidIf lhs, PHSolidIf rhs) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHConstraintsIf_GetTotalForce((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) lhs, (IntPtr) rhs);
            return new Vec3d(ptr, true);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHConstraintsIf_GetTotalForce((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) lhs, (IntPtr) rhs);
            return new Vec3d(ptr, true);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHConstraintsIf_GetTotalForce((IntPtr) _thisArray[0], (IntPtr) lhs, (IntPtr) rhs);
            return new Vec3d(ptr, true);
		}
		throw new InvalidOperationException();
	}
    }
    public partial class PHContactPointIf : PHConstraintIf {
	public PHContactPointIf() { _thisArray[0] = SprExport.Spr_new_PHContactPointIf(); _flag = true; }
	public PHContactPointIf(IntPtr ptr) : base(ptr) {}
	public PHContactPointIf(IntPtr ptr, bool flag) : base(ptr, flag) {}
	public static implicit operator PHContactPointIf(CsCastObject target) {
		return (target._info.Inherit(PHContactPointIf.GetIfInfoStatic()) ? new PHContactPointIf(target._thisArray[0], target._flag) : null);
	}
	~PHContactPointIf() { if (_flag) { SprExport.Spr_delete_PHContactPointIf(_thisArray[0]); _flag = false; } }
        public override string ToString() {
            IntPtr ptr = SprExport.Spr_PHContactPointIf_ToString((IntPtr) _thisArray[0]);
            string bstr = Marshal.PtrToStringBSTR(ptr);
            SprExport.Spr_PHContactPointIf_FreeString((IntPtr) ptr);
            return bstr;
        }
	public IfInfo GetIfInfo() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHContactPointIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new IfInfo(ptr);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHContactPointIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new IfInfo(ptr);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHContactPointIf_GetIfInfo((IntPtr) _thisArray[0]);
            return new IfInfo(ptr);
		}
		throw new InvalidOperationException();
	}
	public static IfInfo GetIfInfoStatic() {
	    IntPtr ptr = SprExport.Spr_PHContactPointIf_GetIfInfoStatic();
            return new IfInfo(ptr);
	}
    }
    public partial class PHJointIf : PHConstraintIf {
	public PHJointIf() { _thisArray[0] = SprExport.Spr_new_PHJointIf(); _flag = true; }
	public PHJointIf(IntPtr ptr) : base(ptr) {}
	public PHJointIf(IntPtr ptr, bool flag) : base(ptr, flag) {}
	public static implicit operator PHJointIf(CsCastObject target) {
		return (target._info.Inherit(PHJointIf.GetIfInfoStatic()) ? new PHJointIf(target._thisArray[0], target._flag) : null);
	}
	~PHJointIf() { if (_flag) { SprExport.Spr_delete_PHJointIf(_thisArray[0]); _flag = false; } }
        public override string ToString() {
            IntPtr ptr = SprExport.Spr_PHJointIf_ToString((IntPtr) _thisArray[0]);
            string bstr = Marshal.PtrToStringBSTR(ptr);
            SprExport.Spr_PHJointIf_FreeString((IntPtr) ptr);
            return bstr;
        }
	public IfInfo GetIfInfo() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHJointIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new IfInfo(ptr);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHJointIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new IfInfo(ptr);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHJointIf_GetIfInfo((IntPtr) _thisArray[0]);
            return new IfInfo(ptr);
		}
		throw new InvalidOperationException();
	}
	public static IfInfo GetIfInfoStatic() {
	    IntPtr ptr = SprExport.Spr_PHJointIf_GetIfInfoStatic();
            return new IfInfo(ptr);
	}
	public void SetMaxForce(double max) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHJointIf_SetMaxForce((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) max);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHJointIf_SetMaxForce((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) max);
				}
			}
		} else {
	    SprExport.Spr_PHJointIf_SetMaxForce((IntPtr) _thisArray[0], (double) max);
		}
		throw new InvalidOperationException();
	}
	public double GetMaxForce() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    double result = (double) SprExport.Spr_PHJointIf_GetMaxForce((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    double result = (double) SprExport.Spr_PHJointIf_GetMaxForce((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    double result = (double) SprExport.Spr_PHJointIf_GetMaxForce((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
    }
    public partial class PH1DJointIf : PHJointIf {
	public PH1DJointIf() { _thisArray[0] = SprExport.Spr_new_PH1DJointIf(); _flag = true; }
	public PH1DJointIf(IntPtr ptr) : base(ptr) {}
	public PH1DJointIf(IntPtr ptr, bool flag) : base(ptr, flag) {}
	public static implicit operator PH1DJointIf(CsCastObject target) {
		return (target._info.Inherit(PH1DJointIf.GetIfInfoStatic()) ? new PH1DJointIf(target._thisArray[0], target._flag) : null);
	}
	~PH1DJointIf() { if (_flag) { SprExport.Spr_delete_PH1DJointIf(_thisArray[0]); _flag = false; } }
        public override string ToString() {
            IntPtr ptr = SprExport.Spr_PH1DJointIf_ToString((IntPtr) _thisArray[0]);
            string bstr = Marshal.PtrToStringBSTR(ptr);
            SprExport.Spr_PH1DJointIf_FreeString((IntPtr) ptr);
            return bstr;
        }
	public IfInfo GetIfInfo() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PH1DJointIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new IfInfo(ptr);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PH1DJointIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new IfInfo(ptr);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PH1DJointIf_GetIfInfo((IntPtr) _thisArray[0]);
            return new IfInfo(ptr);
		}
		throw new InvalidOperationException();
	}
	public static IfInfo GetIfInfoStatic() {
	    IntPtr ptr = SprExport.Spr_PH1DJointIf_GetIfInfoStatic();
            return new IfInfo(ptr);
	}
	public PH1DJointLimitIf CreateLimit(PH1DJointLimitDesc desc) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PH1DJointIf_CreateLimit((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) desc);
            if (ptr == IntPtr.Zero) { return null; } 
            PH1DJointLimitIf obj = new PH1DJointLimitIf(ptr);
            return obj;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PH1DJointIf_CreateLimit((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) desc);
            if (ptr == IntPtr.Zero) { return null; } 
            PH1DJointLimitIf obj = new PH1DJointLimitIf(ptr);
            return obj;
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PH1DJointIf_CreateLimit((IntPtr) _thisArray[0], (IntPtr) desc);
            if (ptr == IntPtr.Zero) { return null; } 
            PH1DJointLimitIf obj = new PH1DJointLimitIf(ptr);
            return obj;
		}
		throw new InvalidOperationException();
	}
	public PH1DJointLimitIf CreateLimit() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PH1DJointIf_CreateLimit_1((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            if (ptr == IntPtr.Zero) { return null; } 
            PH1DJointLimitIf obj = new PH1DJointLimitIf(ptr);
            return obj;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PH1DJointIf_CreateLimit_1((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            if (ptr == IntPtr.Zero) { return null; } 
            PH1DJointLimitIf obj = new PH1DJointLimitIf(ptr);
            return obj;
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PH1DJointIf_CreateLimit_1((IntPtr) _thisArray[0]);
            if (ptr == IntPtr.Zero) { return null; } 
            PH1DJointLimitIf obj = new PH1DJointLimitIf(ptr);
            return obj;
		}
		throw new InvalidOperationException();
	}
	public PH1DJointMotorIf CreateMotor(IfInfo ii, PH1DJointMotorDesc desc) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PH1DJointIf_CreateMotor((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) ii, (IntPtr) desc);
            if (ptr == IntPtr.Zero) { return null; } 
            PH1DJointMotorIf obj = new PH1DJointMotorIf(ptr);
            if (obj.GetIfInfo() == PH1DJointNonLinearMotorIf.GetIfInfoStatic()) { return new PH1DJointNonLinearMotorIf(ptr); }
            if (obj.GetIfInfo() == PHHuman1DJointResistanceIf.GetIfInfoStatic()) { return new PHHuman1DJointResistanceIf(ptr); }
            return obj;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PH1DJointIf_CreateMotor((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) ii, (IntPtr) desc);
            if (ptr == IntPtr.Zero) { return null; } 
            PH1DJointMotorIf obj = new PH1DJointMotorIf(ptr);
            if (obj.GetIfInfo() == PH1DJointNonLinearMotorIf.GetIfInfoStatic()) { return new PH1DJointNonLinearMotorIf(ptr); }
            if (obj.GetIfInfo() == PHHuman1DJointResistanceIf.GetIfInfoStatic()) { return new PHHuman1DJointResistanceIf(ptr); }
            return obj;
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PH1DJointIf_CreateMotor((IntPtr) _thisArray[0], (IntPtr) ii, (IntPtr) desc);
            if (ptr == IntPtr.Zero) { return null; } 
            PH1DJointMotorIf obj = new PH1DJointMotorIf(ptr);
            if (obj.GetIfInfo() == PH1DJointNonLinearMotorIf.GetIfInfoStatic()) { return new PH1DJointNonLinearMotorIf(ptr); }
            if (obj.GetIfInfo() == PHHuman1DJointResistanceIf.GetIfInfoStatic()) { return new PHHuman1DJointResistanceIf(ptr); }
            return obj;
		}
		throw new InvalidOperationException();
	}
	public PH1DJointMotorIf CreateMotor(IfInfo ii) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PH1DJointIf_CreateMotor_1((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) ii);
            if (ptr == IntPtr.Zero) { return null; } 
            PH1DJointMotorIf obj = new PH1DJointMotorIf(ptr);
            if (obj.GetIfInfo() == PH1DJointNonLinearMotorIf.GetIfInfoStatic()) { return new PH1DJointNonLinearMotorIf(ptr); }
            if (obj.GetIfInfo() == PHHuman1DJointResistanceIf.GetIfInfoStatic()) { return new PHHuman1DJointResistanceIf(ptr); }
            return obj;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PH1DJointIf_CreateMotor_1((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) ii);
            if (ptr == IntPtr.Zero) { return null; } 
            PH1DJointMotorIf obj = new PH1DJointMotorIf(ptr);
            if (obj.GetIfInfo() == PH1DJointNonLinearMotorIf.GetIfInfoStatic()) { return new PH1DJointNonLinearMotorIf(ptr); }
            if (obj.GetIfInfo() == PHHuman1DJointResistanceIf.GetIfInfoStatic()) { return new PHHuman1DJointResistanceIf(ptr); }
            return obj;
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PH1DJointIf_CreateMotor_1((IntPtr) _thisArray[0], (IntPtr) ii);
            if (ptr == IntPtr.Zero) { return null; } 
            PH1DJointMotorIf obj = new PH1DJointMotorIf(ptr);
            if (obj.GetIfInfo() == PH1DJointNonLinearMotorIf.GetIfInfoStatic()) { return new PH1DJointNonLinearMotorIf(ptr); }
            if (obj.GetIfInfo() == PHHuman1DJointResistanceIf.GetIfInfoStatic()) { return new PHHuman1DJointResistanceIf(ptr); }
            return obj;
		}
		throw new InvalidOperationException();
	}
	public bool AddMotor(PH1DJointMotorIf m) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    char ret = SprExport.Spr_PH1DJointIf_AddMotor((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) m);
	    return (ret == 0) ? false : true;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    char ret = SprExport.Spr_PH1DJointIf_AddMotor((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) m);
	    return (ret == 0) ? false : true;
				}
			}
		} else {
	    char ret = SprExport.Spr_PH1DJointIf_AddMotor((IntPtr) _thisArray[0], (IntPtr) m);
	    return (ret == 0) ? false : true;
		}
		throw new InvalidOperationException();
	}
	public bool RemoveMotor(int n) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    char ret = SprExport.Spr_PH1DJointIf_RemoveMotor((IntPtr) _thisArray[phSceneIf.sceneForStep], (int) n);
	    return (ret == 0) ? false : true;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    char ret = SprExport.Spr_PH1DJointIf_RemoveMotor((IntPtr) _thisArray[phSceneIf.sceneForGet], (int) n);
	    return (ret == 0) ? false : true;
				}
			}
		} else {
	    char ret = SprExport.Spr_PH1DJointIf_RemoveMotor((IntPtr) _thisArray[0], (int) n);
	    return (ret == 0) ? false : true;
		}
		throw new InvalidOperationException();
	}
	public bool IsCyclic() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    char ret = SprExport.Spr_PH1DJointIf_IsCyclic((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return (ret == 0) ? false : true;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    char ret = SprExport.Spr_PH1DJointIf_IsCyclic((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return (ret == 0) ? false : true;
				}
			}
		} else {
	    char ret = SprExport.Spr_PH1DJointIf_IsCyclic((IntPtr) _thisArray[0]);
	    return (ret == 0) ? false : true;
		}
		throw new InvalidOperationException();
	}
	public void SetCyclic(bool on) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PH1DJointIf_SetCyclic((IntPtr) _thisArray[phSceneIf.sceneForStep], (bool) on);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PH1DJointIf_SetCyclic((IntPtr) _thisArray[phSceneIf.sceneForGet], (bool) on);
				}
			}
		} else {
	    SprExport.Spr_PH1DJointIf_SetCyclic((IntPtr) _thisArray[0], (bool) on);
		}
		throw new InvalidOperationException();
	}
	public double GetPosition() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    double result = (double) SprExport.Spr_PH1DJointIf_GetPosition((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    double result = (double) SprExport.Spr_PH1DJointIf_GetPosition((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    double result = (double) SprExport.Spr_PH1DJointIf_GetPosition((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public double GetVelocity() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    double result = (double) SprExport.Spr_PH1DJointIf_GetVelocity((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    double result = (double) SprExport.Spr_PH1DJointIf_GetVelocity((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    double result = (double) SprExport.Spr_PH1DJointIf_GetVelocity((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public bool HasLimit() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    char ret = SprExport.Spr_PH1DJointIf_HasLimit((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return (ret == 0) ? false : true;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    char ret = SprExport.Spr_PH1DJointIf_HasLimit((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return (ret == 0) ? false : true;
				}
			}
		} else {
	    char ret = SprExport.Spr_PH1DJointIf_HasLimit((IntPtr) _thisArray[0]);
	    return (ret == 0) ? false : true;
		}
		throw new InvalidOperationException();
	}
	public PH1DJointLimitIf GetLimit() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PH1DJointIf_GetLimit((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            if (ptr == IntPtr.Zero) { return null; } 
            PH1DJointLimitIf obj = new PH1DJointLimitIf(ptr);
            return obj;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PH1DJointIf_GetLimit((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            if (ptr == IntPtr.Zero) { return null; } 
            PH1DJointLimitIf obj = new PH1DJointLimitIf(ptr);
            return obj;
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PH1DJointIf_GetLimit((IntPtr) _thisArray[0]);
            if (ptr == IntPtr.Zero) { return null; } 
            PH1DJointLimitIf obj = new PH1DJointLimitIf(ptr);
            return obj;
		}
		throw new InvalidOperationException();
	}
	public void SetSpring(double spring) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PH1DJointIf_SetSpring((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) spring);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PH1DJointIf_SetSpring((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) spring);
				}
			}
		} else {
	    SprExport.Spr_PH1DJointIf_SetSpring((IntPtr) _thisArray[0], (double) spring);
		}
		throw new InvalidOperationException();
	}
	public double GetSpring() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    double result = (double) SprExport.Spr_PH1DJointIf_GetSpring((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    double result = (double) SprExport.Spr_PH1DJointIf_GetSpring((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    double result = (double) SprExport.Spr_PH1DJointIf_GetSpring((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public void SetDamper(double damper) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PH1DJointIf_SetDamper((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) damper);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PH1DJointIf_SetDamper((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) damper);
				}
			}
		} else {
	    SprExport.Spr_PH1DJointIf_SetDamper((IntPtr) _thisArray[0], (double) damper);
		}
		throw new InvalidOperationException();
	}
	public double GetDamper() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    double result = (double) SprExport.Spr_PH1DJointIf_GetDamper((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    double result = (double) SprExport.Spr_PH1DJointIf_GetDamper((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    double result = (double) SprExport.Spr_PH1DJointIf_GetDamper((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public double GetSecondDamper() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    double result = (double) SprExport.Spr_PH1DJointIf_GetSecondDamper((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    double result = (double) SprExport.Spr_PH1DJointIf_GetSecondDamper((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    double result = (double) SprExport.Spr_PH1DJointIf_GetSecondDamper((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public void SetSecondDamper(double input) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PH1DJointIf_SetSecondDamper((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) input);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PH1DJointIf_SetSecondDamper((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) input);
				}
			}
		} else {
	    SprExport.Spr_PH1DJointIf_SetSecondDamper((IntPtr) _thisArray[0], (double) input);
		}
		throw new InvalidOperationException();
	}
	public void SetTargetPosition(double targetPosition) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PH1DJointIf_SetTargetPosition((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) targetPosition);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PH1DJointIf_SetTargetPosition((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) targetPosition);
				}
			}
		} else {
	    SprExport.Spr_PH1DJointIf_SetTargetPosition((IntPtr) _thisArray[0], (double) targetPosition);
		}
		throw new InvalidOperationException();
	}
	public double GetTargetPosition() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    double result = (double) SprExport.Spr_PH1DJointIf_GetTargetPosition((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    double result = (double) SprExport.Spr_PH1DJointIf_GetTargetPosition((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    double result = (double) SprExport.Spr_PH1DJointIf_GetTargetPosition((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public void SetTargetVelocity(double v) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PH1DJointIf_SetTargetVelocity((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) v);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PH1DJointIf_SetTargetVelocity((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) v);
				}
			}
		} else {
	    SprExport.Spr_PH1DJointIf_SetTargetVelocity((IntPtr) _thisArray[0], (double) v);
		}
		throw new InvalidOperationException();
	}
	public double GetTargetVelocity() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    double result = (double) SprExport.Spr_PH1DJointIf_GetTargetVelocity((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    double result = (double) SprExport.Spr_PH1DJointIf_GetTargetVelocity((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    double result = (double) SprExport.Spr_PH1DJointIf_GetTargetVelocity((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public void SetOffsetForce(double dat) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PH1DJointIf_SetOffsetForce((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) dat);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PH1DJointIf_SetOffsetForce((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) dat);
				}
			}
		} else {
	    SprExport.Spr_PH1DJointIf_SetOffsetForce((IntPtr) _thisArray[0], (double) dat);
		}
		throw new InvalidOperationException();
	}
	public double GetOffsetForce() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    double result = (double) SprExport.Spr_PH1DJointIf_GetOffsetForce((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    double result = (double) SprExport.Spr_PH1DJointIf_GetOffsetForce((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    double result = (double) SprExport.Spr_PH1DJointIf_GetOffsetForce((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public void SetOffsetForceN(int n, double dat) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PH1DJointIf_SetOffsetForceN((IntPtr) _thisArray[phSceneIf.sceneForStep], (int) n, (double) dat);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PH1DJointIf_SetOffsetForceN((IntPtr) _thisArray[phSceneIf.sceneForGet], (int) n, (double) dat);
				}
			}
		} else {
	    SprExport.Spr_PH1DJointIf_SetOffsetForceN((IntPtr) _thisArray[0], (int) n, (double) dat);
		}
		throw new InvalidOperationException();
	}
	public double GetOffsetForceN(int n) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    double result = (double) SprExport.Spr_PH1DJointIf_GetOffsetForceN((IntPtr) _thisArray[phSceneIf.sceneForStep], (int) n);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    double result = (double) SprExport.Spr_PH1DJointIf_GetOffsetForceN((IntPtr) _thisArray[phSceneIf.sceneForGet], (int) n);
	    return result;
				}
			}
		} else {
	    double result = (double) SprExport.Spr_PH1DJointIf_GetOffsetForceN((IntPtr) _thisArray[0], (int) n);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public double GetYieldStress() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    double result = (double) SprExport.Spr_PH1DJointIf_GetYieldStress((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    double result = (double) SprExport.Spr_PH1DJointIf_GetYieldStress((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    double result = (double) SprExport.Spr_PH1DJointIf_GetYieldStress((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public void SetYieldStress(double yS) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PH1DJointIf_SetYieldStress((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) yS);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PH1DJointIf_SetYieldStress((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) yS);
				}
			}
		} else {
	    SprExport.Spr_PH1DJointIf_SetYieldStress((IntPtr) _thisArray[0], (double) yS);
		}
		throw new InvalidOperationException();
	}
	public double GetHardnessRate() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    double result = (double) SprExport.Spr_PH1DJointIf_GetHardnessRate((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    double result = (double) SprExport.Spr_PH1DJointIf_GetHardnessRate((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    double result = (double) SprExport.Spr_PH1DJointIf_GetHardnessRate((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public void SetHardnessRate(double hR) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PH1DJointIf_SetHardnessRate((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) hR);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PH1DJointIf_SetHardnessRate((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) hR);
				}
			}
		} else {
	    SprExport.Spr_PH1DJointIf_SetHardnessRate((IntPtr) _thisArray[0], (double) hR);
		}
		throw new InvalidOperationException();
	}
	public void SetSecondMoment(double sM) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PH1DJointIf_SetSecondMoment((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) sM);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PH1DJointIf_SetSecondMoment((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) sM);
				}
			}
		} else {
	    SprExport.Spr_PH1DJointIf_SetSecondMoment((IntPtr) _thisArray[0], (double) sM);
		}
		throw new InvalidOperationException();
	}
	public double GetSecondMoment() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    double result = (double) SprExport.Spr_PH1DJointIf_GetSecondMoment((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    double result = (double) SprExport.Spr_PH1DJointIf_GetSecondMoment((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    double result = (double) SprExport.Spr_PH1DJointIf_GetSecondMoment((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public int NMotors() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    int result = (int) SprExport.Spr_PH1DJointIf_NMotors((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    int result = (int) SprExport.Spr_PH1DJointIf_NMotors((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    int result = (int) SprExport.Spr_PH1DJointIf_NMotors((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public PH1DJointMotorIf GetMotors() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PH1DJointIf_GetMotors((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            if (ptr == IntPtr.Zero) { return null; } 
            PH1DJointMotorIf obj = new PH1DJointMotorIf(ptr);
            if (obj.GetIfInfo() == PH1DJointNonLinearMotorIf.GetIfInfoStatic()) { return new PH1DJointNonLinearMotorIf(ptr); }
            if (obj.GetIfInfo() == PHHuman1DJointResistanceIf.GetIfInfoStatic()) { return new PHHuman1DJointResistanceIf(ptr); }
            return obj;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PH1DJointIf_GetMotors((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            if (ptr == IntPtr.Zero) { return null; } 
            PH1DJointMotorIf obj = new PH1DJointMotorIf(ptr);
            if (obj.GetIfInfo() == PH1DJointNonLinearMotorIf.GetIfInfoStatic()) { return new PH1DJointNonLinearMotorIf(ptr); }
            if (obj.GetIfInfo() == PHHuman1DJointResistanceIf.GetIfInfoStatic()) { return new PHHuman1DJointResistanceIf(ptr); }
            return obj;
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PH1DJointIf_GetMotors((IntPtr) _thisArray[0]);
            if (ptr == IntPtr.Zero) { return null; } 
            PH1DJointMotorIf obj = new PH1DJointMotorIf(ptr);
            if (obj.GetIfInfo() == PH1DJointNonLinearMotorIf.GetIfInfoStatic()) { return new PH1DJointNonLinearMotorIf(ptr); }
            if (obj.GetIfInfo() == PHHuman1DJointResistanceIf.GetIfInfoStatic()) { return new PHHuman1DJointResistanceIf(ptr); }
            return obj;
		}
		throw new InvalidOperationException();
	}
	public double GetMotorForce() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    double result = (double) SprExport.Spr_PH1DJointIf_GetMotorForce((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    double result = (double) SprExport.Spr_PH1DJointIf_GetMotorForce((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    double result = (double) SprExport.Spr_PH1DJointIf_GetMotorForce((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public double GetMotorForceN(int n) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    double result = (double) SprExport.Spr_PH1DJointIf_GetMotorForceN((IntPtr) _thisArray[phSceneIf.sceneForStep], (int) n);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    double result = (double) SprExport.Spr_PH1DJointIf_GetMotorForceN((IntPtr) _thisArray[phSceneIf.sceneForGet], (int) n);
	    return result;
				}
			}
		} else {
	    double result = (double) SprExport.Spr_PH1DJointIf_GetMotorForceN((IntPtr) _thisArray[0], (int) n);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public double GetLimitForce() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    double result = (double) SprExport.Spr_PH1DJointIf_GetLimitForce((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    double result = (double) SprExport.Spr_PH1DJointIf_GetLimitForce((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    double result = (double) SprExport.Spr_PH1DJointIf_GetLimitForce((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
    }
    public partial class PHHingeJointIf : PH1DJointIf {
	public PHHingeJointIf() { _thisArray[0] = SprExport.Spr_new_PHHingeJointIf(); _flag = true; }
	public PHHingeJointIf(IntPtr ptr) : base(ptr) {}
	public PHHingeJointIf(IntPtr ptr, bool flag) : base(ptr, flag) {}
	public static implicit operator PHHingeJointIf(CsCastObject target) {
		return (target._info.Inherit(PHHingeJointIf.GetIfInfoStatic()) ? new PHHingeJointIf(target._thisArray[0], target._flag) : null);
	}
	~PHHingeJointIf() { if (_flag) { SprExport.Spr_delete_PHHingeJointIf(_thisArray[0]); _flag = false; } }
        public override string ToString() {
            IntPtr ptr = SprExport.Spr_PHHingeJointIf_ToString((IntPtr) _thisArray[0]);
            string bstr = Marshal.PtrToStringBSTR(ptr);
            SprExport.Spr_PHHingeJointIf_FreeString((IntPtr) ptr);
            return bstr;
        }
	public IfInfo GetIfInfo() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHHingeJointIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new IfInfo(ptr);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHHingeJointIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new IfInfo(ptr);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHHingeJointIf_GetIfInfo((IntPtr) _thisArray[0]);
            return new IfInfo(ptr);
		}
		throw new InvalidOperationException();
	}
	public static IfInfo GetIfInfoStatic() {
	    IntPtr ptr = SprExport.Spr_PHHingeJointIf_GetIfInfoStatic();
            return new IfInfo(ptr);
	}
    }
    public partial class PHSliderJointIf : PH1DJointIf {
	public PHSliderJointIf() { _thisArray[0] = SprExport.Spr_new_PHSliderJointIf(); _flag = true; }
	public PHSliderJointIf(IntPtr ptr) : base(ptr) {}
	public PHSliderJointIf(IntPtr ptr, bool flag) : base(ptr, flag) {}
	public static implicit operator PHSliderJointIf(CsCastObject target) {
		return (target._info.Inherit(PHSliderJointIf.GetIfInfoStatic()) ? new PHSliderJointIf(target._thisArray[0], target._flag) : null);
	}
	~PHSliderJointIf() { if (_flag) { SprExport.Spr_delete_PHSliderJointIf(_thisArray[0]); _flag = false; } }
        public override string ToString() {
            IntPtr ptr = SprExport.Spr_PHSliderJointIf_ToString((IntPtr) _thisArray[0]);
            string bstr = Marshal.PtrToStringBSTR(ptr);
            SprExport.Spr_PHSliderJointIf_FreeString((IntPtr) ptr);
            return bstr;
        }
	public IfInfo GetIfInfo() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHSliderJointIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new IfInfo(ptr);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHSliderJointIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new IfInfo(ptr);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHSliderJointIf_GetIfInfo((IntPtr) _thisArray[0]);
            return new IfInfo(ptr);
		}
		throw new InvalidOperationException();
	}
	public static IfInfo GetIfInfoStatic() {
	    IntPtr ptr = SprExport.Spr_PHSliderJointIf_GetIfInfoStatic();
            return new IfInfo(ptr);
	}
    }
    public partial class PHPathIf : SceneObjectIf {
	public PHPathIf() { _thisArray[0] = SprExport.Spr_new_PHPathIf(); _flag = true; }
	public PHPathIf(IntPtr ptr) : base(ptr) {}
	public PHPathIf(IntPtr ptr, bool flag) : base(ptr, flag) {}
	public static implicit operator PHPathIf(CsCastObject target) {
		return (target._info.Inherit(PHPathIf.GetIfInfoStatic()) ? new PHPathIf(target._thisArray[0], target._flag) : null);
	}
	~PHPathIf() { if (_flag) { SprExport.Spr_delete_PHPathIf(_thisArray[0]); _flag = false; } }
        public override string ToString() {
            IntPtr ptr = SprExport.Spr_PHPathIf_ToString((IntPtr) _thisArray[0]);
            string bstr = Marshal.PtrToStringBSTR(ptr);
            SprExport.Spr_PHPathIf_FreeString((IntPtr) ptr);
            return bstr;
        }
	public IfInfo GetIfInfo() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHPathIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new IfInfo(ptr);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHPathIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new IfInfo(ptr);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHPathIf_GetIfInfo((IntPtr) _thisArray[0]);
            return new IfInfo(ptr);
		}
		throw new InvalidOperationException();
	}
	public static IfInfo GetIfInfoStatic() {
	    IntPtr ptr = SprExport.Spr_PHPathIf_GetIfInfoStatic();
            return new IfInfo(ptr);
	}
	public void AddPoint(double s, Posed pose) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHPathIf_AddPoint((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) s, (IntPtr) pose);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHPathIf_AddPoint((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) s, (IntPtr) pose);
				}
			}
		} else {
	    SprExport.Spr_PHPathIf_AddPoint((IntPtr) _thisArray[0], (double) s, (IntPtr) pose);
		}
		throw new InvalidOperationException();
	}
	public void SetLoop(bool bOnOff) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHPathIf_SetLoop((IntPtr) _thisArray[phSceneIf.sceneForStep], (bool) bOnOff);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHPathIf_SetLoop((IntPtr) _thisArray[phSceneIf.sceneForGet], (bool) bOnOff);
				}
			}
		} else {
	    SprExport.Spr_PHPathIf_SetLoop((IntPtr) _thisArray[0], (bool) bOnOff);
		}
		throw new InvalidOperationException();
	}
	public void SetLoop() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHPathIf_SetLoop_1((IntPtr) _thisArray[phSceneIf.sceneForStep]);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHPathIf_SetLoop_1((IntPtr) _thisArray[phSceneIf.sceneForGet]);
				}
			}
		} else {
	    SprExport.Spr_PHPathIf_SetLoop_1((IntPtr) _thisArray[0]);
		}
		throw new InvalidOperationException();
	}
	public bool IsLoop() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    char ret = SprExport.Spr_PHPathIf_IsLoop((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return (ret == 0) ? false : true;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    char ret = SprExport.Spr_PHPathIf_IsLoop((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return (ret == 0) ? false : true;
				}
			}
		} else {
	    char ret = SprExport.Spr_PHPathIf_IsLoop((IntPtr) _thisArray[0]);
	    return (ret == 0) ? false : true;
		}
		throw new InvalidOperationException();
	}
    }
    public partial class PHPathJointIf : PH1DJointIf {
	public PHPathJointIf() { _thisArray[0] = SprExport.Spr_new_PHPathJointIf(); _flag = true; }
	public PHPathJointIf(IntPtr ptr) : base(ptr) {}
	public PHPathJointIf(IntPtr ptr, bool flag) : base(ptr, flag) {}
	public static implicit operator PHPathJointIf(CsCastObject target) {
		return (target._info.Inherit(PHPathJointIf.GetIfInfoStatic()) ? new PHPathJointIf(target._thisArray[0], target._flag) : null);
	}
	~PHPathJointIf() { if (_flag) { SprExport.Spr_delete_PHPathJointIf(_thisArray[0]); _flag = false; } }
        public override string ToString() {
            IntPtr ptr = SprExport.Spr_PHPathJointIf_ToString((IntPtr) _thisArray[0]);
            string bstr = Marshal.PtrToStringBSTR(ptr);
            SprExport.Spr_PHPathJointIf_FreeString((IntPtr) ptr);
            return bstr;
        }
	public IfInfo GetIfInfo() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHPathJointIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new IfInfo(ptr);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHPathJointIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new IfInfo(ptr);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHPathJointIf_GetIfInfo((IntPtr) _thisArray[0]);
            return new IfInfo(ptr);
		}
		throw new InvalidOperationException();
	}
	public static IfInfo GetIfInfoStatic() {
	    IntPtr ptr = SprExport.Spr_PHPathJointIf_GetIfInfoStatic();
            return new IfInfo(ptr);
	}
	public void SetPosition(double q) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHPathJointIf_SetPosition((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) q);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHPathJointIf_SetPosition((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) q);
				}
			}
		} else {
	    SprExport.Spr_PHPathJointIf_SetPosition((IntPtr) _thisArray[0], (double) q);
		}
		throw new InvalidOperationException();
	}
    }
    public partial class PHGenericJointIf : PH1DJointIf {
	public PHGenericJointIf() { _thisArray[0] = SprExport.Spr_new_PHGenericJointIf(); _flag = true; }
	public PHGenericJointIf(IntPtr ptr) : base(ptr) {}
	public PHGenericJointIf(IntPtr ptr, bool flag) : base(ptr, flag) {}
	public static implicit operator PHGenericJointIf(CsCastObject target) {
		return (target._info.Inherit(PHGenericJointIf.GetIfInfoStatic()) ? new PHGenericJointIf(target._thisArray[0], target._flag) : null);
	}
	~PHGenericJointIf() { if (_flag) { SprExport.Spr_delete_PHGenericJointIf(_thisArray[0]); _flag = false; } }
        public override string ToString() {
            IntPtr ptr = SprExport.Spr_PHGenericJointIf_ToString((IntPtr) _thisArray[0]);
            string bstr = Marshal.PtrToStringBSTR(ptr);
            SprExport.Spr_PHGenericJointIf_FreeString((IntPtr) ptr);
            return bstr;
        }
	public IfInfo GetIfInfo() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHGenericJointIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new IfInfo(ptr);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHGenericJointIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new IfInfo(ptr);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHGenericJointIf_GetIfInfo((IntPtr) _thisArray[0]);
            return new IfInfo(ptr);
		}
		throw new InvalidOperationException();
	}
	public static IfInfo GetIfInfoStatic() {
	    IntPtr ptr = SprExport.Spr_PHGenericJointIf_GetIfInfoStatic();
            return new IfInfo(ptr);
	}
	public void SetCallback(PHGenericJointCallback cb) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHGenericJointIf_SetCallback((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) cb);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHGenericJointIf_SetCallback((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) cb);
				}
			}
		} else {
	    SprExport.Spr_PHGenericJointIf_SetCallback((IntPtr) _thisArray[0], (IntPtr) cb);
		}
		throw new InvalidOperationException();
	}
	public void SetParam(string name, double value) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
            IntPtr remote1 = Marshal.StringToBSTR(name);
	    SprExport.Spr_PHGenericJointIf_SetParam((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) remote1, (double) value);
            Marshal.FreeBSTR(remote1);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
            IntPtr remote1 = Marshal.StringToBSTR(name);
	    SprExport.Spr_PHGenericJointIf_SetParam((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) remote1, (double) value);
            Marshal.FreeBSTR(remote1);
				}
			}
		} else {
            IntPtr remote1 = Marshal.StringToBSTR(name);
	    SprExport.Spr_PHGenericJointIf_SetParam((IntPtr) _thisArray[0], (IntPtr) remote1, (double) value);
            Marshal.FreeBSTR(remote1);
		}
		throw new InvalidOperationException();
	}
    }
    public partial class PHBallJointIf : PHJointIf {
	public PHBallJointIf() { _thisArray[0] = SprExport.Spr_new_PHBallJointIf(); _flag = true; }
	public PHBallJointIf(IntPtr ptr) : base(ptr) {}
	public PHBallJointIf(IntPtr ptr, bool flag) : base(ptr, flag) {}
	public static implicit operator PHBallJointIf(CsCastObject target) {
		return (target._info.Inherit(PHBallJointIf.GetIfInfoStatic()) ? new PHBallJointIf(target._thisArray[0], target._flag) : null);
	}
	~PHBallJointIf() { if (_flag) { SprExport.Spr_delete_PHBallJointIf(_thisArray[0]); _flag = false; } }
        public override string ToString() {
            IntPtr ptr = SprExport.Spr_PHBallJointIf_ToString((IntPtr) _thisArray[0]);
            string bstr = Marshal.PtrToStringBSTR(ptr);
            SprExport.Spr_PHBallJointIf_FreeString((IntPtr) ptr);
            return bstr;
        }
	public IfInfo GetIfInfo() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHBallJointIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new IfInfo(ptr);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHBallJointIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new IfInfo(ptr);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHBallJointIf_GetIfInfo((IntPtr) _thisArray[0]);
            return new IfInfo(ptr);
		}
		throw new InvalidOperationException();
	}
	public static IfInfo GetIfInfoStatic() {
	    IntPtr ptr = SprExport.Spr_PHBallJointIf_GetIfInfoStatic();
            return new IfInfo(ptr);
	}
	public PHBallJointLimitIf CreateLimit(IfInfo ii, PHBallJointLimitDesc desc) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHBallJointIf_CreateLimit((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) ii, (IntPtr) desc);
            if (ptr == IntPtr.Zero) { return null; } 
            PHBallJointLimitIf obj = new PHBallJointLimitIf(ptr);
            if (obj.GetIfInfo() == PHBallJointConeLimitIf.GetIfInfoStatic()) { return new PHBallJointConeLimitIf(ptr); }
            if (obj.GetIfInfo() == PHBallJointSplineLimitIf.GetIfInfoStatic()) { return new PHBallJointSplineLimitIf(ptr); }
            if (obj.GetIfInfo() == PHBallJointIndependentLimitIf.GetIfInfoStatic()) { return new PHBallJointIndependentLimitIf(ptr); }
            return obj;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHBallJointIf_CreateLimit((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) ii, (IntPtr) desc);
            if (ptr == IntPtr.Zero) { return null; } 
            PHBallJointLimitIf obj = new PHBallJointLimitIf(ptr);
            if (obj.GetIfInfo() == PHBallJointConeLimitIf.GetIfInfoStatic()) { return new PHBallJointConeLimitIf(ptr); }
            if (obj.GetIfInfo() == PHBallJointSplineLimitIf.GetIfInfoStatic()) { return new PHBallJointSplineLimitIf(ptr); }
            if (obj.GetIfInfo() == PHBallJointIndependentLimitIf.GetIfInfoStatic()) { return new PHBallJointIndependentLimitIf(ptr); }
            return obj;
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHBallJointIf_CreateLimit((IntPtr) _thisArray[0], (IntPtr) ii, (IntPtr) desc);
            if (ptr == IntPtr.Zero) { return null; } 
            PHBallJointLimitIf obj = new PHBallJointLimitIf(ptr);
            if (obj.GetIfInfo() == PHBallJointConeLimitIf.GetIfInfoStatic()) { return new PHBallJointConeLimitIf(ptr); }
            if (obj.GetIfInfo() == PHBallJointSplineLimitIf.GetIfInfoStatic()) { return new PHBallJointSplineLimitIf(ptr); }
            if (obj.GetIfInfo() == PHBallJointIndependentLimitIf.GetIfInfoStatic()) { return new PHBallJointIndependentLimitIf(ptr); }
            return obj;
		}
		throw new InvalidOperationException();
	}
	public PHBallJointLimitIf CreateLimit(IfInfo ii) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHBallJointIf_CreateLimit_1((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) ii);
            if (ptr == IntPtr.Zero) { return null; } 
            PHBallJointLimitIf obj = new PHBallJointLimitIf(ptr);
            if (obj.GetIfInfo() == PHBallJointConeLimitIf.GetIfInfoStatic()) { return new PHBallJointConeLimitIf(ptr); }
            if (obj.GetIfInfo() == PHBallJointSplineLimitIf.GetIfInfoStatic()) { return new PHBallJointSplineLimitIf(ptr); }
            if (obj.GetIfInfo() == PHBallJointIndependentLimitIf.GetIfInfoStatic()) { return new PHBallJointIndependentLimitIf(ptr); }
            return obj;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHBallJointIf_CreateLimit_1((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) ii);
            if (ptr == IntPtr.Zero) { return null; } 
            PHBallJointLimitIf obj = new PHBallJointLimitIf(ptr);
            if (obj.GetIfInfo() == PHBallJointConeLimitIf.GetIfInfoStatic()) { return new PHBallJointConeLimitIf(ptr); }
            if (obj.GetIfInfo() == PHBallJointSplineLimitIf.GetIfInfoStatic()) { return new PHBallJointSplineLimitIf(ptr); }
            if (obj.GetIfInfo() == PHBallJointIndependentLimitIf.GetIfInfoStatic()) { return new PHBallJointIndependentLimitIf(ptr); }
            return obj;
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHBallJointIf_CreateLimit_1((IntPtr) _thisArray[0], (IntPtr) ii);
            if (ptr == IntPtr.Zero) { return null; } 
            PHBallJointLimitIf obj = new PHBallJointLimitIf(ptr);
            if (obj.GetIfInfo() == PHBallJointConeLimitIf.GetIfInfoStatic()) { return new PHBallJointConeLimitIf(ptr); }
            if (obj.GetIfInfo() == PHBallJointSplineLimitIf.GetIfInfoStatic()) { return new PHBallJointSplineLimitIf(ptr); }
            if (obj.GetIfInfo() == PHBallJointIndependentLimitIf.GetIfInfoStatic()) { return new PHBallJointIndependentLimitIf(ptr); }
            return obj;
		}
		throw new InvalidOperationException();
	}
	public PHBallJointMotorIf CreateMotor(IfInfo ii, PHBallJointMotorDesc desc) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHBallJointIf_CreateMotor((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) ii, (IntPtr) desc);
            if (ptr == IntPtr.Zero) { return null; } 
            PHBallJointMotorIf obj = new PHBallJointMotorIf(ptr);
            if (obj.GetIfInfo() == PHBallJointNonLinearMotorIf.GetIfInfoStatic()) { return new PHBallJointNonLinearMotorIf(ptr); }
            if (obj.GetIfInfo() == PHHumanBallJointResistanceIf.GetIfInfoStatic()) { return new PHHumanBallJointResistanceIf(ptr); }
            return obj;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHBallJointIf_CreateMotor((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) ii, (IntPtr) desc);
            if (ptr == IntPtr.Zero) { return null; } 
            PHBallJointMotorIf obj = new PHBallJointMotorIf(ptr);
            if (obj.GetIfInfo() == PHBallJointNonLinearMotorIf.GetIfInfoStatic()) { return new PHBallJointNonLinearMotorIf(ptr); }
            if (obj.GetIfInfo() == PHHumanBallJointResistanceIf.GetIfInfoStatic()) { return new PHHumanBallJointResistanceIf(ptr); }
            return obj;
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHBallJointIf_CreateMotor((IntPtr) _thisArray[0], (IntPtr) ii, (IntPtr) desc);
            if (ptr == IntPtr.Zero) { return null; } 
            PHBallJointMotorIf obj = new PHBallJointMotorIf(ptr);
            if (obj.GetIfInfo() == PHBallJointNonLinearMotorIf.GetIfInfoStatic()) { return new PHBallJointNonLinearMotorIf(ptr); }
            if (obj.GetIfInfo() == PHHumanBallJointResistanceIf.GetIfInfoStatic()) { return new PHHumanBallJointResistanceIf(ptr); }
            return obj;
		}
		throw new InvalidOperationException();
	}
	public PHBallJointMotorIf CreateMotor(IfInfo ii) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHBallJointIf_CreateMotor_1((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) ii);
            if (ptr == IntPtr.Zero) { return null; } 
            PHBallJointMotorIf obj = new PHBallJointMotorIf(ptr);
            if (obj.GetIfInfo() == PHBallJointNonLinearMotorIf.GetIfInfoStatic()) { return new PHBallJointNonLinearMotorIf(ptr); }
            if (obj.GetIfInfo() == PHHumanBallJointResistanceIf.GetIfInfoStatic()) { return new PHHumanBallJointResistanceIf(ptr); }
            return obj;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHBallJointIf_CreateMotor_1((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) ii);
            if (ptr == IntPtr.Zero) { return null; } 
            PHBallJointMotorIf obj = new PHBallJointMotorIf(ptr);
            if (obj.GetIfInfo() == PHBallJointNonLinearMotorIf.GetIfInfoStatic()) { return new PHBallJointNonLinearMotorIf(ptr); }
            if (obj.GetIfInfo() == PHHumanBallJointResistanceIf.GetIfInfoStatic()) { return new PHHumanBallJointResistanceIf(ptr); }
            return obj;
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHBallJointIf_CreateMotor_1((IntPtr) _thisArray[0], (IntPtr) ii);
            if (ptr == IntPtr.Zero) { return null; } 
            PHBallJointMotorIf obj = new PHBallJointMotorIf(ptr);
            if (obj.GetIfInfo() == PHBallJointNonLinearMotorIf.GetIfInfoStatic()) { return new PHBallJointNonLinearMotorIf(ptr); }
            if (obj.GetIfInfo() == PHHumanBallJointResistanceIf.GetIfInfoStatic()) { return new PHHumanBallJointResistanceIf(ptr); }
            return obj;
		}
		throw new InvalidOperationException();
	}
	public bool AddMotor(PHBallJointMotorIf m) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    char ret = SprExport.Spr_PHBallJointIf_AddMotor((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) m);
	    return (ret == 0) ? false : true;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    char ret = SprExport.Spr_PHBallJointIf_AddMotor((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) m);
	    return (ret == 0) ? false : true;
				}
			}
		} else {
	    char ret = SprExport.Spr_PHBallJointIf_AddMotor((IntPtr) _thisArray[0], (IntPtr) m);
	    return (ret == 0) ? false : true;
		}
		throw new InvalidOperationException();
	}
	public bool RemoveMotor(int n) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    char ret = SprExport.Spr_PHBallJointIf_RemoveMotor((IntPtr) _thisArray[phSceneIf.sceneForStep], (int) n);
	    return (ret == 0) ? false : true;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    char ret = SprExport.Spr_PHBallJointIf_RemoveMotor((IntPtr) _thisArray[phSceneIf.sceneForGet], (int) n);
	    return (ret == 0) ? false : true;
				}
			}
		} else {
	    char ret = SprExport.Spr_PHBallJointIf_RemoveMotor((IntPtr) _thisArray[0], (int) n);
	    return (ret == 0) ? false : true;
		}
		throw new InvalidOperationException();
	}
	public Vec3d GetAngle() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHBallJointIf_GetAngle((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new Vec3d(ptr, true);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHBallJointIf_GetAngle((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new Vec3d(ptr, true);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHBallJointIf_GetAngle((IntPtr) _thisArray[0]);
            return new Vec3d(ptr, true);
		}
		throw new InvalidOperationException();
	}
	public Quaterniond GetPosition() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHBallJointIf_GetPosition((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new Quaterniond(ptr, true);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHBallJointIf_GetPosition((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new Quaterniond(ptr, true);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHBallJointIf_GetPosition((IntPtr) _thisArray[0]);
            return new Quaterniond(ptr, true);
		}
		throw new InvalidOperationException();
	}
	public Vec3d GetVelocity() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHBallJointIf_GetVelocity((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new Vec3d(ptr, true);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHBallJointIf_GetVelocity((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new Vec3d(ptr, true);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHBallJointIf_GetVelocity((IntPtr) _thisArray[0]);
            return new Vec3d(ptr, true);
		}
		throw new InvalidOperationException();
	}
	public bool HasLimit() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    char ret = SprExport.Spr_PHBallJointIf_HasLimit((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return (ret == 0) ? false : true;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    char ret = SprExport.Spr_PHBallJointIf_HasLimit((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return (ret == 0) ? false : true;
				}
			}
		} else {
	    char ret = SprExport.Spr_PHBallJointIf_HasLimit((IntPtr) _thisArray[0]);
	    return (ret == 0) ? false : true;
		}
		throw new InvalidOperationException();
	}
	public PHBallJointLimitIf GetLimit() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHBallJointIf_GetLimit((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            if (ptr == IntPtr.Zero) { return null; } 
            PHBallJointLimitIf obj = new PHBallJointLimitIf(ptr);
            if (obj.GetIfInfo() == PHBallJointConeLimitIf.GetIfInfoStatic()) { return new PHBallJointConeLimitIf(ptr); }
            if (obj.GetIfInfo() == PHBallJointSplineLimitIf.GetIfInfoStatic()) { return new PHBallJointSplineLimitIf(ptr); }
            if (obj.GetIfInfo() == PHBallJointIndependentLimitIf.GetIfInfoStatic()) { return new PHBallJointIndependentLimitIf(ptr); }
            return obj;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHBallJointIf_GetLimit((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            if (ptr == IntPtr.Zero) { return null; } 
            PHBallJointLimitIf obj = new PHBallJointLimitIf(ptr);
            if (obj.GetIfInfo() == PHBallJointConeLimitIf.GetIfInfoStatic()) { return new PHBallJointConeLimitIf(ptr); }
            if (obj.GetIfInfo() == PHBallJointSplineLimitIf.GetIfInfoStatic()) { return new PHBallJointSplineLimitIf(ptr); }
            if (obj.GetIfInfo() == PHBallJointIndependentLimitIf.GetIfInfoStatic()) { return new PHBallJointIndependentLimitIf(ptr); }
            return obj;
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHBallJointIf_GetLimit((IntPtr) _thisArray[0]);
            if (ptr == IntPtr.Zero) { return null; } 
            PHBallJointLimitIf obj = new PHBallJointLimitIf(ptr);
            if (obj.GetIfInfo() == PHBallJointConeLimitIf.GetIfInfoStatic()) { return new PHBallJointConeLimitIf(ptr); }
            if (obj.GetIfInfo() == PHBallJointSplineLimitIf.GetIfInfoStatic()) { return new PHBallJointSplineLimitIf(ptr); }
            if (obj.GetIfInfo() == PHBallJointIndependentLimitIf.GetIfInfoStatic()) { return new PHBallJointIndependentLimitIf(ptr); }
            return obj;
		}
		throw new InvalidOperationException();
	}
	public void SetSpring(double spring) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHBallJointIf_SetSpring((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) spring);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHBallJointIf_SetSpring((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) spring);
				}
			}
		} else {
	    SprExport.Spr_PHBallJointIf_SetSpring((IntPtr) _thisArray[0], (double) spring);
		}
		throw new InvalidOperationException();
	}
	public double GetSpring() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    double result = (double) SprExport.Spr_PHBallJointIf_GetSpring((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    double result = (double) SprExport.Spr_PHBallJointIf_GetSpring((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    double result = (double) SprExport.Spr_PHBallJointIf_GetSpring((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public void SetDamper(double damper) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHBallJointIf_SetDamper((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) damper);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHBallJointIf_SetDamper((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) damper);
				}
			}
		} else {
	    SprExport.Spr_PHBallJointIf_SetDamper((IntPtr) _thisArray[0], (double) damper);
		}
		throw new InvalidOperationException();
	}
	public double GetDamper() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    double result = (double) SprExport.Spr_PHBallJointIf_GetDamper((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    double result = (double) SprExport.Spr_PHBallJointIf_GetDamper((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    double result = (double) SprExport.Spr_PHBallJointIf_GetDamper((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public Vec3d GetSecondDamper() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHBallJointIf_GetSecondDamper((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new Vec3d(ptr, true);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHBallJointIf_GetSecondDamper((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new Vec3d(ptr, true);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHBallJointIf_GetSecondDamper((IntPtr) _thisArray[0]);
            return new Vec3d(ptr, true);
		}
		throw new InvalidOperationException();
	}
	public void SetSecondDamper(Vec3d damper2) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHBallJointIf_SetSecondDamper((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) damper2);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHBallJointIf_SetSecondDamper((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) damper2);
				}
			}
		} else {
	    SprExport.Spr_PHBallJointIf_SetSecondDamper((IntPtr) _thisArray[0], (IntPtr) damper2);
		}
		throw new InvalidOperationException();
	}
	public void SetTargetPosition(Quaterniond p) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHBallJointIf_SetTargetPosition((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) p);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHBallJointIf_SetTargetPosition((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) p);
				}
			}
		} else {
	    SprExport.Spr_PHBallJointIf_SetTargetPosition((IntPtr) _thisArray[0], (IntPtr) p);
		}
		throw new InvalidOperationException();
	}
	public Quaterniond GetTargetPosition() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHBallJointIf_GetTargetPosition((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new Quaterniond(ptr, true);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHBallJointIf_GetTargetPosition((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new Quaterniond(ptr, true);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHBallJointIf_GetTargetPosition((IntPtr) _thisArray[0]);
            return new Quaterniond(ptr, true);
		}
		throw new InvalidOperationException();
	}
	public void SetTargetVelocity(Vec3d q) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHBallJointIf_SetTargetVelocity((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) q);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHBallJointIf_SetTargetVelocity((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) q);
				}
			}
		} else {
	    SprExport.Spr_PHBallJointIf_SetTargetVelocity((IntPtr) _thisArray[0], (IntPtr) q);
		}
		throw new InvalidOperationException();
	}
	public Vec3d GetTargetVelocity() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHBallJointIf_GetTargetVelocity((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new Vec3d(ptr, true);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHBallJointIf_GetTargetVelocity((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new Vec3d(ptr, true);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHBallJointIf_GetTargetVelocity((IntPtr) _thisArray[0]);
            return new Vec3d(ptr, true);
		}
		throw new InvalidOperationException();
	}
	public void SetOffsetForce(Vec3d ofst) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHBallJointIf_SetOffsetForce((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) ofst);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHBallJointIf_SetOffsetForce((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) ofst);
				}
			}
		} else {
	    SprExport.Spr_PHBallJointIf_SetOffsetForce((IntPtr) _thisArray[0], (IntPtr) ofst);
		}
		throw new InvalidOperationException();
	}
	public Vec3d GetOffsetForce() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHBallJointIf_GetOffsetForce((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new Vec3d(ptr, true);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHBallJointIf_GetOffsetForce((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new Vec3d(ptr, true);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHBallJointIf_GetOffsetForce((IntPtr) _thisArray[0]);
            return new Vec3d(ptr, true);
		}
		throw new InvalidOperationException();
	}
	public void SetOffsetForceN(int n, Vec3d ofst) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHBallJointIf_SetOffsetForceN((IntPtr) _thisArray[phSceneIf.sceneForStep], (int) n, (IntPtr) ofst);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHBallJointIf_SetOffsetForceN((IntPtr) _thisArray[phSceneIf.sceneForGet], (int) n, (IntPtr) ofst);
				}
			}
		} else {
	    SprExport.Spr_PHBallJointIf_SetOffsetForceN((IntPtr) _thisArray[0], (int) n, (IntPtr) ofst);
		}
		throw new InvalidOperationException();
	}
	public Vec3d GetOffsetForceN(int n) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHBallJointIf_GetOffsetForceN((IntPtr) _thisArray[phSceneIf.sceneForStep], (int) n);
            return new Vec3d(ptr, true);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHBallJointIf_GetOffsetForceN((IntPtr) _thisArray[phSceneIf.sceneForGet], (int) n);
            return new Vec3d(ptr, true);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHBallJointIf_GetOffsetForceN((IntPtr) _thisArray[0], (int) n);
            return new Vec3d(ptr, true);
		}
		throw new InvalidOperationException();
	}
	public void SetYieldStress(double yS) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHBallJointIf_SetYieldStress((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) yS);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHBallJointIf_SetYieldStress((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) yS);
				}
			}
		} else {
	    SprExport.Spr_PHBallJointIf_SetYieldStress((IntPtr) _thisArray[0], (double) yS);
		}
		throw new InvalidOperationException();
	}
	public double GetYieldStress() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    double result = (double) SprExport.Spr_PHBallJointIf_GetYieldStress((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    double result = (double) SprExport.Spr_PHBallJointIf_GetYieldStress((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    double result = (double) SprExport.Spr_PHBallJointIf_GetYieldStress((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public void SetHardnessRate(double hR) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHBallJointIf_SetHardnessRate((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) hR);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHBallJointIf_SetHardnessRate((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) hR);
				}
			}
		} else {
	    SprExport.Spr_PHBallJointIf_SetHardnessRate((IntPtr) _thisArray[0], (double) hR);
		}
		throw new InvalidOperationException();
	}
	public double GetHardnessRate() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    double result = (double) SprExport.Spr_PHBallJointIf_GetHardnessRate((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    double result = (double) SprExport.Spr_PHBallJointIf_GetHardnessRate((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    double result = (double) SprExport.Spr_PHBallJointIf_GetHardnessRate((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public void SetSecondMoment(Vec3d m) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHBallJointIf_SetSecondMoment((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) m);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHBallJointIf_SetSecondMoment((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) m);
				}
			}
		} else {
	    SprExport.Spr_PHBallJointIf_SetSecondMoment((IntPtr) _thisArray[0], (IntPtr) m);
		}
		throw new InvalidOperationException();
	}
	public Vec3d GetSecondMoment() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHBallJointIf_GetSecondMoment((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new Vec3d(ptr, true);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHBallJointIf_GetSecondMoment((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new Vec3d(ptr, true);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHBallJointIf_GetSecondMoment((IntPtr) _thisArray[0]);
            return new Vec3d(ptr, true);
		}
		throw new InvalidOperationException();
	}
	public int NMotors() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    int result = (int) SprExport.Spr_PHBallJointIf_NMotors((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    int result = (int) SprExport.Spr_PHBallJointIf_NMotors((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    int result = (int) SprExport.Spr_PHBallJointIf_NMotors((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public PHBallJointMotorIf GetMotors() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHBallJointIf_GetMotors((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            if (ptr == IntPtr.Zero) { return null; } 
            PHBallJointMotorIf obj = new PHBallJointMotorIf(ptr);
            if (obj.GetIfInfo() == PHBallJointNonLinearMotorIf.GetIfInfoStatic()) { return new PHBallJointNonLinearMotorIf(ptr); }
            if (obj.GetIfInfo() == PHHumanBallJointResistanceIf.GetIfInfoStatic()) { return new PHHumanBallJointResistanceIf(ptr); }
            return obj;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHBallJointIf_GetMotors((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            if (ptr == IntPtr.Zero) { return null; } 
            PHBallJointMotorIf obj = new PHBallJointMotorIf(ptr);
            if (obj.GetIfInfo() == PHBallJointNonLinearMotorIf.GetIfInfoStatic()) { return new PHBallJointNonLinearMotorIf(ptr); }
            if (obj.GetIfInfo() == PHHumanBallJointResistanceIf.GetIfInfoStatic()) { return new PHHumanBallJointResistanceIf(ptr); }
            return obj;
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHBallJointIf_GetMotors((IntPtr) _thisArray[0]);
            if (ptr == IntPtr.Zero) { return null; } 
            PHBallJointMotorIf obj = new PHBallJointMotorIf(ptr);
            if (obj.GetIfInfo() == PHBallJointNonLinearMotorIf.GetIfInfoStatic()) { return new PHBallJointNonLinearMotorIf(ptr); }
            if (obj.GetIfInfo() == PHHumanBallJointResistanceIf.GetIfInfoStatic()) { return new PHHumanBallJointResistanceIf(ptr); }
            return obj;
		}
		throw new InvalidOperationException();
	}
	public Vec3d GetMotorForce() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHBallJointIf_GetMotorForce((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new Vec3d(ptr, true);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHBallJointIf_GetMotorForce((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new Vec3d(ptr, true);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHBallJointIf_GetMotorForce((IntPtr) _thisArray[0]);
            return new Vec3d(ptr, true);
		}
		throw new InvalidOperationException();
	}
	public Vec3d GetMotorForceN(int n) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHBallJointIf_GetMotorForceN((IntPtr) _thisArray[phSceneIf.sceneForStep], (int) n);
            return new Vec3d(ptr, true);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHBallJointIf_GetMotorForceN((IntPtr) _thisArray[phSceneIf.sceneForGet], (int) n);
            return new Vec3d(ptr, true);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHBallJointIf_GetMotorForceN((IntPtr) _thisArray[0], (int) n);
            return new Vec3d(ptr, true);
		}
		throw new InvalidOperationException();
	}
	public Vec3d GetLimitForce() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHBallJointIf_GetLimitForce((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new Vec3d(ptr, true);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHBallJointIf_GetLimitForce((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new Vec3d(ptr, true);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHBallJointIf_GetLimitForce((IntPtr) _thisArray[0]);
            return new Vec3d(ptr, true);
		}
		throw new InvalidOperationException();
	}
    }
    public partial class PHFixJointIf : PHJointIf {
	public PHFixJointIf() { _thisArray[0] = SprExport.Spr_new_PHFixJointIf(); _flag = true; }
	public PHFixJointIf(IntPtr ptr) : base(ptr) {}
	public PHFixJointIf(IntPtr ptr, bool flag) : base(ptr, flag) {}
	public static implicit operator PHFixJointIf(CsCastObject target) {
		return (target._info.Inherit(PHFixJointIf.GetIfInfoStatic()) ? new PHFixJointIf(target._thisArray[0], target._flag) : null);
	}
	~PHFixJointIf() { if (_flag) { SprExport.Spr_delete_PHFixJointIf(_thisArray[0]); _flag = false; } }
        public override string ToString() {
            IntPtr ptr = SprExport.Spr_PHFixJointIf_ToString((IntPtr) _thisArray[0]);
            string bstr = Marshal.PtrToStringBSTR(ptr);
            SprExport.Spr_PHFixJointIf_FreeString((IntPtr) ptr);
            return bstr;
        }
	public IfInfo GetIfInfo() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHFixJointIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new IfInfo(ptr);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHFixJointIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new IfInfo(ptr);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHFixJointIf_GetIfInfo((IntPtr) _thisArray[0]);
            return new IfInfo(ptr);
		}
		throw new InvalidOperationException();
	}
	public static IfInfo GetIfInfoStatic() {
	    IntPtr ptr = SprExport.Spr_PHFixJointIf_GetIfInfoStatic();
            return new IfInfo(ptr);
	}
    }
    public partial class PHSpringIf : PHJointIf {
	public PHSpringIf() { _thisArray[0] = SprExport.Spr_new_PHSpringIf(); _flag = true; }
	public PHSpringIf(IntPtr ptr) : base(ptr) {}
	public PHSpringIf(IntPtr ptr, bool flag) : base(ptr, flag) {}
	public static implicit operator PHSpringIf(CsCastObject target) {
		return (target._info.Inherit(PHSpringIf.GetIfInfoStatic()) ? new PHSpringIf(target._thisArray[0], target._flag) : null);
	}
	~PHSpringIf() { if (_flag) { SprExport.Spr_delete_PHSpringIf(_thisArray[0]); _flag = false; } }
        public override string ToString() {
            IntPtr ptr = SprExport.Spr_PHSpringIf_ToString((IntPtr) _thisArray[0]);
            string bstr = Marshal.PtrToStringBSTR(ptr);
            SprExport.Spr_PHSpringIf_FreeString((IntPtr) ptr);
            return bstr;
        }
	public IfInfo GetIfInfo() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHSpringIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new IfInfo(ptr);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHSpringIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new IfInfo(ptr);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHSpringIf_GetIfInfo((IntPtr) _thisArray[0]);
            return new IfInfo(ptr);
		}
		throw new InvalidOperationException();
	}
	public static IfInfo GetIfInfoStatic() {
	    IntPtr ptr = SprExport.Spr_PHSpringIf_GetIfInfoStatic();
            return new IfInfo(ptr);
	}
	public void SetTargetPosition(Vec3d targetPosition) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHSpringIf_SetTargetPosition((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) targetPosition);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHSpringIf_SetTargetPosition((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) targetPosition);
				}
			}
		} else {
	    SprExport.Spr_PHSpringIf_SetTargetPosition((IntPtr) _thisArray[0], (IntPtr) targetPosition);
		}
		throw new InvalidOperationException();
	}
	public Vec3d GetTargetPosition() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHSpringIf_GetTargetPosition((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new Vec3d(ptr, true);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHSpringIf_GetTargetPosition((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new Vec3d(ptr, true);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHSpringIf_GetTargetPosition((IntPtr) _thisArray[0]);
            return new Vec3d(ptr, true);
		}
		throw new InvalidOperationException();
	}
	public void SetTargetOrientation(Quaterniond targetOrientation) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHSpringIf_SetTargetOrientation((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) targetOrientation);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHSpringIf_SetTargetOrientation((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) targetOrientation);
				}
			}
		} else {
	    SprExport.Spr_PHSpringIf_SetTargetOrientation((IntPtr) _thisArray[0], (IntPtr) targetOrientation);
		}
		throw new InvalidOperationException();
	}
	public Quaterniond GetTargetOrientation() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHSpringIf_GetTargetOrientation((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new Quaterniond(ptr, true);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHSpringIf_GetTargetOrientation((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new Quaterniond(ptr, true);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHSpringIf_GetTargetOrientation((IntPtr) _thisArray[0]);
            return new Quaterniond(ptr, true);
		}
		throw new InvalidOperationException();
	}
	public void SetSpring(Vec3d spring) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHSpringIf_SetSpring((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) spring);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHSpringIf_SetSpring((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) spring);
				}
			}
		} else {
	    SprExport.Spr_PHSpringIf_SetSpring((IntPtr) _thisArray[0], (IntPtr) spring);
		}
		throw new InvalidOperationException();
	}
	public Vec3d GetSpring() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHSpringIf_GetSpring((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new Vec3d(ptr, true);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHSpringIf_GetSpring((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new Vec3d(ptr, true);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHSpringIf_GetSpring((IntPtr) _thisArray[0]);
            return new Vec3d(ptr, true);
		}
		throw new InvalidOperationException();
	}
	public void SetDamper(Vec3d damper) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHSpringIf_SetDamper((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) damper);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHSpringIf_SetDamper((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) damper);
				}
			}
		} else {
	    SprExport.Spr_PHSpringIf_SetDamper((IntPtr) _thisArray[0], (IntPtr) damper);
		}
		throw new InvalidOperationException();
	}
	public Vec3d GetDamper() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHSpringIf_GetDamper((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new Vec3d(ptr, true);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHSpringIf_GetDamper((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new Vec3d(ptr, true);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHSpringIf_GetDamper((IntPtr) _thisArray[0]);
            return new Vec3d(ptr, true);
		}
		throw new InvalidOperationException();
	}
	public void SetSecondDamper(Vec3d secondDamper) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHSpringIf_SetSecondDamper((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) secondDamper);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHSpringIf_SetSecondDamper((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) secondDamper);
				}
			}
		} else {
	    SprExport.Spr_PHSpringIf_SetSecondDamper((IntPtr) _thisArray[0], (IntPtr) secondDamper);
		}
		throw new InvalidOperationException();
	}
	public Vec3d GetSecondDamper() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHSpringIf_GetSecondDamper((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new Vec3d(ptr, true);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHSpringIf_GetSecondDamper((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new Vec3d(ptr, true);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHSpringIf_GetSecondDamper((IntPtr) _thisArray[0]);
            return new Vec3d(ptr, true);
		}
		throw new InvalidOperationException();
	}
	public void SetSpringOri(double spring) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHSpringIf_SetSpringOri((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) spring);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHSpringIf_SetSpringOri((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) spring);
				}
			}
		} else {
	    SprExport.Spr_PHSpringIf_SetSpringOri((IntPtr) _thisArray[0], (double) spring);
		}
		throw new InvalidOperationException();
	}
	public double GetSpringOri() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    double result = (double) SprExport.Spr_PHSpringIf_GetSpringOri((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    double result = (double) SprExport.Spr_PHSpringIf_GetSpringOri((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    double result = (double) SprExport.Spr_PHSpringIf_GetSpringOri((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public void SetDamperOri(double damper) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHSpringIf_SetDamperOri((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) damper);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHSpringIf_SetDamperOri((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) damper);
				}
			}
		} else {
	    SprExport.Spr_PHSpringIf_SetDamperOri((IntPtr) _thisArray[0], (double) damper);
		}
		throw new InvalidOperationException();
	}
	public double GetDamperOri() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    double result = (double) SprExport.Spr_PHSpringIf_GetDamperOri((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    double result = (double) SprExport.Spr_PHSpringIf_GetDamperOri((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    double result = (double) SprExport.Spr_PHSpringIf_GetDamperOri((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public void SetSecondDamperOri(double secondDamperOri) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHSpringIf_SetSecondDamperOri((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) secondDamperOri);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHSpringIf_SetSecondDamperOri((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) secondDamperOri);
				}
			}
		} else {
	    SprExport.Spr_PHSpringIf_SetSecondDamperOri((IntPtr) _thisArray[0], (double) secondDamperOri);
		}
		throw new InvalidOperationException();
	}
	public double GetSecondDamperOri() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    double result = (double) SprExport.Spr_PHSpringIf_GetSecondDamperOri((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    double result = (double) SprExport.Spr_PHSpringIf_GetSecondDamperOri((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    double result = (double) SprExport.Spr_PHSpringIf_GetSecondDamperOri((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public void SetYieldStress(double yieldStress) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHSpringIf_SetYieldStress((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) yieldStress);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHSpringIf_SetYieldStress((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) yieldStress);
				}
			}
		} else {
	    SprExport.Spr_PHSpringIf_SetYieldStress((IntPtr) _thisArray[0], (double) yieldStress);
		}
		throw new InvalidOperationException();
	}
	public double GetYieldStress() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    double result = (double) SprExport.Spr_PHSpringIf_GetYieldStress((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    double result = (double) SprExport.Spr_PHSpringIf_GetYieldStress((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    double result = (double) SprExport.Spr_PHSpringIf_GetYieldStress((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public void SetHardnessRate(double hardnessRate) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHSpringIf_SetHardnessRate((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) hardnessRate);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHSpringIf_SetHardnessRate((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) hardnessRate);
				}
			}
		} else {
	    SprExport.Spr_PHSpringIf_SetHardnessRate((IntPtr) _thisArray[0], (double) hardnessRate);
		}
		throw new InvalidOperationException();
	}
	public double GetHardnessRate() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    double result = (double) SprExport.Spr_PHSpringIf_GetHardnessRate((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    double result = (double) SprExport.Spr_PHSpringIf_GetHardnessRate((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    double result = (double) SprExport.Spr_PHSpringIf_GetHardnessRate((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public void SetSecondMoment(Vec3d secondMoment) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHSpringIf_SetSecondMoment((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) secondMoment);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHSpringIf_SetSecondMoment((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) secondMoment);
				}
			}
		} else {
	    SprExport.Spr_PHSpringIf_SetSecondMoment((IntPtr) _thisArray[0], (IntPtr) secondMoment);
		}
		throw new InvalidOperationException();
	}
	public Vec3d GetSecondMoment() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHSpringIf_GetSecondMoment((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new Vec3d(ptr, true);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHSpringIf_GetSecondMoment((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new Vec3d(ptr, true);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHSpringIf_GetSecondMoment((IntPtr) _thisArray[0]);
            return new Vec3d(ptr, true);
		}
		throw new InvalidOperationException();
	}
	public Vec6d GetMotorForce() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHSpringIf_GetMotorForce((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new Vec6d(ptr, true);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHSpringIf_GetMotorForce((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new Vec6d(ptr, true);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHSpringIf_GetMotorForce((IntPtr) _thisArray[0]);
            return new Vec6d(ptr, true);
		}
		throw new InvalidOperationException();
	}
	public void SetOffsetForce(Vec6d offsetForce) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHSpringIf_SetOffsetForce((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) offsetForce);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHSpringIf_SetOffsetForce((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) offsetForce);
				}
			}
		} else {
	    SprExport.Spr_PHSpringIf_SetOffsetForce((IntPtr) _thisArray[0], (IntPtr) offsetForce);
		}
		throw new InvalidOperationException();
	}
	public void SetTargetVelocity(Vec6d targetVelocity) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHSpringIf_SetTargetVelocity((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) targetVelocity);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHSpringIf_SetTargetVelocity((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) targetVelocity);
				}
			}
		} else {
	    SprExport.Spr_PHSpringIf_SetTargetVelocity((IntPtr) _thisArray[0], (IntPtr) targetVelocity);
		}
		throw new InvalidOperationException();
	}
	public Vec6d GetTargetVelocity() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHSpringIf_GetTargetVelocity((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new Vec6d(ptr, true);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHSpringIf_GetTargetVelocity((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new Vec6d(ptr, true);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHSpringIf_GetTargetVelocity((IntPtr) _thisArray[0]);
            return new Vec6d(ptr, true);
		}
		throw new InvalidOperationException();
	}
    }
    public partial class PHMateIf : PHJointIf {
	public PHMateIf() { _thisArray[0] = SprExport.Spr_new_PHMateIf(); _flag = true; }
	public PHMateIf(IntPtr ptr) : base(ptr) {}
	public PHMateIf(IntPtr ptr, bool flag) : base(ptr, flag) {}
	public static implicit operator PHMateIf(CsCastObject target) {
		return (target._info.Inherit(PHMateIf.GetIfInfoStatic()) ? new PHMateIf(target._thisArray[0], target._flag) : null);
	}
	~PHMateIf() { if (_flag) { SprExport.Spr_delete_PHMateIf(_thisArray[0]); _flag = false; } }
        public override string ToString() {
            IntPtr ptr = SprExport.Spr_PHMateIf_ToString((IntPtr) _thisArray[0]);
            string bstr = Marshal.PtrToStringBSTR(ptr);
            SprExport.Spr_PHMateIf_FreeString((IntPtr) ptr);
            return bstr;
        }
	public IfInfo GetIfInfo() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHMateIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new IfInfo(ptr);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHMateIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new IfInfo(ptr);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHMateIf_GetIfInfo((IntPtr) _thisArray[0]);
            return new IfInfo(ptr);
		}
		throw new InvalidOperationException();
	}
	public static IfInfo GetIfInfoStatic() {
	    IntPtr ptr = SprExport.Spr_PHMateIf_GetIfInfoStatic();
            return new IfInfo(ptr);
	}
    }
    public partial class PHPointToPointMateIf : PHMateIf {
	public PHPointToPointMateIf() { _thisArray[0] = SprExport.Spr_new_PHPointToPointMateIf(); _flag = true; }
	public PHPointToPointMateIf(IntPtr ptr) : base(ptr) {}
	public PHPointToPointMateIf(IntPtr ptr, bool flag) : base(ptr, flag) {}
	public static implicit operator PHPointToPointMateIf(CsCastObject target) {
		return (target._info.Inherit(PHPointToPointMateIf.GetIfInfoStatic()) ? new PHPointToPointMateIf(target._thisArray[0], target._flag) : null);
	}
	~PHPointToPointMateIf() { if (_flag) { SprExport.Spr_delete_PHPointToPointMateIf(_thisArray[0]); _flag = false; } }
        public override string ToString() {
            IntPtr ptr = SprExport.Spr_PHPointToPointMateIf_ToString((IntPtr) _thisArray[0]);
            string bstr = Marshal.PtrToStringBSTR(ptr);
            SprExport.Spr_PHPointToPointMateIf_FreeString((IntPtr) ptr);
            return bstr;
        }
	public IfInfo GetIfInfo() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHPointToPointMateIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new IfInfo(ptr);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHPointToPointMateIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new IfInfo(ptr);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHPointToPointMateIf_GetIfInfo((IntPtr) _thisArray[0]);
            return new IfInfo(ptr);
		}
		throw new InvalidOperationException();
	}
	public static IfInfo GetIfInfoStatic() {
	    IntPtr ptr = SprExport.Spr_PHPointToPointMateIf_GetIfInfoStatic();
            return new IfInfo(ptr);
	}
    }
    public partial class PHPointToLineMateIf : PHMateIf {
	public PHPointToLineMateIf() { _thisArray[0] = SprExport.Spr_new_PHPointToLineMateIf(); _flag = true; }
	public PHPointToLineMateIf(IntPtr ptr) : base(ptr) {}
	public PHPointToLineMateIf(IntPtr ptr, bool flag) : base(ptr, flag) {}
	public static implicit operator PHPointToLineMateIf(CsCastObject target) {
		return (target._info.Inherit(PHPointToLineMateIf.GetIfInfoStatic()) ? new PHPointToLineMateIf(target._thisArray[0], target._flag) : null);
	}
	~PHPointToLineMateIf() { if (_flag) { SprExport.Spr_delete_PHPointToLineMateIf(_thisArray[0]); _flag = false; } }
        public override string ToString() {
            IntPtr ptr = SprExport.Spr_PHPointToLineMateIf_ToString((IntPtr) _thisArray[0]);
            string bstr = Marshal.PtrToStringBSTR(ptr);
            SprExport.Spr_PHPointToLineMateIf_FreeString((IntPtr) ptr);
            return bstr;
        }
	public IfInfo GetIfInfo() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHPointToLineMateIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new IfInfo(ptr);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHPointToLineMateIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new IfInfo(ptr);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHPointToLineMateIf_GetIfInfo((IntPtr) _thisArray[0]);
            return new IfInfo(ptr);
		}
		throw new InvalidOperationException();
	}
	public static IfInfo GetIfInfoStatic() {
	    IntPtr ptr = SprExport.Spr_PHPointToLineMateIf_GetIfInfoStatic();
            return new IfInfo(ptr);
	}
    }
    public partial class PHPointToPlaneMateIf : PHMateIf {
	public PHPointToPlaneMateIf() { _thisArray[0] = SprExport.Spr_new_PHPointToPlaneMateIf(); _flag = true; }
	public PHPointToPlaneMateIf(IntPtr ptr) : base(ptr) {}
	public PHPointToPlaneMateIf(IntPtr ptr, bool flag) : base(ptr, flag) {}
	public static implicit operator PHPointToPlaneMateIf(CsCastObject target) {
		return (target._info.Inherit(PHPointToPlaneMateIf.GetIfInfoStatic()) ? new PHPointToPlaneMateIf(target._thisArray[0], target._flag) : null);
	}
	~PHPointToPlaneMateIf() { if (_flag) { SprExport.Spr_delete_PHPointToPlaneMateIf(_thisArray[0]); _flag = false; } }
        public override string ToString() {
            IntPtr ptr = SprExport.Spr_PHPointToPlaneMateIf_ToString((IntPtr) _thisArray[0]);
            string bstr = Marshal.PtrToStringBSTR(ptr);
            SprExport.Spr_PHPointToPlaneMateIf_FreeString((IntPtr) ptr);
            return bstr;
        }
	public IfInfo GetIfInfo() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHPointToPlaneMateIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new IfInfo(ptr);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHPointToPlaneMateIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new IfInfo(ptr);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHPointToPlaneMateIf_GetIfInfo((IntPtr) _thisArray[0]);
            return new IfInfo(ptr);
		}
		throw new InvalidOperationException();
	}
	public static IfInfo GetIfInfoStatic() {
	    IntPtr ptr = SprExport.Spr_PHPointToPlaneMateIf_GetIfInfoStatic();
            return new IfInfo(ptr);
	}
	public void SetRange(Vec2d range) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHPointToPlaneMateIf_SetRange((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) range);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHPointToPlaneMateIf_SetRange((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) range);
				}
			}
		} else {
	    SprExport.Spr_PHPointToPlaneMateIf_SetRange((IntPtr) _thisArray[0], (IntPtr) range);
		}
		throw new InvalidOperationException();
	}
	public void GetRange(Vec2d range) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHPointToPlaneMateIf_GetRange((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) range);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHPointToPlaneMateIf_GetRange((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) range);
				}
			}
		} else {
	    SprExport.Spr_PHPointToPlaneMateIf_GetRange((IntPtr) _thisArray[0], (IntPtr) range);
		}
		throw new InvalidOperationException();
	}
    }
    public partial class PHLineToLineMateIf : PHMateIf {
	public PHLineToLineMateIf() { _thisArray[0] = SprExport.Spr_new_PHLineToLineMateIf(); _flag = true; }
	public PHLineToLineMateIf(IntPtr ptr) : base(ptr) {}
	public PHLineToLineMateIf(IntPtr ptr, bool flag) : base(ptr, flag) {}
	public static implicit operator PHLineToLineMateIf(CsCastObject target) {
		return (target._info.Inherit(PHLineToLineMateIf.GetIfInfoStatic()) ? new PHLineToLineMateIf(target._thisArray[0], target._flag) : null);
	}
	~PHLineToLineMateIf() { if (_flag) { SprExport.Spr_delete_PHLineToLineMateIf(_thisArray[0]); _flag = false; } }
        public override string ToString() {
            IntPtr ptr = SprExport.Spr_PHLineToLineMateIf_ToString((IntPtr) _thisArray[0]);
            string bstr = Marshal.PtrToStringBSTR(ptr);
            SprExport.Spr_PHLineToLineMateIf_FreeString((IntPtr) ptr);
            return bstr;
        }
	public IfInfo GetIfInfo() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHLineToLineMateIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new IfInfo(ptr);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHLineToLineMateIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new IfInfo(ptr);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHLineToLineMateIf_GetIfInfo((IntPtr) _thisArray[0]);
            return new IfInfo(ptr);
		}
		throw new InvalidOperationException();
	}
	public static IfInfo GetIfInfoStatic() {
	    IntPtr ptr = SprExport.Spr_PHLineToLineMateIf_GetIfInfoStatic();
            return new IfInfo(ptr);
	}
    }
    public partial class PHPlaneToPlaneMateIf : PHMateIf {
	public PHPlaneToPlaneMateIf() { _thisArray[0] = SprExport.Spr_new_PHPlaneToPlaneMateIf(); _flag = true; }
	public PHPlaneToPlaneMateIf(IntPtr ptr) : base(ptr) {}
	public PHPlaneToPlaneMateIf(IntPtr ptr, bool flag) : base(ptr, flag) {}
	public static implicit operator PHPlaneToPlaneMateIf(CsCastObject target) {
		return (target._info.Inherit(PHPlaneToPlaneMateIf.GetIfInfoStatic()) ? new PHPlaneToPlaneMateIf(target._thisArray[0], target._flag) : null);
	}
	~PHPlaneToPlaneMateIf() { if (_flag) { SprExport.Spr_delete_PHPlaneToPlaneMateIf(_thisArray[0]); _flag = false; } }
        public override string ToString() {
            IntPtr ptr = SprExport.Spr_PHPlaneToPlaneMateIf_ToString((IntPtr) _thisArray[0]);
            string bstr = Marshal.PtrToStringBSTR(ptr);
            SprExport.Spr_PHPlaneToPlaneMateIf_FreeString((IntPtr) ptr);
            return bstr;
        }
	public IfInfo GetIfInfo() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHPlaneToPlaneMateIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new IfInfo(ptr);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHPlaneToPlaneMateIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new IfInfo(ptr);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHPlaneToPlaneMateIf_GetIfInfo((IntPtr) _thisArray[0]);
            return new IfInfo(ptr);
		}
		throw new InvalidOperationException();
	}
	public static IfInfo GetIfInfoStatic() {
	    IntPtr ptr = SprExport.Spr_PHPlaneToPlaneMateIf_GetIfInfoStatic();
            return new IfInfo(ptr);
	}
    }
    public partial class PHTreeNodeIf : SceneObjectIf {
	public PHTreeNodeIf() { _thisArray[0] = SprExport.Spr_new_PHTreeNodeIf(); _flag = true; }
	public PHTreeNodeIf(IntPtr ptr) : base(ptr) {}
	public PHTreeNodeIf(IntPtr ptr, bool flag) : base(ptr, flag) {}
	public static implicit operator PHTreeNodeIf(CsCastObject target) {
		return (target._info.Inherit(PHTreeNodeIf.GetIfInfoStatic()) ? new PHTreeNodeIf(target._thisArray[0], target._flag) : null);
	}
	~PHTreeNodeIf() { if (_flag) { SprExport.Spr_delete_PHTreeNodeIf(_thisArray[0]); _flag = false; } }
        public override string ToString() {
            IntPtr ptr = SprExport.Spr_PHTreeNodeIf_ToString((IntPtr) _thisArray[0]);
            string bstr = Marshal.PtrToStringBSTR(ptr);
            SprExport.Spr_PHTreeNodeIf_FreeString((IntPtr) ptr);
            return bstr;
        }
	public IfInfo GetIfInfo() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHTreeNodeIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new IfInfo(ptr);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHTreeNodeIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new IfInfo(ptr);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHTreeNodeIf_GetIfInfo((IntPtr) _thisArray[0]);
            return new IfInfo(ptr);
		}
		throw new InvalidOperationException();
	}
	public static IfInfo GetIfInfoStatic() {
	    IntPtr ptr = SprExport.Spr_PHTreeNodeIf_GetIfInfoStatic();
            return new IfInfo(ptr);
	}
	public void Enable(bool bEnable) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHTreeNodeIf_Enable((IntPtr) _thisArray[phSceneIf.sceneForStep], (bool) bEnable);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHTreeNodeIf_Enable((IntPtr) _thisArray[phSceneIf.sceneForGet], (bool) bEnable);
				}
			}
		} else {
	    SprExport.Spr_PHTreeNodeIf_Enable((IntPtr) _thisArray[0], (bool) bEnable);
		}
		throw new InvalidOperationException();
	}
	public void Enable() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHTreeNodeIf_Enable_1((IntPtr) _thisArray[phSceneIf.sceneForStep]);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHTreeNodeIf_Enable_1((IntPtr) _thisArray[phSceneIf.sceneForGet]);
				}
			}
		} else {
	    SprExport.Spr_PHTreeNodeIf_Enable_1((IntPtr) _thisArray[0]);
		}
		throw new InvalidOperationException();
	}
	public bool IsEnabled() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    char ret = SprExport.Spr_PHTreeNodeIf_IsEnabled((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return (ret == 0) ? false : true;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    char ret = SprExport.Spr_PHTreeNodeIf_IsEnabled((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return (ret == 0) ? false : true;
				}
			}
		} else {
	    char ret = SprExport.Spr_PHTreeNodeIf_IsEnabled((IntPtr) _thisArray[0]);
	    return (ret == 0) ? false : true;
		}
		throw new InvalidOperationException();
	}
	public int NChildren() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    int result = (int) SprExport.Spr_PHTreeNodeIf_NChildren((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    int result = (int) SprExport.Spr_PHTreeNodeIf_NChildren((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    int result = (int) SprExport.Spr_PHTreeNodeIf_NChildren((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public PHTreeNodeIf GetParentNode() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHTreeNodeIf_GetParentNode((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            if (ptr == IntPtr.Zero) { return null; } 
            PHTreeNodeIf obj = new PHTreeNodeIf(ptr);
            if (obj.GetIfInfo() == PHRootNodeIf.GetIfInfoStatic()) { return new PHRootNodeIf(ptr); }
            if (obj.GetIfInfo() == PHTreeNode1DIf.GetIfInfoStatic()) { return new PHTreeNode1DIf(ptr); }
            if (obj.GetIfInfo() == PHBallJointNodeIf.GetIfInfoStatic()) { return new PHBallJointNodeIf(ptr); }
            if (obj.GetIfInfo() == PHFixJointNodeIf.GetIfInfoStatic()) { return new PHFixJointNodeIf(ptr); }
            if (obj.GetIfInfo() == PHHingeJointNodeIf.GetIfInfoStatic()) { return new PHHingeJointNodeIf(ptr); }
            if (obj.GetIfInfo() == PHSliderJointNodeIf.GetIfInfoStatic()) { return new PHSliderJointNodeIf(ptr); }
            if (obj.GetIfInfo() == PHPathJointNodeIf.GetIfInfoStatic()) { return new PHPathJointNodeIf(ptr); }
            if (obj.GetIfInfo() == PHGenericJointNodeIf.GetIfInfoStatic()) { return new PHGenericJointNodeIf(ptr); }
            return obj;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHTreeNodeIf_GetParentNode((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            if (ptr == IntPtr.Zero) { return null; } 
            PHTreeNodeIf obj = new PHTreeNodeIf(ptr);
            if (obj.GetIfInfo() == PHRootNodeIf.GetIfInfoStatic()) { return new PHRootNodeIf(ptr); }
            if (obj.GetIfInfo() == PHTreeNode1DIf.GetIfInfoStatic()) { return new PHTreeNode1DIf(ptr); }
            if (obj.GetIfInfo() == PHBallJointNodeIf.GetIfInfoStatic()) { return new PHBallJointNodeIf(ptr); }
            if (obj.GetIfInfo() == PHFixJointNodeIf.GetIfInfoStatic()) { return new PHFixJointNodeIf(ptr); }
            if (obj.GetIfInfo() == PHHingeJointNodeIf.GetIfInfoStatic()) { return new PHHingeJointNodeIf(ptr); }
            if (obj.GetIfInfo() == PHSliderJointNodeIf.GetIfInfoStatic()) { return new PHSliderJointNodeIf(ptr); }
            if (obj.GetIfInfo() == PHPathJointNodeIf.GetIfInfoStatic()) { return new PHPathJointNodeIf(ptr); }
            if (obj.GetIfInfo() == PHGenericJointNodeIf.GetIfInfoStatic()) { return new PHGenericJointNodeIf(ptr); }
            return obj;
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHTreeNodeIf_GetParentNode((IntPtr) _thisArray[0]);
            if (ptr == IntPtr.Zero) { return null; } 
            PHTreeNodeIf obj = new PHTreeNodeIf(ptr);
            if (obj.GetIfInfo() == PHRootNodeIf.GetIfInfoStatic()) { return new PHRootNodeIf(ptr); }
            if (obj.GetIfInfo() == PHTreeNode1DIf.GetIfInfoStatic()) { return new PHTreeNode1DIf(ptr); }
            if (obj.GetIfInfo() == PHBallJointNodeIf.GetIfInfoStatic()) { return new PHBallJointNodeIf(ptr); }
            if (obj.GetIfInfo() == PHFixJointNodeIf.GetIfInfoStatic()) { return new PHFixJointNodeIf(ptr); }
            if (obj.GetIfInfo() == PHHingeJointNodeIf.GetIfInfoStatic()) { return new PHHingeJointNodeIf(ptr); }
            if (obj.GetIfInfo() == PHSliderJointNodeIf.GetIfInfoStatic()) { return new PHSliderJointNodeIf(ptr); }
            if (obj.GetIfInfo() == PHPathJointNodeIf.GetIfInfoStatic()) { return new PHPathJointNodeIf(ptr); }
            if (obj.GetIfInfo() == PHGenericJointNodeIf.GetIfInfoStatic()) { return new PHGenericJointNodeIf(ptr); }
            return obj;
		}
		throw new InvalidOperationException();
	}
	public PHTreeNodeIf GetChildNode(int i) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHTreeNodeIf_GetChildNode((IntPtr) _thisArray[phSceneIf.sceneForStep], (int) i);
            if (ptr == IntPtr.Zero) { return null; } 
            PHTreeNodeIf obj = new PHTreeNodeIf(ptr);
            if (obj.GetIfInfo() == PHRootNodeIf.GetIfInfoStatic()) { return new PHRootNodeIf(ptr); }
            if (obj.GetIfInfo() == PHTreeNode1DIf.GetIfInfoStatic()) { return new PHTreeNode1DIf(ptr); }
            if (obj.GetIfInfo() == PHBallJointNodeIf.GetIfInfoStatic()) { return new PHBallJointNodeIf(ptr); }
            if (obj.GetIfInfo() == PHFixJointNodeIf.GetIfInfoStatic()) { return new PHFixJointNodeIf(ptr); }
            if (obj.GetIfInfo() == PHHingeJointNodeIf.GetIfInfoStatic()) { return new PHHingeJointNodeIf(ptr); }
            if (obj.GetIfInfo() == PHSliderJointNodeIf.GetIfInfoStatic()) { return new PHSliderJointNodeIf(ptr); }
            if (obj.GetIfInfo() == PHPathJointNodeIf.GetIfInfoStatic()) { return new PHPathJointNodeIf(ptr); }
            if (obj.GetIfInfo() == PHGenericJointNodeIf.GetIfInfoStatic()) { return new PHGenericJointNodeIf(ptr); }
            return obj;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHTreeNodeIf_GetChildNode((IntPtr) _thisArray[phSceneIf.sceneForGet], (int) i);
            if (ptr == IntPtr.Zero) { return null; } 
            PHTreeNodeIf obj = new PHTreeNodeIf(ptr);
            if (obj.GetIfInfo() == PHRootNodeIf.GetIfInfoStatic()) { return new PHRootNodeIf(ptr); }
            if (obj.GetIfInfo() == PHTreeNode1DIf.GetIfInfoStatic()) { return new PHTreeNode1DIf(ptr); }
            if (obj.GetIfInfo() == PHBallJointNodeIf.GetIfInfoStatic()) { return new PHBallJointNodeIf(ptr); }
            if (obj.GetIfInfo() == PHFixJointNodeIf.GetIfInfoStatic()) { return new PHFixJointNodeIf(ptr); }
            if (obj.GetIfInfo() == PHHingeJointNodeIf.GetIfInfoStatic()) { return new PHHingeJointNodeIf(ptr); }
            if (obj.GetIfInfo() == PHSliderJointNodeIf.GetIfInfoStatic()) { return new PHSliderJointNodeIf(ptr); }
            if (obj.GetIfInfo() == PHPathJointNodeIf.GetIfInfoStatic()) { return new PHPathJointNodeIf(ptr); }
            if (obj.GetIfInfo() == PHGenericJointNodeIf.GetIfInfoStatic()) { return new PHGenericJointNodeIf(ptr); }
            return obj;
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHTreeNodeIf_GetChildNode((IntPtr) _thisArray[0], (int) i);
            if (ptr == IntPtr.Zero) { return null; } 
            PHTreeNodeIf obj = new PHTreeNodeIf(ptr);
            if (obj.GetIfInfo() == PHRootNodeIf.GetIfInfoStatic()) { return new PHRootNodeIf(ptr); }
            if (obj.GetIfInfo() == PHTreeNode1DIf.GetIfInfoStatic()) { return new PHTreeNode1DIf(ptr); }
            if (obj.GetIfInfo() == PHBallJointNodeIf.GetIfInfoStatic()) { return new PHBallJointNodeIf(ptr); }
            if (obj.GetIfInfo() == PHFixJointNodeIf.GetIfInfoStatic()) { return new PHFixJointNodeIf(ptr); }
            if (obj.GetIfInfo() == PHHingeJointNodeIf.GetIfInfoStatic()) { return new PHHingeJointNodeIf(ptr); }
            if (obj.GetIfInfo() == PHSliderJointNodeIf.GetIfInfoStatic()) { return new PHSliderJointNodeIf(ptr); }
            if (obj.GetIfInfo() == PHPathJointNodeIf.GetIfInfoStatic()) { return new PHPathJointNodeIf(ptr); }
            if (obj.GetIfInfo() == PHGenericJointNodeIf.GetIfInfoStatic()) { return new PHGenericJointNodeIf(ptr); }
            return obj;
		}
		throw new InvalidOperationException();
	}
	public PHRootNodeIf GetRootNode() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHTreeNodeIf_GetRootNode((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            if (ptr == IntPtr.Zero) { return null; } 
            PHRootNodeIf obj = new PHRootNodeIf(ptr);
            return obj;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHTreeNodeIf_GetRootNode((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            if (ptr == IntPtr.Zero) { return null; } 
            PHRootNodeIf obj = new PHRootNodeIf(ptr);
            return obj;
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHTreeNodeIf_GetRootNode((IntPtr) _thisArray[0]);
            if (ptr == IntPtr.Zero) { return null; } 
            PHRootNodeIf obj = new PHRootNodeIf(ptr);
            return obj;
		}
		throw new InvalidOperationException();
	}
	public PHSolidIf GetSolid() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHTreeNodeIf_GetSolid((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            if (ptr == IntPtr.Zero) { return null; } 
            PHSolidIf obj = new PHSolidIf(ptr);
            if (obj.GetIfInfo() == PHHapticPointerIf.GetIfInfoStatic()) { return new PHHapticPointerIf(ptr); }
            return obj;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHTreeNodeIf_GetSolid((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            if (ptr == IntPtr.Zero) { return null; } 
            PHSolidIf obj = new PHSolidIf(ptr);
            if (obj.GetIfInfo() == PHHapticPointerIf.GetIfInfoStatic()) { return new PHHapticPointerIf(ptr); }
            return obj;
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHTreeNodeIf_GetSolid((IntPtr) _thisArray[0]);
            if (ptr == IntPtr.Zero) { return null; } 
            PHSolidIf obj = new PHSolidIf(ptr);
            if (obj.GetIfInfo() == PHHapticPointerIf.GetIfInfoStatic()) { return new PHHapticPointerIf(ptr); }
            return obj;
		}
		throw new InvalidOperationException();
	}
    }
    public partial class PHRootNodeIf : PHTreeNodeIf {
	public PHRootNodeIf() { _thisArray[0] = SprExport.Spr_new_PHRootNodeIf(); _flag = true; }
	public PHRootNodeIf(IntPtr ptr) : base(ptr) {}
	public PHRootNodeIf(IntPtr ptr, bool flag) : base(ptr, flag) {}
	public static implicit operator PHRootNodeIf(CsCastObject target) {
		return (target._info.Inherit(PHRootNodeIf.GetIfInfoStatic()) ? new PHRootNodeIf(target._thisArray[0], target._flag) : null);
	}
	~PHRootNodeIf() { if (_flag) { SprExport.Spr_delete_PHRootNodeIf(_thisArray[0]); _flag = false; } }
        public override string ToString() {
            IntPtr ptr = SprExport.Spr_PHRootNodeIf_ToString((IntPtr) _thisArray[0]);
            string bstr = Marshal.PtrToStringBSTR(ptr);
            SprExport.Spr_PHRootNodeIf_FreeString((IntPtr) ptr);
            return bstr;
        }
	public IfInfo GetIfInfo() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHRootNodeIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new IfInfo(ptr);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHRootNodeIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new IfInfo(ptr);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHRootNodeIf_GetIfInfo((IntPtr) _thisArray[0]);
            return new IfInfo(ptr);
		}
		throw new InvalidOperationException();
	}
	public static IfInfo GetIfInfoStatic() {
	    IntPtr ptr = SprExport.Spr_PHRootNodeIf_GetIfInfoStatic();
            return new IfInfo(ptr);
	}
    }
    public partial class PHTreeNode1DIf : PHTreeNodeIf {
	public PHTreeNode1DIf() { _thisArray[0] = SprExport.Spr_new_PHTreeNode1DIf(); _flag = true; }
	public PHTreeNode1DIf(IntPtr ptr) : base(ptr) {}
	public PHTreeNode1DIf(IntPtr ptr, bool flag) : base(ptr, flag) {}
	public static implicit operator PHTreeNode1DIf(CsCastObject target) {
		return (target._info.Inherit(PHTreeNode1DIf.GetIfInfoStatic()) ? new PHTreeNode1DIf(target._thisArray[0], target._flag) : null);
	}
	~PHTreeNode1DIf() { if (_flag) { SprExport.Spr_delete_PHTreeNode1DIf(_thisArray[0]); _flag = false; } }
        public override string ToString() {
            IntPtr ptr = SprExport.Spr_PHTreeNode1DIf_ToString((IntPtr) _thisArray[0]);
            string bstr = Marshal.PtrToStringBSTR(ptr);
            SprExport.Spr_PHTreeNode1DIf_FreeString((IntPtr) ptr);
            return bstr;
        }
	public IfInfo GetIfInfo() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHTreeNode1DIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new IfInfo(ptr);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHTreeNode1DIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new IfInfo(ptr);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHTreeNode1DIf_GetIfInfo((IntPtr) _thisArray[0]);
            return new IfInfo(ptr);
		}
		throw new InvalidOperationException();
	}
	public static IfInfo GetIfInfoStatic() {
	    IntPtr ptr = SprExport.Spr_PHTreeNode1DIf_GetIfInfoStatic();
            return new IfInfo(ptr);
	}
    }
    public partial class PHHingeJointNodeIf : PHTreeNode1DIf {
	public PHHingeJointNodeIf() { _thisArray[0] = SprExport.Spr_new_PHHingeJointNodeIf(); _flag = true; }
	public PHHingeJointNodeIf(IntPtr ptr) : base(ptr) {}
	public PHHingeJointNodeIf(IntPtr ptr, bool flag) : base(ptr, flag) {}
	public static implicit operator PHHingeJointNodeIf(CsCastObject target) {
		return (target._info.Inherit(PHHingeJointNodeIf.GetIfInfoStatic()) ? new PHHingeJointNodeIf(target._thisArray[0], target._flag) : null);
	}
	~PHHingeJointNodeIf() { if (_flag) { SprExport.Spr_delete_PHHingeJointNodeIf(_thisArray[0]); _flag = false; } }
        public override string ToString() {
            IntPtr ptr = SprExport.Spr_PHHingeJointNodeIf_ToString((IntPtr) _thisArray[0]);
            string bstr = Marshal.PtrToStringBSTR(ptr);
            SprExport.Spr_PHHingeJointNodeIf_FreeString((IntPtr) ptr);
            return bstr;
        }
	public IfInfo GetIfInfo() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHHingeJointNodeIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new IfInfo(ptr);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHHingeJointNodeIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new IfInfo(ptr);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHHingeJointNodeIf_GetIfInfo((IntPtr) _thisArray[0]);
            return new IfInfo(ptr);
		}
		throw new InvalidOperationException();
	}
	public static IfInfo GetIfInfoStatic() {
	    IntPtr ptr = SprExport.Spr_PHHingeJointNodeIf_GetIfInfoStatic();
            return new IfInfo(ptr);
	}
    }
    public partial class PHSliderJointNodeIf : PHTreeNode1DIf {
	public PHSliderJointNodeIf() { _thisArray[0] = SprExport.Spr_new_PHSliderJointNodeIf(); _flag = true; }
	public PHSliderJointNodeIf(IntPtr ptr) : base(ptr) {}
	public PHSliderJointNodeIf(IntPtr ptr, bool flag) : base(ptr, flag) {}
	public static implicit operator PHSliderJointNodeIf(CsCastObject target) {
		return (target._info.Inherit(PHSliderJointNodeIf.GetIfInfoStatic()) ? new PHSliderJointNodeIf(target._thisArray[0], target._flag) : null);
	}
	~PHSliderJointNodeIf() { if (_flag) { SprExport.Spr_delete_PHSliderJointNodeIf(_thisArray[0]); _flag = false; } }
        public override string ToString() {
            IntPtr ptr = SprExport.Spr_PHSliderJointNodeIf_ToString((IntPtr) _thisArray[0]);
            string bstr = Marshal.PtrToStringBSTR(ptr);
            SprExport.Spr_PHSliderJointNodeIf_FreeString((IntPtr) ptr);
            return bstr;
        }
	public IfInfo GetIfInfo() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHSliderJointNodeIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new IfInfo(ptr);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHSliderJointNodeIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new IfInfo(ptr);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHSliderJointNodeIf_GetIfInfo((IntPtr) _thisArray[0]);
            return new IfInfo(ptr);
		}
		throw new InvalidOperationException();
	}
	public static IfInfo GetIfInfoStatic() {
	    IntPtr ptr = SprExport.Spr_PHSliderJointNodeIf_GetIfInfoStatic();
            return new IfInfo(ptr);
	}
    }
    public partial class PHPathJointNodeIf : PHTreeNode1DIf {
	public PHPathJointNodeIf() { _thisArray[0] = SprExport.Spr_new_PHPathJointNodeIf(); _flag = true; }
	public PHPathJointNodeIf(IntPtr ptr) : base(ptr) {}
	public PHPathJointNodeIf(IntPtr ptr, bool flag) : base(ptr, flag) {}
	public static implicit operator PHPathJointNodeIf(CsCastObject target) {
		return (target._info.Inherit(PHPathJointNodeIf.GetIfInfoStatic()) ? new PHPathJointNodeIf(target._thisArray[0], target._flag) : null);
	}
	~PHPathJointNodeIf() { if (_flag) { SprExport.Spr_delete_PHPathJointNodeIf(_thisArray[0]); _flag = false; } }
        public override string ToString() {
            IntPtr ptr = SprExport.Spr_PHPathJointNodeIf_ToString((IntPtr) _thisArray[0]);
            string bstr = Marshal.PtrToStringBSTR(ptr);
            SprExport.Spr_PHPathJointNodeIf_FreeString((IntPtr) ptr);
            return bstr;
        }
	public IfInfo GetIfInfo() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHPathJointNodeIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new IfInfo(ptr);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHPathJointNodeIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new IfInfo(ptr);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHPathJointNodeIf_GetIfInfo((IntPtr) _thisArray[0]);
            return new IfInfo(ptr);
		}
		throw new InvalidOperationException();
	}
	public static IfInfo GetIfInfoStatic() {
	    IntPtr ptr = SprExport.Spr_PHPathJointNodeIf_GetIfInfoStatic();
            return new IfInfo(ptr);
	}
    }
    public partial class PHGenericJointNodeIf : PHTreeNode1DIf {
	public PHGenericJointNodeIf() { _thisArray[0] = SprExport.Spr_new_PHGenericJointNodeIf(); _flag = true; }
	public PHGenericJointNodeIf(IntPtr ptr) : base(ptr) {}
	public PHGenericJointNodeIf(IntPtr ptr, bool flag) : base(ptr, flag) {}
	public static implicit operator PHGenericJointNodeIf(CsCastObject target) {
		return (target._info.Inherit(PHGenericJointNodeIf.GetIfInfoStatic()) ? new PHGenericJointNodeIf(target._thisArray[0], target._flag) : null);
	}
	~PHGenericJointNodeIf() { if (_flag) { SprExport.Spr_delete_PHGenericJointNodeIf(_thisArray[0]); _flag = false; } }
        public override string ToString() {
            IntPtr ptr = SprExport.Spr_PHGenericJointNodeIf_ToString((IntPtr) _thisArray[0]);
            string bstr = Marshal.PtrToStringBSTR(ptr);
            SprExport.Spr_PHGenericJointNodeIf_FreeString((IntPtr) ptr);
            return bstr;
        }
	public IfInfo GetIfInfo() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHGenericJointNodeIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new IfInfo(ptr);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHGenericJointNodeIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new IfInfo(ptr);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHGenericJointNodeIf_GetIfInfo((IntPtr) _thisArray[0]);
            return new IfInfo(ptr);
		}
		throw new InvalidOperationException();
	}
	public static IfInfo GetIfInfoStatic() {
	    IntPtr ptr = SprExport.Spr_PHGenericJointNodeIf_GetIfInfoStatic();
            return new IfInfo(ptr);
	}
    }
    public partial class PHBallJointNodeIf : PHTreeNodeIf {
	public PHBallJointNodeIf() { _thisArray[0] = SprExport.Spr_new_PHBallJointNodeIf(); _flag = true; }
	public PHBallJointNodeIf(IntPtr ptr) : base(ptr) {}
	public PHBallJointNodeIf(IntPtr ptr, bool flag) : base(ptr, flag) {}
	public static implicit operator PHBallJointNodeIf(CsCastObject target) {
		return (target._info.Inherit(PHBallJointNodeIf.GetIfInfoStatic()) ? new PHBallJointNodeIf(target._thisArray[0], target._flag) : null);
	}
	~PHBallJointNodeIf() { if (_flag) { SprExport.Spr_delete_PHBallJointNodeIf(_thisArray[0]); _flag = false; } }
        public override string ToString() {
            IntPtr ptr = SprExport.Spr_PHBallJointNodeIf_ToString((IntPtr) _thisArray[0]);
            string bstr = Marshal.PtrToStringBSTR(ptr);
            SprExport.Spr_PHBallJointNodeIf_FreeString((IntPtr) ptr);
            return bstr;
        }
	public IfInfo GetIfInfo() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHBallJointNodeIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new IfInfo(ptr);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHBallJointNodeIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new IfInfo(ptr);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHBallJointNodeIf_GetIfInfo((IntPtr) _thisArray[0]);
            return new IfInfo(ptr);
		}
		throw new InvalidOperationException();
	}
	public static IfInfo GetIfInfoStatic() {
	    IntPtr ptr = SprExport.Spr_PHBallJointNodeIf_GetIfInfoStatic();
            return new IfInfo(ptr);
	}
    }
    public partial class PHFixJointNodeIf : PHTreeNodeIf {
	public PHFixJointNodeIf() { _thisArray[0] = SprExport.Spr_new_PHFixJointNodeIf(); _flag = true; }
	public PHFixJointNodeIf(IntPtr ptr) : base(ptr) {}
	public PHFixJointNodeIf(IntPtr ptr, bool flag) : base(ptr, flag) {}
	public static implicit operator PHFixJointNodeIf(CsCastObject target) {
		return (target._info.Inherit(PHFixJointNodeIf.GetIfInfoStatic()) ? new PHFixJointNodeIf(target._thisArray[0], target._flag) : null);
	}
	~PHFixJointNodeIf() { if (_flag) { SprExport.Spr_delete_PHFixJointNodeIf(_thisArray[0]); _flag = false; } }
        public override string ToString() {
            IntPtr ptr = SprExport.Spr_PHFixJointNodeIf_ToString((IntPtr) _thisArray[0]);
            string bstr = Marshal.PtrToStringBSTR(ptr);
            SprExport.Spr_PHFixJointNodeIf_FreeString((IntPtr) ptr);
            return bstr;
        }
	public IfInfo GetIfInfo() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHFixJointNodeIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new IfInfo(ptr);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHFixJointNodeIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new IfInfo(ptr);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHFixJointNodeIf_GetIfInfo((IntPtr) _thisArray[0]);
            return new IfInfo(ptr);
		}
		throw new InvalidOperationException();
	}
	public static IfInfo GetIfInfoStatic() {
	    IntPtr ptr = SprExport.Spr_PHFixJointNodeIf_GetIfInfoStatic();
            return new IfInfo(ptr);
	}
    }
    public partial class PHGearIf : SceneObjectIf {
	public PHGearIf() { _thisArray[0] = SprExport.Spr_new_PHGearIf(); _flag = true; }
	public PHGearIf(IntPtr ptr) : base(ptr) {}
	public PHGearIf(IntPtr ptr, bool flag) : base(ptr, flag) {}
	public static implicit operator PHGearIf(CsCastObject target) {
		return (target._info.Inherit(PHGearIf.GetIfInfoStatic()) ? new PHGearIf(target._thisArray[0], target._flag) : null);
	}
	~PHGearIf() { if (_flag) { SprExport.Spr_delete_PHGearIf(_thisArray[0]); _flag = false; } }
        public override string ToString() {
            IntPtr ptr = SprExport.Spr_PHGearIf_ToString((IntPtr) _thisArray[0]);
            string bstr = Marshal.PtrToStringBSTR(ptr);
            SprExport.Spr_PHGearIf_FreeString((IntPtr) ptr);
            return bstr;
        }
	public IfInfo GetIfInfo() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHGearIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new IfInfo(ptr);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHGearIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new IfInfo(ptr);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHGearIf_GetIfInfo((IntPtr) _thisArray[0]);
            return new IfInfo(ptr);
		}
		throw new InvalidOperationException();
	}
	public static IfInfo GetIfInfoStatic() {
	    IntPtr ptr = SprExport.Spr_PHGearIf_GetIfInfoStatic();
            return new IfInfo(ptr);
	}
	public void Enable(bool bEnable) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHGearIf_Enable((IntPtr) _thisArray[phSceneIf.sceneForStep], (bool) bEnable);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHGearIf_Enable((IntPtr) _thisArray[phSceneIf.sceneForGet], (bool) bEnable);
				}
			}
		} else {
	    SprExport.Spr_PHGearIf_Enable((IntPtr) _thisArray[0], (bool) bEnable);
		}
		throw new InvalidOperationException();
	}
	public void Enable() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHGearIf_Enable_1((IntPtr) _thisArray[phSceneIf.sceneForStep]);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHGearIf_Enable_1((IntPtr) _thisArray[phSceneIf.sceneForGet]);
				}
			}
		} else {
	    SprExport.Spr_PHGearIf_Enable_1((IntPtr) _thisArray[0]);
		}
		throw new InvalidOperationException();
	}
	public bool IsEnabled() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    char ret = SprExport.Spr_PHGearIf_IsEnabled((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return (ret == 0) ? false : true;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    char ret = SprExport.Spr_PHGearIf_IsEnabled((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return (ret == 0) ? false : true;
				}
			}
		} else {
	    char ret = SprExport.Spr_PHGearIf_IsEnabled((IntPtr) _thisArray[0]);
	    return (ret == 0) ? false : true;
		}
		throw new InvalidOperationException();
	}
	public void SetRatio(double ratio) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHGearIf_SetRatio((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) ratio);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHGearIf_SetRatio((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) ratio);
				}
			}
		} else {
	    SprExport.Spr_PHGearIf_SetRatio((IntPtr) _thisArray[0], (double) ratio);
		}
		throw new InvalidOperationException();
	}
	public double GetRatio() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    double result = (double) SprExport.Spr_PHGearIf_GetRatio((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    double result = (double) SprExport.Spr_PHGearIf_GetRatio((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    double result = (double) SprExport.Spr_PHGearIf_GetRatio((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public void SetOffset(double offset) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHGearIf_SetOffset((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) offset);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHGearIf_SetOffset((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) offset);
				}
			}
		} else {
	    SprExport.Spr_PHGearIf_SetOffset((IntPtr) _thisArray[0], (double) offset);
		}
		throw new InvalidOperationException();
	}
	public double GetOffset() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    double result = (double) SprExport.Spr_PHGearIf_GetOffset((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    double result = (double) SprExport.Spr_PHGearIf_GetOffset((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    double result = (double) SprExport.Spr_PHGearIf_GetOffset((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public void SetMode(int mode) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHGearIf_SetMode((IntPtr) _thisArray[phSceneIf.sceneForStep], (int) mode);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHGearIf_SetMode((IntPtr) _thisArray[phSceneIf.sceneForGet], (int) mode);
				}
			}
		} else {
	    SprExport.Spr_PHGearIf_SetMode((IntPtr) _thisArray[0], (int) mode);
		}
		throw new InvalidOperationException();
	}
	public int GetMode() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    int result = (int) SprExport.Spr_PHGearIf_GetMode((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    int result = (int) SprExport.Spr_PHGearIf_GetMode((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    int result = (int) SprExport.Spr_PHGearIf_GetMode((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
    }
    public partial class PH1DJointLimitIf : SceneObjectIf {
	public PH1DJointLimitIf() { _thisArray[0] = SprExport.Spr_new_PH1DJointLimitIf(); _flag = true; }
	public PH1DJointLimitIf(IntPtr ptr) : base(ptr) {}
	public PH1DJointLimitIf(IntPtr ptr, bool flag) : base(ptr, flag) {}
	public static implicit operator PH1DJointLimitIf(CsCastObject target) {
		return (target._info.Inherit(PH1DJointLimitIf.GetIfInfoStatic()) ? new PH1DJointLimitIf(target._thisArray[0], target._flag) : null);
	}
	~PH1DJointLimitIf() { if (_flag) { SprExport.Spr_delete_PH1DJointLimitIf(_thisArray[0]); _flag = false; } }
        public override string ToString() {
            IntPtr ptr = SprExport.Spr_PH1DJointLimitIf_ToString((IntPtr) _thisArray[0]);
            string bstr = Marshal.PtrToStringBSTR(ptr);
            SprExport.Spr_PH1DJointLimitIf_FreeString((IntPtr) ptr);
            return bstr;
        }
	public IfInfo GetIfInfo() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PH1DJointLimitIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new IfInfo(ptr);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PH1DJointLimitIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new IfInfo(ptr);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PH1DJointLimitIf_GetIfInfo((IntPtr) _thisArray[0]);
            return new IfInfo(ptr);
		}
		throw new InvalidOperationException();
	}
	public static IfInfo GetIfInfoStatic() {
	    IntPtr ptr = SprExport.Spr_PH1DJointLimitIf_GetIfInfoStatic();
            return new IfInfo(ptr);
	}
	public void SetRange(Vec2d range) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PH1DJointLimitIf_SetRange((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) range);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PH1DJointLimitIf_SetRange((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) range);
				}
			}
		} else {
	    SprExport.Spr_PH1DJointLimitIf_SetRange((IntPtr) _thisArray[0], (IntPtr) range);
		}
		throw new InvalidOperationException();
	}
	public void GetRange(Vec2d range) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PH1DJointLimitIf_GetRange((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) range);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PH1DJointLimitIf_GetRange((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) range);
				}
			}
		} else {
	    SprExport.Spr_PH1DJointLimitIf_GetRange((IntPtr) _thisArray[0], (IntPtr) range);
		}
		throw new InvalidOperationException();
	}
	public void SetSpring(double spring) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PH1DJointLimitIf_SetSpring((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) spring);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PH1DJointLimitIf_SetSpring((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) spring);
				}
			}
		} else {
	    SprExport.Spr_PH1DJointLimitIf_SetSpring((IntPtr) _thisArray[0], (double) spring);
		}
		throw new InvalidOperationException();
	}
	public double GetSpring() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    double result = (double) SprExport.Spr_PH1DJointLimitIf_GetSpring((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    double result = (double) SprExport.Spr_PH1DJointLimitIf_GetSpring((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    double result = (double) SprExport.Spr_PH1DJointLimitIf_GetSpring((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public void SetDamper(double damper) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PH1DJointLimitIf_SetDamper((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) damper);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PH1DJointLimitIf_SetDamper((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) damper);
				}
			}
		} else {
	    SprExport.Spr_PH1DJointLimitIf_SetDamper((IntPtr) _thisArray[0], (double) damper);
		}
		throw new InvalidOperationException();
	}
	public double GetDamper() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    double result = (double) SprExport.Spr_PH1DJointLimitIf_GetDamper((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    double result = (double) SprExport.Spr_PH1DJointLimitIf_GetDamper((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    double result = (double) SprExport.Spr_PH1DJointLimitIf_GetDamper((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public bool IsOnLimit() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    char ret = SprExport.Spr_PH1DJointLimitIf_IsOnLimit((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return (ret == 0) ? false : true;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    char ret = SprExport.Spr_PH1DJointLimitIf_IsOnLimit((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return (ret == 0) ? false : true;
				}
			}
		} else {
	    char ret = SprExport.Spr_PH1DJointLimitIf_IsOnLimit((IntPtr) _thisArray[0]);
	    return (ret == 0) ? false : true;
		}
		throw new InvalidOperationException();
	}
	public void Enable(bool b) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PH1DJointLimitIf_Enable((IntPtr) _thisArray[phSceneIf.sceneForStep], (bool) b);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PH1DJointLimitIf_Enable((IntPtr) _thisArray[phSceneIf.sceneForGet], (bool) b);
				}
			}
		} else {
	    SprExport.Spr_PH1DJointLimitIf_Enable((IntPtr) _thisArray[0], (bool) b);
		}
		throw new InvalidOperationException();
	}
	public bool IsEnabled() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    char ret = SprExport.Spr_PH1DJointLimitIf_IsEnabled((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return (ret == 0) ? false : true;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    char ret = SprExport.Spr_PH1DJointLimitIf_IsEnabled((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return (ret == 0) ? false : true;
				}
			}
		} else {
	    char ret = SprExport.Spr_PH1DJointLimitIf_IsEnabled((IntPtr) _thisArray[0]);
	    return (ret == 0) ? false : true;
		}
		throw new InvalidOperationException();
	}
    }
    public partial class PHBallJointLimitIf : SceneObjectIf {
	public PHBallJointLimitIf() { _thisArray[0] = SprExport.Spr_new_PHBallJointLimitIf(); _flag = true; }
	public PHBallJointLimitIf(IntPtr ptr) : base(ptr) {}
	public PHBallJointLimitIf(IntPtr ptr, bool flag) : base(ptr, flag) {}
	public static implicit operator PHBallJointLimitIf(CsCastObject target) {
		return (target._info.Inherit(PHBallJointLimitIf.GetIfInfoStatic()) ? new PHBallJointLimitIf(target._thisArray[0], target._flag) : null);
	}
	~PHBallJointLimitIf() { if (_flag) { SprExport.Spr_delete_PHBallJointLimitIf(_thisArray[0]); _flag = false; } }
        public override string ToString() {
            IntPtr ptr = SprExport.Spr_PHBallJointLimitIf_ToString((IntPtr) _thisArray[0]);
            string bstr = Marshal.PtrToStringBSTR(ptr);
            SprExport.Spr_PHBallJointLimitIf_FreeString((IntPtr) ptr);
            return bstr;
        }
	public IfInfo GetIfInfo() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHBallJointLimitIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new IfInfo(ptr);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHBallJointLimitIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new IfInfo(ptr);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHBallJointLimitIf_GetIfInfo((IntPtr) _thisArray[0]);
            return new IfInfo(ptr);
		}
		throw new InvalidOperationException();
	}
	public static IfInfo GetIfInfoStatic() {
	    IntPtr ptr = SprExport.Spr_PHBallJointLimitIf_GetIfInfoStatic();
            return new IfInfo(ptr);
	}
	public void SetSpring(double rSpring) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHBallJointLimitIf_SetSpring((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) rSpring);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHBallJointLimitIf_SetSpring((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) rSpring);
				}
			}
		} else {
	    SprExport.Spr_PHBallJointLimitIf_SetSpring((IntPtr) _thisArray[0], (double) rSpring);
		}
		throw new InvalidOperationException();
	}
	public double GetSpring() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    double result = (double) SprExport.Spr_PHBallJointLimitIf_GetSpring((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    double result = (double) SprExport.Spr_PHBallJointLimitIf_GetSpring((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    double result = (double) SprExport.Spr_PHBallJointLimitIf_GetSpring((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public void SetDamper(double rDamper) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHBallJointLimitIf_SetDamper((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) rDamper);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHBallJointLimitIf_SetDamper((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) rDamper);
				}
			}
		} else {
	    SprExport.Spr_PHBallJointLimitIf_SetDamper((IntPtr) _thisArray[0], (double) rDamper);
		}
		throw new InvalidOperationException();
	}
	public double GetDamper() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    double result = (double) SprExport.Spr_PHBallJointLimitIf_GetDamper((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    double result = (double) SprExport.Spr_PHBallJointLimitIf_GetDamper((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    double result = (double) SprExport.Spr_PHBallJointLimitIf_GetDamper((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public void SetLimitDir(Vec3d limDir) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHBallJointLimitIf_SetLimitDir((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) limDir);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHBallJointLimitIf_SetLimitDir((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) limDir);
				}
			}
		} else {
	    SprExport.Spr_PHBallJointLimitIf_SetLimitDir((IntPtr) _thisArray[0], (IntPtr) limDir);
		}
		throw new InvalidOperationException();
	}
	public Vec3d GetLimitDir() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHBallJointLimitIf_GetLimitDir((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new Vec3d(ptr, true);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHBallJointLimitIf_GetLimitDir((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new Vec3d(ptr, true);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHBallJointLimitIf_GetLimitDir((IntPtr) _thisArray[0]);
            return new Vec3d(ptr, true);
		}
		throw new InvalidOperationException();
	}
	public bool IsOnLimit() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    char ret = SprExport.Spr_PHBallJointLimitIf_IsOnLimit((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return (ret == 0) ? false : true;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    char ret = SprExport.Spr_PHBallJointLimitIf_IsOnLimit((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return (ret == 0) ? false : true;
				}
			}
		} else {
	    char ret = SprExport.Spr_PHBallJointLimitIf_IsOnLimit((IntPtr) _thisArray[0]);
	    return (ret == 0) ? false : true;
		}
		throw new InvalidOperationException();
	}
	public void Enable(bool b) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHBallJointLimitIf_Enable((IntPtr) _thisArray[phSceneIf.sceneForStep], (bool) b);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHBallJointLimitIf_Enable((IntPtr) _thisArray[phSceneIf.sceneForGet], (bool) b);
				}
			}
		} else {
	    SprExport.Spr_PHBallJointLimitIf_Enable((IntPtr) _thisArray[0], (bool) b);
		}
		throw new InvalidOperationException();
	}
	public bool IsEnabled() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    char ret = SprExport.Spr_PHBallJointLimitIf_IsEnabled((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return (ret == 0) ? false : true;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    char ret = SprExport.Spr_PHBallJointLimitIf_IsEnabled((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return (ret == 0) ? false : true;
				}
			}
		} else {
	    char ret = SprExport.Spr_PHBallJointLimitIf_IsEnabled((IntPtr) _thisArray[0]);
	    return (ret == 0) ? false : true;
		}
		throw new InvalidOperationException();
	}
    }
    public partial class PHBallJointConeLimitIf : PHBallJointLimitIf {
	public PHBallJointConeLimitIf() { _thisArray[0] = SprExport.Spr_new_PHBallJointConeLimitIf(); _flag = true; }
	public PHBallJointConeLimitIf(IntPtr ptr) : base(ptr) {}
	public PHBallJointConeLimitIf(IntPtr ptr, bool flag) : base(ptr, flag) {}
	public static implicit operator PHBallJointConeLimitIf(CsCastObject target) {
		return (target._info.Inherit(PHBallJointConeLimitIf.GetIfInfoStatic()) ? new PHBallJointConeLimitIf(target._thisArray[0], target._flag) : null);
	}
	~PHBallJointConeLimitIf() { if (_flag) { SprExport.Spr_delete_PHBallJointConeLimitIf(_thisArray[0]); _flag = false; } }
        public override string ToString() {
            IntPtr ptr = SprExport.Spr_PHBallJointConeLimitIf_ToString((IntPtr) _thisArray[0]);
            string bstr = Marshal.PtrToStringBSTR(ptr);
            SprExport.Spr_PHBallJointConeLimitIf_FreeString((IntPtr) ptr);
            return bstr;
        }
	public IfInfo GetIfInfo() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHBallJointConeLimitIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new IfInfo(ptr);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHBallJointConeLimitIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new IfInfo(ptr);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHBallJointConeLimitIf_GetIfInfo((IntPtr) _thisArray[0]);
            return new IfInfo(ptr);
		}
		throw new InvalidOperationException();
	}
	public static IfInfo GetIfInfoStatic() {
	    IntPtr ptr = SprExport.Spr_PHBallJointConeLimitIf_GetIfInfoStatic();
            return new IfInfo(ptr);
	}
	public void SetSwingRange(Vec2d range) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHBallJointConeLimitIf_SetSwingRange((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) range);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHBallJointConeLimitIf_SetSwingRange((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) range);
				}
			}
		} else {
	    SprExport.Spr_PHBallJointConeLimitIf_SetSwingRange((IntPtr) _thisArray[0], (IntPtr) range);
		}
		throw new InvalidOperationException();
	}
	public void GetSwingRange(Vec2d range) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHBallJointConeLimitIf_GetSwingRange((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) range);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHBallJointConeLimitIf_GetSwingRange((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) range);
				}
			}
		} else {
	    SprExport.Spr_PHBallJointConeLimitIf_GetSwingRange((IntPtr) _thisArray[0], (IntPtr) range);
		}
		throw new InvalidOperationException();
	}
	public void SetSwingDirRange(Vec2d range) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHBallJointConeLimitIf_SetSwingDirRange((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) range);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHBallJointConeLimitIf_SetSwingDirRange((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) range);
				}
			}
		} else {
	    SprExport.Spr_PHBallJointConeLimitIf_SetSwingDirRange((IntPtr) _thisArray[0], (IntPtr) range);
		}
		throw new InvalidOperationException();
	}
	public void GetSwingDirRange(Vec2d range) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHBallJointConeLimitIf_GetSwingDirRange((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) range);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHBallJointConeLimitIf_GetSwingDirRange((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) range);
				}
			}
		} else {
	    SprExport.Spr_PHBallJointConeLimitIf_GetSwingDirRange((IntPtr) _thisArray[0], (IntPtr) range);
		}
		throw new InvalidOperationException();
	}
	public void SetTwistRange(Vec2d range) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHBallJointConeLimitIf_SetTwistRange((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) range);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHBallJointConeLimitIf_SetTwistRange((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) range);
				}
			}
		} else {
	    SprExport.Spr_PHBallJointConeLimitIf_SetTwistRange((IntPtr) _thisArray[0], (IntPtr) range);
		}
		throw new InvalidOperationException();
	}
	public void GetTwistRange(Vec2d range) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHBallJointConeLimitIf_GetTwistRange((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) range);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHBallJointConeLimitIf_GetTwistRange((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) range);
				}
			}
		} else {
	    SprExport.Spr_PHBallJointConeLimitIf_GetTwistRange((IntPtr) _thisArray[0], (IntPtr) range);
		}
		throw new InvalidOperationException();
	}
    }
    public partial class PHBallJointSplineLimitIf : PHBallJointLimitIf {
	public PHBallJointSplineLimitIf() { _thisArray[0] = SprExport.Spr_new_PHBallJointSplineLimitIf(); _flag = true; }
	public PHBallJointSplineLimitIf(IntPtr ptr) : base(ptr) {}
	public PHBallJointSplineLimitIf(IntPtr ptr, bool flag) : base(ptr, flag) {}
	public static implicit operator PHBallJointSplineLimitIf(CsCastObject target) {
		return (target._info.Inherit(PHBallJointSplineLimitIf.GetIfInfoStatic()) ? new PHBallJointSplineLimitIf(target._thisArray[0], target._flag) : null);
	}
	~PHBallJointSplineLimitIf() { if (_flag) { SprExport.Spr_delete_PHBallJointSplineLimitIf(_thisArray[0]); _flag = false; } }
        public override string ToString() {
            IntPtr ptr = SprExport.Spr_PHBallJointSplineLimitIf_ToString((IntPtr) _thisArray[0]);
            string bstr = Marshal.PtrToStringBSTR(ptr);
            SprExport.Spr_PHBallJointSplineLimitIf_FreeString((IntPtr) ptr);
            return bstr;
        }
	public IfInfo GetIfInfo() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHBallJointSplineLimitIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new IfInfo(ptr);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHBallJointSplineLimitIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new IfInfo(ptr);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHBallJointSplineLimitIf_GetIfInfo((IntPtr) _thisArray[0]);
            return new IfInfo(ptr);
		}
		throw new InvalidOperationException();
	}
	public static IfInfo GetIfInfoStatic() {
	    IntPtr ptr = SprExport.Spr_PHBallJointSplineLimitIf_GetIfInfoStatic();
            return new IfInfo(ptr);
	}
	public void AddNode(PHSplineLimitNode node) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHBallJointSplineLimitIf_AddNode((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) node);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHBallJointSplineLimitIf_AddNode((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) node);
				}
			}
		} else {
	    SprExport.Spr_PHBallJointSplineLimitIf_AddNode((IntPtr) _thisArray[0], (IntPtr) node);
		}
		throw new InvalidOperationException();
	}
	public void AddNode(double S, double SD, double dS, double dSD, double tMin, double tMax) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHBallJointSplineLimitIf_AddNode_1((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) S, (double) SD, (double) dS, (double) dSD, (double) tMin, (double) tMax);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHBallJointSplineLimitIf_AddNode_1((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) S, (double) SD, (double) dS, (double) dSD, (double) tMin, (double) tMax);
				}
			}
		} else {
	    SprExport.Spr_PHBallJointSplineLimitIf_AddNode_1((IntPtr) _thisArray[0], (double) S, (double) SD, (double) dS, (double) dSD, (double) tMin, (double) tMax);
		}
		throw new InvalidOperationException();
	}
	public void AddNode(PHSplineLimitNode node, int pos) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHBallJointSplineLimitIf_AddNode_2((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) node, (int) pos);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHBallJointSplineLimitIf_AddNode_2((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) node, (int) pos);
				}
			}
		} else {
	    SprExport.Spr_PHBallJointSplineLimitIf_AddNode_2((IntPtr) _thisArray[0], (IntPtr) node, (int) pos);
		}
		throw new InvalidOperationException();
	}
	public void AddNode(double S, double SD, double dS, double dSD, double tMin, double tMax, int pos) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHBallJointSplineLimitIf_AddNode_3((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) S, (double) SD, (double) dS, (double) dSD, (double) tMin, (double) tMax, (int) pos);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHBallJointSplineLimitIf_AddNode_3((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) S, (double) SD, (double) dS, (double) dSD, (double) tMin, (double) tMax, (int) pos);
				}
			}
		} else {
	    SprExport.Spr_PHBallJointSplineLimitIf_AddNode_3((IntPtr) _thisArray[0], (double) S, (double) SD, (double) dS, (double) dSD, (double) tMin, (double) tMax, (int) pos);
		}
		throw new InvalidOperationException();
	}
	public void SetPoleTwistRange(Vec2d range) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHBallJointSplineLimitIf_SetPoleTwistRange((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) range);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHBallJointSplineLimitIf_SetPoleTwistRange((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) range);
				}
			}
		} else {
	    SprExport.Spr_PHBallJointSplineLimitIf_SetPoleTwistRange((IntPtr) _thisArray[0], (IntPtr) range);
		}
		throw new InvalidOperationException();
	}
	public void GetPoleTwistRange(Vec2d range) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHBallJointSplineLimitIf_GetPoleTwistRange((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) range);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHBallJointSplineLimitIf_GetPoleTwistRange((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) range);
				}
			}
		} else {
	    SprExport.Spr_PHBallJointSplineLimitIf_GetPoleTwistRange((IntPtr) _thisArray[0], (IntPtr) range);
		}
		throw new InvalidOperationException();
	}
    }
    public partial class PHBallJointIndependentLimitIf : PHBallJointLimitIf {
	public PHBallJointIndependentLimitIf() { _thisArray[0] = SprExport.Spr_new_PHBallJointIndependentLimitIf(); _flag = true; }
	public PHBallJointIndependentLimitIf(IntPtr ptr) : base(ptr) {}
	public PHBallJointIndependentLimitIf(IntPtr ptr, bool flag) : base(ptr, flag) {}
	public static implicit operator PHBallJointIndependentLimitIf(CsCastObject target) {
		return (target._info.Inherit(PHBallJointIndependentLimitIf.GetIfInfoStatic()) ? new PHBallJointIndependentLimitIf(target._thisArray[0], target._flag) : null);
	}
	~PHBallJointIndependentLimitIf() { if (_flag) { SprExport.Spr_delete_PHBallJointIndependentLimitIf(_thisArray[0]); _flag = false; } }
        public override string ToString() {
            IntPtr ptr = SprExport.Spr_PHBallJointIndependentLimitIf_ToString((IntPtr) _thisArray[0]);
            string bstr = Marshal.PtrToStringBSTR(ptr);
            SprExport.Spr_PHBallJointIndependentLimitIf_FreeString((IntPtr) ptr);
            return bstr;
        }
	public IfInfo GetIfInfo() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHBallJointIndependentLimitIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new IfInfo(ptr);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHBallJointIndependentLimitIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new IfInfo(ptr);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHBallJointIndependentLimitIf_GetIfInfo((IntPtr) _thisArray[0]);
            return new IfInfo(ptr);
		}
		throw new InvalidOperationException();
	}
	public static IfInfo GetIfInfoStatic() {
	    IntPtr ptr = SprExport.Spr_PHBallJointIndependentLimitIf_GetIfInfoStatic();
            return new IfInfo(ptr);
	}
	public bool IsOnLimit() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    char ret = SprExport.Spr_PHBallJointIndependentLimitIf_IsOnLimit((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return (ret == 0) ? false : true;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    char ret = SprExport.Spr_PHBallJointIndependentLimitIf_IsOnLimit((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return (ret == 0) ? false : true;
				}
			}
		} else {
	    char ret = SprExport.Spr_PHBallJointIndependentLimitIf_IsOnLimit((IntPtr) _thisArray[0]);
	    return (ret == 0) ? false : true;
		}
		throw new InvalidOperationException();
	}
	public int AxesEnabled() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    int result = (int) SprExport.Spr_PHBallJointIndependentLimitIf_AxesEnabled((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    int result = (int) SprExport.Spr_PHBallJointIndependentLimitIf_AxesEnabled((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    int result = (int) SprExport.Spr_PHBallJointIndependentLimitIf_AxesEnabled((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public void SetLimitRangeN(int n, Vec2d range) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHBallJointIndependentLimitIf_SetLimitRangeN((IntPtr) _thisArray[phSceneIf.sceneForStep], (int) n, (IntPtr) range);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHBallJointIndependentLimitIf_SetLimitRangeN((IntPtr) _thisArray[phSceneIf.sceneForGet], (int) n, (IntPtr) range);
				}
			}
		} else {
	    SprExport.Spr_PHBallJointIndependentLimitIf_SetLimitRangeN((IntPtr) _thisArray[0], (int) n, (IntPtr) range);
		}
		throw new InvalidOperationException();
	}
	public void GetLimitRangeN(int n, Vec2d range) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHBallJointIndependentLimitIf_GetLimitRangeN((IntPtr) _thisArray[phSceneIf.sceneForStep], (int) n, (IntPtr) range);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHBallJointIndependentLimitIf_GetLimitRangeN((IntPtr) _thisArray[phSceneIf.sceneForGet], (int) n, (IntPtr) range);
				}
			}
		} else {
	    SprExport.Spr_PHBallJointIndependentLimitIf_GetLimitRangeN((IntPtr) _thisArray[0], (int) n, (IntPtr) range);
		}
		throw new InvalidOperationException();
	}
    }
    public partial class PH1DJointMotorIf : SceneObjectIf {
	public PH1DJointMotorIf() { _thisArray[0] = SprExport.Spr_new_PH1DJointMotorIf(); _flag = true; }
	public PH1DJointMotorIf(IntPtr ptr) : base(ptr) {}
	public PH1DJointMotorIf(IntPtr ptr, bool flag) : base(ptr, flag) {}
	public static implicit operator PH1DJointMotorIf(CsCastObject target) {
		return (target._info.Inherit(PH1DJointMotorIf.GetIfInfoStatic()) ? new PH1DJointMotorIf(target._thisArray[0], target._flag) : null);
	}
	~PH1DJointMotorIf() { if (_flag) { SprExport.Spr_delete_PH1DJointMotorIf(_thisArray[0]); _flag = false; } }
        public override string ToString() {
            IntPtr ptr = SprExport.Spr_PH1DJointMotorIf_ToString((IntPtr) _thisArray[0]);
            string bstr = Marshal.PtrToStringBSTR(ptr);
            SprExport.Spr_PH1DJointMotorIf_FreeString((IntPtr) ptr);
            return bstr;
        }
	public IfInfo GetIfInfo() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PH1DJointMotorIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new IfInfo(ptr);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PH1DJointMotorIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new IfInfo(ptr);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PH1DJointMotorIf_GetIfInfo((IntPtr) _thisArray[0]);
            return new IfInfo(ptr);
		}
		throw new InvalidOperationException();
	}
	public static IfInfo GetIfInfoStatic() {
	    IntPtr ptr = SprExport.Spr_PH1DJointMotorIf_GetIfInfoStatic();
            return new IfInfo(ptr);
	}
    }
    public partial class PH1DJointNonLinearMotorIf : PH1DJointMotorIf {
	public PH1DJointNonLinearMotorIf() { _thisArray[0] = SprExport.Spr_new_PH1DJointNonLinearMotorIf(); _flag = true; }
	public PH1DJointNonLinearMotorIf(IntPtr ptr) : base(ptr) {}
	public PH1DJointNonLinearMotorIf(IntPtr ptr, bool flag) : base(ptr, flag) {}
	public static implicit operator PH1DJointNonLinearMotorIf(CsCastObject target) {
		return (target._info.Inherit(PH1DJointNonLinearMotorIf.GetIfInfoStatic()) ? new PH1DJointNonLinearMotorIf(target._thisArray[0], target._flag) : null);
	}
	~PH1DJointNonLinearMotorIf() { if (_flag) { SprExport.Spr_delete_PH1DJointNonLinearMotorIf(_thisArray[0]); _flag = false; } }
        public override string ToString() {
            IntPtr ptr = SprExport.Spr_PH1DJointNonLinearMotorIf_ToString((IntPtr) _thisArray[0]);
            string bstr = Marshal.PtrToStringBSTR(ptr);
            SprExport.Spr_PH1DJointNonLinearMotorIf_FreeString((IntPtr) ptr);
            return bstr;
        }
	public IfInfo GetIfInfo() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PH1DJointNonLinearMotorIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new IfInfo(ptr);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PH1DJointNonLinearMotorIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new IfInfo(ptr);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PH1DJointNonLinearMotorIf_GetIfInfo((IntPtr) _thisArray[0]);
            return new IfInfo(ptr);
		}
		throw new InvalidOperationException();
	}
	public static IfInfo GetIfInfoStatic() {
	    IntPtr ptr = SprExport.Spr_PH1DJointNonLinearMotorIf_GetIfInfoStatic();
            return new IfInfo(ptr);
	}
	public void SetSpring(PH1DJointNonLinearMotorDesc.FunctionMode m, CsObject param) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PH1DJointNonLinearMotorIf_SetSpring((IntPtr) _thisArray[phSceneIf.sceneForStep], (int) m, (IntPtr) param);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PH1DJointNonLinearMotorIf_SetSpring((IntPtr) _thisArray[phSceneIf.sceneForGet], (int) m, (IntPtr) param);
				}
			}
		} else {
	    SprExport.Spr_PH1DJointNonLinearMotorIf_SetSpring((IntPtr) _thisArray[0], (int) m, (IntPtr) param);
		}
		throw new InvalidOperationException();
	}
	public void SetDamper(PH1DJointNonLinearMotorDesc.FunctionMode m, CsObject param) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PH1DJointNonLinearMotorIf_SetDamper((IntPtr) _thisArray[phSceneIf.sceneForStep], (int) m, (IntPtr) param);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PH1DJointNonLinearMotorIf_SetDamper((IntPtr) _thisArray[phSceneIf.sceneForGet], (int) m, (IntPtr) param);
				}
			}
		} else {
	    SprExport.Spr_PH1DJointNonLinearMotorIf_SetDamper((IntPtr) _thisArray[0], (int) m, (IntPtr) param);
		}
		throw new InvalidOperationException();
	}
	public void SetSpringDamper(PH1DJointNonLinearMotorDesc.FunctionMode smode, PH1DJointNonLinearMotorDesc.FunctionMode dmode, CsObject sparam, CsObject dparam) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PH1DJointNonLinearMotorIf_SetSpringDamper((IntPtr) _thisArray[phSceneIf.sceneForStep], (int) smode, (int) dmode, (IntPtr) sparam, (IntPtr) dparam);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PH1DJointNonLinearMotorIf_SetSpringDamper((IntPtr) _thisArray[phSceneIf.sceneForGet], (int) smode, (int) dmode, (IntPtr) sparam, (IntPtr) dparam);
				}
			}
		} else {
	    SprExport.Spr_PH1DJointNonLinearMotorIf_SetSpringDamper((IntPtr) _thisArray[0], (int) smode, (int) dmode, (IntPtr) sparam, (IntPtr) dparam);
		}
		throw new InvalidOperationException();
	}
    }
    public partial class PHHuman1DJointResistanceIf : PH1DJointNonLinearMotorIf {
	public PHHuman1DJointResistanceIf() { _thisArray[0] = SprExport.Spr_new_PHHuman1DJointResistanceIf(); _flag = true; }
	public PHHuman1DJointResistanceIf(IntPtr ptr) : base(ptr) {}
	public PHHuman1DJointResistanceIf(IntPtr ptr, bool flag) : base(ptr, flag) {}
	public static implicit operator PHHuman1DJointResistanceIf(CsCastObject target) {
		return (target._info.Inherit(PHHuman1DJointResistanceIf.GetIfInfoStatic()) ? new PHHuman1DJointResistanceIf(target._thisArray[0], target._flag) : null);
	}
	~PHHuman1DJointResistanceIf() { if (_flag) { SprExport.Spr_delete_PHHuman1DJointResistanceIf(_thisArray[0]); _flag = false; } }
        public override string ToString() {
            IntPtr ptr = SprExport.Spr_PHHuman1DJointResistanceIf_ToString((IntPtr) _thisArray[0]);
            string bstr = Marshal.PtrToStringBSTR(ptr);
            SprExport.Spr_PHHuman1DJointResistanceIf_FreeString((IntPtr) ptr);
            return bstr;
        }
	public IfInfo GetIfInfo() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHHuman1DJointResistanceIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new IfInfo(ptr);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHHuman1DJointResistanceIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new IfInfo(ptr);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHHuman1DJointResistanceIf_GetIfInfo((IntPtr) _thisArray[0]);
            return new IfInfo(ptr);
		}
		throw new InvalidOperationException();
	}
	public static IfInfo GetIfInfoStatic() {
	    IntPtr ptr = SprExport.Spr_PHHuman1DJointResistanceIf_GetIfInfoStatic();
            return new IfInfo(ptr);
	}
	public double GetCurrentResistance() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    double result = (double) SprExport.Spr_PHHuman1DJointResistanceIf_GetCurrentResistance((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    double result = (double) SprExport.Spr_PHHuman1DJointResistanceIf_GetCurrentResistance((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    double result = (double) SprExport.Spr_PHHuman1DJointResistanceIf_GetCurrentResistance((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
    }
    public partial class PHBallJointMotorIf : SceneObjectIf {
	public PHBallJointMotorIf() { _thisArray[0] = SprExport.Spr_new_PHBallJointMotorIf(); _flag = true; }
	public PHBallJointMotorIf(IntPtr ptr) : base(ptr) {}
	public PHBallJointMotorIf(IntPtr ptr, bool flag) : base(ptr, flag) {}
	public static implicit operator PHBallJointMotorIf(CsCastObject target) {
		return (target._info.Inherit(PHBallJointMotorIf.GetIfInfoStatic()) ? new PHBallJointMotorIf(target._thisArray[0], target._flag) : null);
	}
	~PHBallJointMotorIf() { if (_flag) { SprExport.Spr_delete_PHBallJointMotorIf(_thisArray[0]); _flag = false; } }
        public override string ToString() {
            IntPtr ptr = SprExport.Spr_PHBallJointMotorIf_ToString((IntPtr) _thisArray[0]);
            string bstr = Marshal.PtrToStringBSTR(ptr);
            SprExport.Spr_PHBallJointMotorIf_FreeString((IntPtr) ptr);
            return bstr;
        }
	public IfInfo GetIfInfo() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHBallJointMotorIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new IfInfo(ptr);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHBallJointMotorIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new IfInfo(ptr);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHBallJointMotorIf_GetIfInfo((IntPtr) _thisArray[0]);
            return new IfInfo(ptr);
		}
		throw new InvalidOperationException();
	}
	public static IfInfo GetIfInfoStatic() {
	    IntPtr ptr = SprExport.Spr_PHBallJointMotorIf_GetIfInfoStatic();
            return new IfInfo(ptr);
	}
    }
    public partial class PHBallJointNonLinearMotorIf : PHBallJointMotorIf {
	public PHBallJointNonLinearMotorIf() { _thisArray[0] = SprExport.Spr_new_PHBallJointNonLinearMotorIf(); _flag = true; }
	public PHBallJointNonLinearMotorIf(IntPtr ptr) : base(ptr) {}
	public PHBallJointNonLinearMotorIf(IntPtr ptr, bool flag) : base(ptr, flag) {}
	public static implicit operator PHBallJointNonLinearMotorIf(CsCastObject target) {
		return (target._info.Inherit(PHBallJointNonLinearMotorIf.GetIfInfoStatic()) ? new PHBallJointNonLinearMotorIf(target._thisArray[0], target._flag) : null);
	}
	~PHBallJointNonLinearMotorIf() { if (_flag) { SprExport.Spr_delete_PHBallJointNonLinearMotorIf(_thisArray[0]); _flag = false; } }
        public override string ToString() {
            IntPtr ptr = SprExport.Spr_PHBallJointNonLinearMotorIf_ToString((IntPtr) _thisArray[0]);
            string bstr = Marshal.PtrToStringBSTR(ptr);
            SprExport.Spr_PHBallJointNonLinearMotorIf_FreeString((IntPtr) ptr);
            return bstr;
        }
	public IfInfo GetIfInfo() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHBallJointNonLinearMotorIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new IfInfo(ptr);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHBallJointNonLinearMotorIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new IfInfo(ptr);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHBallJointNonLinearMotorIf_GetIfInfo((IntPtr) _thisArray[0]);
            return new IfInfo(ptr);
		}
		throw new InvalidOperationException();
	}
	public static IfInfo GetIfInfoStatic() {
	    IntPtr ptr = SprExport.Spr_PHBallJointNonLinearMotorIf_GetIfInfoStatic();
            return new IfInfo(ptr);
	}
	public void SetFuncFromDatabaseN(int n, int i, int j, CsObject sparam, CsObject dparam) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHBallJointNonLinearMotorIf_SetFuncFromDatabaseN((IntPtr) _thisArray[phSceneIf.sceneForStep], (int) n, (int) i, (int) j, (IntPtr) sparam, (IntPtr) dparam);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHBallJointNonLinearMotorIf_SetFuncFromDatabaseN((IntPtr) _thisArray[phSceneIf.sceneForGet], (int) n, (int) i, (int) j, (IntPtr) sparam, (IntPtr) dparam);
				}
			}
		} else {
	    SprExport.Spr_PHBallJointNonLinearMotorIf_SetFuncFromDatabaseN((IntPtr) _thisArray[0], (int) n, (int) i, (int) j, (IntPtr) sparam, (IntPtr) dparam);
		}
		throw new InvalidOperationException();
	}
    }
    public partial class PHHumanBallJointResistanceIf : PHBallJointNonLinearMotorIf {
	public PHHumanBallJointResistanceIf() { _thisArray[0] = SprExport.Spr_new_PHHumanBallJointResistanceIf(); _flag = true; }
	public PHHumanBallJointResistanceIf(IntPtr ptr) : base(ptr) {}
	public PHHumanBallJointResistanceIf(IntPtr ptr, bool flag) : base(ptr, flag) {}
	public static implicit operator PHHumanBallJointResistanceIf(CsCastObject target) {
		return (target._info.Inherit(PHHumanBallJointResistanceIf.GetIfInfoStatic()) ? new PHHumanBallJointResistanceIf(target._thisArray[0], target._flag) : null);
	}
	~PHHumanBallJointResistanceIf() { if (_flag) { SprExport.Spr_delete_PHHumanBallJointResistanceIf(_thisArray[0]); _flag = false; } }
        public override string ToString() {
            IntPtr ptr = SprExport.Spr_PHHumanBallJointResistanceIf_ToString((IntPtr) _thisArray[0]);
            string bstr = Marshal.PtrToStringBSTR(ptr);
            SprExport.Spr_PHHumanBallJointResistanceIf_FreeString((IntPtr) ptr);
            return bstr;
        }
	public IfInfo GetIfInfo() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHHumanBallJointResistanceIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new IfInfo(ptr);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHHumanBallJointResistanceIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new IfInfo(ptr);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHHumanBallJointResistanceIf_GetIfInfo((IntPtr) _thisArray[0]);
            return new IfInfo(ptr);
		}
		throw new InvalidOperationException();
	}
	public static IfInfo GetIfInfoStatic() {
	    IntPtr ptr = SprExport.Spr_PHHumanBallJointResistanceIf_GetIfInfoStatic();
            return new IfInfo(ptr);
	}
	public Vec3d GetCurrentResistance() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHHumanBallJointResistanceIf_GetCurrentResistance((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new Vec3d(ptr, true);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHHumanBallJointResistanceIf_GetCurrentResistance((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new Vec3d(ptr, true);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHHumanBallJointResistanceIf_GetCurrentResistance((IntPtr) _thisArray[0]);
            return new Vec3d(ptr, true);
		}
		throw new InvalidOperationException();
	}
    }
    public partial class PHSpringMotorIf : SceneObjectIf {
	public PHSpringMotorIf() { _thisArray[0] = SprExport.Spr_new_PHSpringMotorIf(); _flag = true; }
	public PHSpringMotorIf(IntPtr ptr) : base(ptr) {}
	public PHSpringMotorIf(IntPtr ptr, bool flag) : base(ptr, flag) {}
	public static implicit operator PHSpringMotorIf(CsCastObject target) {
		return (target._info.Inherit(PHSpringMotorIf.GetIfInfoStatic()) ? new PHSpringMotorIf(target._thisArray[0], target._flag) : null);
	}
	~PHSpringMotorIf() { if (_flag) { SprExport.Spr_delete_PHSpringMotorIf(_thisArray[0]); _flag = false; } }
        public override string ToString() {
            IntPtr ptr = SprExport.Spr_PHSpringMotorIf_ToString((IntPtr) _thisArray[0]);
            string bstr = Marshal.PtrToStringBSTR(ptr);
            SprExport.Spr_PHSpringMotorIf_FreeString((IntPtr) ptr);
            return bstr;
        }
	public IfInfo GetIfInfo() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHSpringMotorIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new IfInfo(ptr);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHSpringMotorIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new IfInfo(ptr);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHSpringMotorIf_GetIfInfo((IntPtr) _thisArray[0]);
            return new IfInfo(ptr);
		}
		throw new InvalidOperationException();
	}
	public static IfInfo GetIfInfoStatic() {
	    IntPtr ptr = SprExport.Spr_PHSpringMotorIf_GetIfInfoStatic();
            return new IfInfo(ptr);
	}
    }
    public partial class PHOpObjIf : SceneObjectIf {
	public PHOpObjIf() { _thisArray[0] = SprExport.Spr_new_PHOpObjIf(); _flag = true; }
	public PHOpObjIf(IntPtr ptr) : base(ptr) {}
	public PHOpObjIf(IntPtr ptr, bool flag) : base(ptr, flag) {}
	public static implicit operator PHOpObjIf(CsCastObject target) {
		return (target._info.Inherit(PHOpObjIf.GetIfInfoStatic()) ? new PHOpObjIf(target._thisArray[0], target._flag) : null);
	}
	~PHOpObjIf() { if (_flag) { SprExport.Spr_delete_PHOpObjIf(_thisArray[0]); _flag = false; } }
        public override string ToString() {
            IntPtr ptr = SprExport.Spr_PHOpObjIf_ToString((IntPtr) _thisArray[0]);
            string bstr = Marshal.PtrToStringBSTR(ptr);
            SprExport.Spr_PHOpObjIf_FreeString((IntPtr) ptr);
            return bstr;
        }
	public IfInfo GetIfInfo() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHOpObjIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new IfInfo(ptr);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHOpObjIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new IfInfo(ptr);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHOpObjIf_GetIfInfo((IntPtr) _thisArray[0]);
            return new IfInfo(ptr);
		}
		throw new InvalidOperationException();
	}
	public static IfInfo GetIfInfoStatic() {
	    IntPtr ptr = SprExport.Spr_PHOpObjIf_GetIfInfoStatic();
            return new IfInfo(ptr);
	}
	public bool initialPHOpObj(Vec3f vts, int vtsNum, float pSize) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    char ret = SprExport.Spr_PHOpObjIf_initialPHOpObj((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) vts, (int) vtsNum, (float) pSize);
	    return (ret == 0) ? false : true;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    char ret = SprExport.Spr_PHOpObjIf_initialPHOpObj((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) vts, (int) vtsNum, (float) pSize);
	    return (ret == 0) ? false : true;
				}
			}
		} else {
	    char ret = SprExport.Spr_PHOpObjIf_initialPHOpObj((IntPtr) _thisArray[0], (IntPtr) vts, (int) vtsNum, (float) pSize);
	    return (ret == 0) ? false : true;
		}
		throw new InvalidOperationException();
	}
	public void SetGravity(bool bOn) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHOpObjIf_SetGravity((IntPtr) _thisArray[phSceneIf.sceneForStep], (bool) bOn);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHOpObjIf_SetGravity((IntPtr) _thisArray[phSceneIf.sceneForGet], (bool) bOn);
				}
			}
		} else {
	    SprExport.Spr_PHOpObjIf_SetGravity((IntPtr) _thisArray[0], (bool) bOn);
		}
		throw new InvalidOperationException();
	}
	public void SimpleSimulationStep() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHOpObjIf_SimpleSimulationStep((IntPtr) _thisArray[phSceneIf.sceneForStep]);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHOpObjIf_SimpleSimulationStep((IntPtr) _thisArray[phSceneIf.sceneForGet]);
				}
			}
		} else {
	    SprExport.Spr_PHOpObjIf_SimpleSimulationStep((IntPtr) _thisArray[0]);
		}
		throw new InvalidOperationException();
	}
	public void AddVertextoLocalBuffer(Vec3f v) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHOpObjIf_AddVertextoLocalBuffer((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) v);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHOpObjIf_AddVertextoLocalBuffer((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) v);
				}
			}
		} else {
	    SprExport.Spr_PHOpObjIf_AddVertextoLocalBuffer((IntPtr) _thisArray[0], (IntPtr) v);
		}
		throw new InvalidOperationException();
	}
	public bool InitialObjUsingLocalBuffer(float pSize) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    char ret = SprExport.Spr_PHOpObjIf_InitialObjUsingLocalBuffer((IntPtr) _thisArray[phSceneIf.sceneForStep], (float) pSize);
	    return (ret == 0) ? false : true;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    char ret = SprExport.Spr_PHOpObjIf_InitialObjUsingLocalBuffer((IntPtr) _thisArray[phSceneIf.sceneForGet], (float) pSize);
	    return (ret == 0) ? false : true;
				}
			}
		} else {
	    char ret = SprExport.Spr_PHOpObjIf_InitialObjUsingLocalBuffer((IntPtr) _thisArray[0], (float) pSize);
	    return (ret == 0) ? false : true;
		}
		throw new InvalidOperationException();
	}
	public void positionPredict() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHOpObjIf_positionPredict((IntPtr) _thisArray[phSceneIf.sceneForStep]);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHOpObjIf_positionPredict((IntPtr) _thisArray[phSceneIf.sceneForGet]);
				}
			}
		} else {
	    SprExport.Spr_PHOpObjIf_positionPredict((IntPtr) _thisArray[0]);
		}
		throw new InvalidOperationException();
	}
	public void groupStep() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHOpObjIf_groupStep((IntPtr) _thisArray[phSceneIf.sceneForStep]);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHOpObjIf_groupStep((IntPtr) _thisArray[phSceneIf.sceneForGet]);
				}
			}
		} else {
	    SprExport.Spr_PHOpObjIf_groupStep((IntPtr) _thisArray[0]);
		}
		throw new InvalidOperationException();
	}
	public void integrationStep() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHOpObjIf_integrationStep((IntPtr) _thisArray[phSceneIf.sceneForStep]);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHOpObjIf_integrationStep((IntPtr) _thisArray[phSceneIf.sceneForGet]);
				}
			}
		} else {
	    SprExport.Spr_PHOpObjIf_integrationStep((IntPtr) _thisArray[0]);
		}
		throw new InvalidOperationException();
	}
	public void ReducedPositionProject() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHOpObjIf_ReducedPositionProject((IntPtr) _thisArray[phSceneIf.sceneForStep]);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHOpObjIf_ReducedPositionProject((IntPtr) _thisArray[phSceneIf.sceneForGet]);
				}
			}
		} else {
	    SprExport.Spr_PHOpObjIf_ReducedPositionProject((IntPtr) _thisArray[0]);
		}
		throw new InvalidOperationException();
	}
	public void positionProject() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHOpObjIf_positionProject((IntPtr) _thisArray[phSceneIf.sceneForStep]);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHOpObjIf_positionProject((IntPtr) _thisArray[phSceneIf.sceneForGet]);
				}
			}
		} else {
	    SprExport.Spr_PHOpObjIf_positionProject((IntPtr) _thisArray[0]);
		}
		throw new InvalidOperationException();
	}
	public void SetDefaultLinkNum(int linkNum) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHOpObjIf_SetDefaultLinkNum((IntPtr) _thisArray[phSceneIf.sceneForStep], (int) linkNum);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHOpObjIf_SetDefaultLinkNum((IntPtr) _thisArray[phSceneIf.sceneForGet], (int) linkNum);
				}
			}
		} else {
	    SprExport.Spr_PHOpObjIf_SetDefaultLinkNum((IntPtr) _thisArray[0], (int) linkNum);
		}
		throw new InvalidOperationException();
	}
	public void BuildBlendWeight() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHOpObjIf_BuildBlendWeight((IntPtr) _thisArray[phSceneIf.sceneForStep]);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHOpObjIf_BuildBlendWeight((IntPtr) _thisArray[phSceneIf.sceneForGet]);
				}
			}
		} else {
	    SprExport.Spr_PHOpObjIf_BuildBlendWeight((IntPtr) _thisArray[0]);
		}
		throw new InvalidOperationException();
	}
	public void buildGroupCenter() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHOpObjIf_buildGroupCenter((IntPtr) _thisArray[phSceneIf.sceneForStep]);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHOpObjIf_buildGroupCenter((IntPtr) _thisArray[phSceneIf.sceneForGet]);
				}
			}
		} else {
	    SprExport.Spr_PHOpObjIf_buildGroupCenter((IntPtr) _thisArray[0]);
		}
		throw new InvalidOperationException();
	}
	public int GetVertexNum() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    int result = (int) SprExport.Spr_PHOpObjIf_GetVertexNum((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    int result = (int) SprExport.Spr_PHOpObjIf_GetVertexNum((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    int result = (int) SprExport.Spr_PHOpObjIf_GetVertexNum((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public Vec3f GetVertex(int vi) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHOpObjIf_GetVertex((IntPtr) _thisArray[phSceneIf.sceneForStep], (int) vi);
            return new Vec3f(ptr, true);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHOpObjIf_GetVertex((IntPtr) _thisArray[phSceneIf.sceneForGet], (int) vi);
            return new Vec3f(ptr, true);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHOpObjIf_GetVertex((IntPtr) _thisArray[0], (int) vi);
            return new Vec3f(ptr, true);
		}
		throw new InvalidOperationException();
	}
	public ObjectIf GetOpParticle(int pi) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHOpObjIf_GetOpParticle((IntPtr) _thisArray[phSceneIf.sceneForStep], (int) pi);
            if (ptr == IntPtr.Zero) { return null; } 
            ObjectIf obj = new ObjectIf(ptr);
            if (obj.GetIfInfo() == PHSolidPairIf.GetIfInfoStatic()) { return new PHSolidPairIf(ptr); }
            if (obj.GetIfInfo() == PHOpParticleIf.GetIfInfoStatic()) { return new PHOpParticleIf(ptr); }
            if (obj.GetIfInfo() == PHOpGroupIf.GetIfInfoStatic()) { return new PHOpGroupIf(ptr); }
            if (obj.GetIfInfo() == PHOpSpHashColliAgentIf.GetIfInfoStatic()) { return new PHOpSpHashColliAgentIf(ptr); }
            if (obj.GetIfInfo() == PHSolidPairForLCPIf.GetIfInfoStatic()) { return new PHSolidPairForLCPIf(ptr); }
            if (obj.GetIfInfo() == PHSolidPairForHapticIf.GetIfInfoStatic()) { return new PHSolidPairForHapticIf(ptr); }
            return obj;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHOpObjIf_GetOpParticle((IntPtr) _thisArray[phSceneIf.sceneForGet], (int) pi);
            if (ptr == IntPtr.Zero) { return null; } 
            ObjectIf obj = new ObjectIf(ptr);
            if (obj.GetIfInfo() == PHSolidPairIf.GetIfInfoStatic()) { return new PHSolidPairIf(ptr); }
            if (obj.GetIfInfo() == PHOpParticleIf.GetIfInfoStatic()) { return new PHOpParticleIf(ptr); }
            if (obj.GetIfInfo() == PHOpGroupIf.GetIfInfoStatic()) { return new PHOpGroupIf(ptr); }
            if (obj.GetIfInfo() == PHOpSpHashColliAgentIf.GetIfInfoStatic()) { return new PHOpSpHashColliAgentIf(ptr); }
            if (obj.GetIfInfo() == PHSolidPairForLCPIf.GetIfInfoStatic()) { return new PHSolidPairForLCPIf(ptr); }
            if (obj.GetIfInfo() == PHSolidPairForHapticIf.GetIfInfoStatic()) { return new PHSolidPairForHapticIf(ptr); }
            return obj;
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHOpObjIf_GetOpParticle((IntPtr) _thisArray[0], (int) pi);
            if (ptr == IntPtr.Zero) { return null; } 
            ObjectIf obj = new ObjectIf(ptr);
            if (obj.GetIfInfo() == PHSolidPairIf.GetIfInfoStatic()) { return new PHSolidPairIf(ptr); }
            if (obj.GetIfInfo() == PHOpParticleIf.GetIfInfoStatic()) { return new PHOpParticleIf(ptr); }
            if (obj.GetIfInfo() == PHOpGroupIf.GetIfInfoStatic()) { return new PHOpGroupIf(ptr); }
            if (obj.GetIfInfo() == PHOpSpHashColliAgentIf.GetIfInfoStatic()) { return new PHOpSpHashColliAgentIf(ptr); }
            if (obj.GetIfInfo() == PHSolidPairForLCPIf.GetIfInfoStatic()) { return new PHSolidPairForLCPIf(ptr); }
            if (obj.GetIfInfo() == PHSolidPairForHapticIf.GetIfInfoStatic()) { return new PHSolidPairForHapticIf(ptr); }
            return obj;
		}
		throw new InvalidOperationException();
	}
	public ObjectIf GetOpGroup(int gi) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHOpObjIf_GetOpGroup((IntPtr) _thisArray[phSceneIf.sceneForStep], (int) gi);
            if (ptr == IntPtr.Zero) { return null; } 
            ObjectIf obj = new ObjectIf(ptr);
            if (obj.GetIfInfo() == PHSolidPairIf.GetIfInfoStatic()) { return new PHSolidPairIf(ptr); }
            if (obj.GetIfInfo() == PHOpParticleIf.GetIfInfoStatic()) { return new PHOpParticleIf(ptr); }
            if (obj.GetIfInfo() == PHOpGroupIf.GetIfInfoStatic()) { return new PHOpGroupIf(ptr); }
            if (obj.GetIfInfo() == PHOpSpHashColliAgentIf.GetIfInfoStatic()) { return new PHOpSpHashColliAgentIf(ptr); }
            if (obj.GetIfInfo() == PHSolidPairForLCPIf.GetIfInfoStatic()) { return new PHSolidPairForLCPIf(ptr); }
            if (obj.GetIfInfo() == PHSolidPairForHapticIf.GetIfInfoStatic()) { return new PHSolidPairForHapticIf(ptr); }
            return obj;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHOpObjIf_GetOpGroup((IntPtr) _thisArray[phSceneIf.sceneForGet], (int) gi);
            if (ptr == IntPtr.Zero) { return null; } 
            ObjectIf obj = new ObjectIf(ptr);
            if (obj.GetIfInfo() == PHSolidPairIf.GetIfInfoStatic()) { return new PHSolidPairIf(ptr); }
            if (obj.GetIfInfo() == PHOpParticleIf.GetIfInfoStatic()) { return new PHOpParticleIf(ptr); }
            if (obj.GetIfInfo() == PHOpGroupIf.GetIfInfoStatic()) { return new PHOpGroupIf(ptr); }
            if (obj.GetIfInfo() == PHOpSpHashColliAgentIf.GetIfInfoStatic()) { return new PHOpSpHashColliAgentIf(ptr); }
            if (obj.GetIfInfo() == PHSolidPairForLCPIf.GetIfInfoStatic()) { return new PHSolidPairForLCPIf(ptr); }
            if (obj.GetIfInfo() == PHSolidPairForHapticIf.GetIfInfoStatic()) { return new PHSolidPairForHapticIf(ptr); }
            return obj;
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHOpObjIf_GetOpGroup((IntPtr) _thisArray[0], (int) gi);
            if (ptr == IntPtr.Zero) { return null; } 
            ObjectIf obj = new ObjectIf(ptr);
            if (obj.GetIfInfo() == PHSolidPairIf.GetIfInfoStatic()) { return new PHSolidPairIf(ptr); }
            if (obj.GetIfInfo() == PHOpParticleIf.GetIfInfoStatic()) { return new PHOpParticleIf(ptr); }
            if (obj.GetIfInfo() == PHOpGroupIf.GetIfInfoStatic()) { return new PHOpGroupIf(ptr); }
            if (obj.GetIfInfo() == PHOpSpHashColliAgentIf.GetIfInfoStatic()) { return new PHOpSpHashColliAgentIf(ptr); }
            if (obj.GetIfInfo() == PHSolidPairForLCPIf.GetIfInfoStatic()) { return new PHSolidPairForLCPIf(ptr); }
            if (obj.GetIfInfo() == PHSolidPairForHapticIf.GetIfInfoStatic()) { return new PHSolidPairForHapticIf(ptr); }
            return obj;
		}
		throw new InvalidOperationException();
	}
	public int GetobjVtoPmap(int vi) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    int result = (int) SprExport.Spr_PHOpObjIf_GetobjVtoPmap((IntPtr) _thisArray[phSceneIf.sceneForStep], (int) vi);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    int result = (int) SprExport.Spr_PHOpObjIf_GetobjVtoPmap((IntPtr) _thisArray[phSceneIf.sceneForGet], (int) vi);
	    return result;
				}
			}
		} else {
	    int result = (int) SprExport.Spr_PHOpObjIf_GetobjVtoPmap((IntPtr) _thisArray[0], (int) vi);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public float GetVtxBlendWeight(int Vtxi, int Grpi) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    float result = (float) SprExport.Spr_PHOpObjIf_GetVtxBlendWeight((IntPtr) _thisArray[phSceneIf.sceneForStep], (int) Vtxi, (int) Grpi);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    float result = (float) SprExport.Spr_PHOpObjIf_GetVtxBlendWeight((IntPtr) _thisArray[phSceneIf.sceneForGet], (int) Vtxi, (int) Grpi);
	    return result;
				}
			}
		} else {
	    float result = (float) SprExport.Spr_PHOpObjIf_GetVtxBlendWeight((IntPtr) _thisArray[0], (int) Vtxi, (int) Grpi);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public void SetVelocityDamping(float vd) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHOpObjIf_SetVelocityDamping((IntPtr) _thisArray[phSceneIf.sceneForStep], (float) vd);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHOpObjIf_SetVelocityDamping((IntPtr) _thisArray[phSceneIf.sceneForGet], (float) vd);
				}
			}
		} else {
	    SprExport.Spr_PHOpObjIf_SetVelocityDamping((IntPtr) _thisArray[0], (float) vd);
		}
		throw new InvalidOperationException();
	}
	public float GetVelocityDamping() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    float result = (float) SprExport.Spr_PHOpObjIf_GetVelocityDamping((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    float result = (float) SprExport.Spr_PHOpObjIf_GetVelocityDamping((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    float result = (float) SprExport.Spr_PHOpObjIf_GetVelocityDamping((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public float GetBoundLength() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    float result = (float) SprExport.Spr_PHOpObjIf_GetBoundLength((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    float result = (float) SprExport.Spr_PHOpObjIf_GetBoundLength((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    float result = (float) SprExport.Spr_PHOpObjIf_GetBoundLength((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public void SetBound(float b) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHOpObjIf_SetBound((IntPtr) _thisArray[phSceneIf.sceneForStep], (float) b);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHOpObjIf_SetBound((IntPtr) _thisArray[phSceneIf.sceneForGet], (float) b);
				}
			}
		} else {
	    SprExport.Spr_PHOpObjIf_SetBound((IntPtr) _thisArray[0], (float) b);
		}
		throw new InvalidOperationException();
	}
	public void SetTimeStep(float t) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHOpObjIf_SetTimeStep((IntPtr) _thisArray[phSceneIf.sceneForStep], (float) t);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHOpObjIf_SetTimeStep((IntPtr) _thisArray[phSceneIf.sceneForGet], (float) t);
				}
			}
		} else {
	    SprExport.Spr_PHOpObjIf_SetTimeStep((IntPtr) _thisArray[0], (float) t);
		}
		throw new InvalidOperationException();
	}
	public float GetTimeStep() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    float result = (float) SprExport.Spr_PHOpObjIf_GetTimeStep((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    float result = (float) SprExport.Spr_PHOpObjIf_GetTimeStep((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    float result = (float) SprExport.Spr_PHOpObjIf_GetTimeStep((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public float GetObjBeta() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    float result = (float) SprExport.Spr_PHOpObjIf_GetObjBeta((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    float result = (float) SprExport.Spr_PHOpObjIf_GetObjBeta((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    float result = (float) SprExport.Spr_PHOpObjIf_GetObjBeta((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public void SetObjBeta(float beta) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHOpObjIf_SetObjBeta((IntPtr) _thisArray[phSceneIf.sceneForStep], (float) beta);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHOpObjIf_SetObjBeta((IntPtr) _thisArray[phSceneIf.sceneForGet], (float) beta);
				}
			}
		} else {
	    SprExport.Spr_PHOpObjIf_SetObjBeta((IntPtr) _thisArray[0], (float) beta);
		}
		throw new InvalidOperationException();
	}
	public void SetObjAlpha(float alpha) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHOpObjIf_SetObjAlpha((IntPtr) _thisArray[phSceneIf.sceneForStep], (float) alpha);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHOpObjIf_SetObjAlpha((IntPtr) _thisArray[phSceneIf.sceneForGet], (float) alpha);
				}
			}
		} else {
	    SprExport.Spr_PHOpObjIf_SetObjAlpha((IntPtr) _thisArray[0], (float) alpha);
		}
		throw new InvalidOperationException();
	}
	public float GetObjAlpha() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    float result = (float) SprExport.Spr_PHOpObjIf_GetObjAlpha((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    float result = (float) SprExport.Spr_PHOpObjIf_GetObjAlpha((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    float result = (float) SprExport.Spr_PHOpObjIf_GetObjAlpha((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public bool GetObjDstConstraint() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    char ret = SprExport.Spr_PHOpObjIf_GetObjDstConstraint((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return (ret == 0) ? false : true;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    char ret = SprExport.Spr_PHOpObjIf_GetObjDstConstraint((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return (ret == 0) ? false : true;
				}
			}
		} else {
	    char ret = SprExport.Spr_PHOpObjIf_GetObjDstConstraint((IntPtr) _thisArray[0]);
	    return (ret == 0) ? false : true;
		}
		throw new InvalidOperationException();
	}
	public void SetObjDstConstraint(bool d) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHOpObjIf_SetObjDstConstraint((IntPtr) _thisArray[phSceneIf.sceneForStep], (bool) d);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHOpObjIf_SetObjDstConstraint((IntPtr) _thisArray[phSceneIf.sceneForGet], (bool) d);
				}
			}
		} else {
	    SprExport.Spr_PHOpObjIf_SetObjDstConstraint((IntPtr) _thisArray[0], (bool) d);
		}
		throw new InvalidOperationException();
	}
	public void SetObjItrTime(int itrT) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHOpObjIf_SetObjItrTime((IntPtr) _thisArray[phSceneIf.sceneForStep], (int) itrT);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHOpObjIf_SetObjItrTime((IntPtr) _thisArray[phSceneIf.sceneForGet], (int) itrT);
				}
			}
		} else {
	    SprExport.Spr_PHOpObjIf_SetObjItrTime((IntPtr) _thisArray[0], (int) itrT);
		}
		throw new InvalidOperationException();
	}
	public int GetObjItrTime() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    int result = (int) SprExport.Spr_PHOpObjIf_GetObjItrTime((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    int result = (int) SprExport.Spr_PHOpObjIf_GetObjItrTime((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    int result = (int) SprExport.Spr_PHOpObjIf_GetObjItrTime((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public void StoreOrigPose() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHOpObjIf_StoreOrigPose((IntPtr) _thisArray[phSceneIf.sceneForStep]);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHOpObjIf_StoreOrigPose((IntPtr) _thisArray[phSceneIf.sceneForGet]);
				}
			}
		} else {
	    SprExport.Spr_PHOpObjIf_StoreOrigPose((IntPtr) _thisArray[0]);
		}
		throw new InvalidOperationException();
	}
    }
    public partial class PHOpParticleIf : ObjectIf {
	public PHOpParticleIf() { _thisArray[0] = SprExport.Spr_new_PHOpParticleIf(); _flag = true; }
	public PHOpParticleIf(IntPtr ptr) : base(ptr) {}
	public PHOpParticleIf(IntPtr ptr, bool flag) : base(ptr, flag) {}
	public static implicit operator PHOpParticleIf(CsCastObject target) {
		return (target._info.Inherit(PHOpParticleIf.GetIfInfoStatic()) ? new PHOpParticleIf(target._thisArray[0], target._flag) : null);
	}
	~PHOpParticleIf() { if (_flag) { SprExport.Spr_delete_PHOpParticleIf(_thisArray[0]); _flag = false; } }
        public override string ToString() {
            IntPtr ptr = SprExport.Spr_PHOpParticleIf_ToString((IntPtr) _thisArray[0]);
            string bstr = Marshal.PtrToStringBSTR(ptr);
            SprExport.Spr_PHOpParticleIf_FreeString((IntPtr) ptr);
            return bstr;
        }
	public IfInfo GetIfInfo() {
	    IntPtr ptr = SprExport.Spr_PHOpParticleIf_GetIfInfo((IntPtr) _thisArray[0]);
            return new IfInfo(ptr);
	}
	public static IfInfo GetIfInfoStatic() {
	    IntPtr ptr = SprExport.Spr_PHOpParticleIf_GetIfInfoStatic();
            return new IfInfo(ptr);
	}
	public int GetOpPtclVtxId(int vi) {
	    int result = (int) SprExport.Spr_PHOpParticleIf_GetOpPtclVtxId((IntPtr) _thisArray[0], (int) vi);
	    return result;
	}
	public int GetinGrpListNum() {
	    int result = (int) SprExport.Spr_PHOpParticleIf_GetinGrpListNum((IntPtr) _thisArray[0]);
	    return result;
	}
	public int GetinGrpList(int gi) {
	    int result = (int) SprExport.Spr_PHOpParticleIf_GetinGrpList((IntPtr) _thisArray[0], (int) gi);
	    return result;
	}
	public float GetVtxDisWeight(int vi) {
	    float result = (float) SprExport.Spr_PHOpParticleIf_GetVtxDisWeight((IntPtr) _thisArray[0], (int) vi);
	    return result;
	}
	public arraywrapper_PHOpParticleDesc GetParticleDesc() {
	    IntPtr ptr = SprExport.Spr_PHOpParticleIf_GetParticleDesc((IntPtr) _thisArray[0]);
            return new arraywrapper_PHOpParticleDesc(ptr);
	}
    }
    public partial class PHOpGroupIf : ObjectIf {
	public PHOpGroupIf() { _thisArray[0] = SprExport.Spr_new_PHOpGroupIf(); _flag = true; }
	public PHOpGroupIf(IntPtr ptr) : base(ptr) {}
	public PHOpGroupIf(IntPtr ptr, bool flag) : base(ptr, flag) {}
	public static implicit operator PHOpGroupIf(CsCastObject target) {
		return (target._info.Inherit(PHOpGroupIf.GetIfInfoStatic()) ? new PHOpGroupIf(target._thisArray[0], target._flag) : null);
	}
	~PHOpGroupIf() { if (_flag) { SprExport.Spr_delete_PHOpGroupIf(_thisArray[0]); _flag = false; } }
        public override string ToString() {
            IntPtr ptr = SprExport.Spr_PHOpGroupIf_ToString((IntPtr) _thisArray[0]);
            string bstr = Marshal.PtrToStringBSTR(ptr);
            SprExport.Spr_PHOpGroupIf_FreeString((IntPtr) ptr);
            return bstr;
        }
	public IfInfo GetIfInfo() {
	    IntPtr ptr = SprExport.Spr_PHOpGroupIf_GetIfInfo((IntPtr) _thisArray[0]);
            return new IfInfo(ptr);
	}
	public static IfInfo GetIfInfoStatic() {
	    IntPtr ptr = SprExport.Spr_PHOpGroupIf_GetIfInfoStatic();
            return new IfInfo(ptr);
	}
	public int GetGrpInPtclNum() {
	    int result = (int) SprExport.Spr_PHOpGroupIf_GetGrpInPtclNum((IntPtr) _thisArray[0]);
	    return result;
	}
	public int GetGrpInPtcl(int gi) {
	    int result = (int) SprExport.Spr_PHOpGroupIf_GetGrpInPtcl((IntPtr) _thisArray[0], (int) gi);
	    return result;
	}
	public arraywrapper_PHOpGroupDesc GetGroupDesc() {
	    IntPtr ptr = SprExport.Spr_PHOpGroupIf_GetGroupDesc((IntPtr) _thisArray[0]);
            return new arraywrapper_PHOpGroupDesc(ptr);
	}
    }
    public partial class PHOpHapticControllerIf : SceneObjectIf {
	public PHOpHapticControllerIf() { _thisArray[0] = SprExport.Spr_new_PHOpHapticControllerIf(); _flag = true; }
	public PHOpHapticControllerIf(IntPtr ptr) : base(ptr) {}
	public PHOpHapticControllerIf(IntPtr ptr, bool flag) : base(ptr, flag) {}
	public static implicit operator PHOpHapticControllerIf(CsCastObject target) {
		return (target._info.Inherit(PHOpHapticControllerIf.GetIfInfoStatic()) ? new PHOpHapticControllerIf(target._thisArray[0], target._flag) : null);
	}
	~PHOpHapticControllerIf() { if (_flag) { SprExport.Spr_delete_PHOpHapticControllerIf(_thisArray[0]); _flag = false; } }
        public override string ToString() {
            IntPtr ptr = SprExport.Spr_PHOpHapticControllerIf_ToString((IntPtr) _thisArray[0]);
            string bstr = Marshal.PtrToStringBSTR(ptr);
            SprExport.Spr_PHOpHapticControllerIf_FreeString((IntPtr) ptr);
            return bstr;
        }
	public IfInfo GetIfInfo() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHOpHapticControllerIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new IfInfo(ptr);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHOpHapticControllerIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new IfInfo(ptr);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHOpHapticControllerIf_GetIfInfo((IntPtr) _thisArray[0]);
            return new IfInfo(ptr);
		}
		throw new InvalidOperationException();
	}
	public static IfInfo GetIfInfoStatic() {
	    IntPtr ptr = SprExport.Spr_PHOpHapticControllerIf_GetIfInfoStatic();
            return new IfInfo(ptr);
	}
	public void SetHCForceReady(bool flag) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHOpHapticControllerIf_SetHCForceReady((IntPtr) _thisArray[phSceneIf.sceneForStep], (bool) flag);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHOpHapticControllerIf_SetHCForceReady((IntPtr) _thisArray[phSceneIf.sceneForGet], (bool) flag);
				}
			}
		} else {
	    SprExport.Spr_PHOpHapticControllerIf_SetHCForceReady((IntPtr) _thisArray[0], (bool) flag);
		}
		throw new InvalidOperationException();
	}
	public bool GetHCForceReady() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    char ret = SprExport.Spr_PHOpHapticControllerIf_GetHCForceReady((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return (ret == 0) ? false : true;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    char ret = SprExport.Spr_PHOpHapticControllerIf_GetHCForceReady((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return (ret == 0) ? false : true;
				}
			}
		} else {
	    char ret = SprExport.Spr_PHOpHapticControllerIf_GetHCForceReady((IntPtr) _thisArray[0]);
	    return (ret == 0) ? false : true;
		}
		throw new InvalidOperationException();
	}
	public bool CheckProxyState() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    char ret = SprExport.Spr_PHOpHapticControllerIf_CheckProxyState((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return (ret == 0) ? false : true;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    char ret = SprExport.Spr_PHOpHapticControllerIf_CheckProxyState((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return (ret == 0) ? false : true;
				}
			}
		} else {
	    char ret = SprExport.Spr_PHOpHapticControllerIf_CheckProxyState((IntPtr) _thisArray[0]);
	    return (ret == 0) ? false : true;
		}
		throw new InvalidOperationException();
	}
	public void AddColliedPtcl(int pIndex, int objindex, Vec3f ctcPos) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHOpHapticControllerIf_AddColliedPtcl((IntPtr) _thisArray[phSceneIf.sceneForStep], (int) pIndex, (int) objindex, (IntPtr) ctcPos);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHOpHapticControllerIf_AddColliedPtcl((IntPtr) _thisArray[phSceneIf.sceneForGet], (int) pIndex, (int) objindex, (IntPtr) ctcPos);
				}
			}
		} else {
	    SprExport.Spr_PHOpHapticControllerIf_AddColliedPtcl((IntPtr) _thisArray[0], (int) pIndex, (int) objindex, (IntPtr) ctcPos);
		}
		throw new InvalidOperationException();
	}
	public bool BeginLogForce() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    char ret = SprExport.Spr_PHOpHapticControllerIf_BeginLogForce((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return (ret == 0) ? false : true;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    char ret = SprExport.Spr_PHOpHapticControllerIf_BeginLogForce((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return (ret == 0) ? false : true;
				}
			}
		} else {
	    char ret = SprExport.Spr_PHOpHapticControllerIf_BeginLogForce((IntPtr) _thisArray[0]);
	    return (ret == 0) ? false : true;
		}
		throw new InvalidOperationException();
	}
	public void EndLogForce() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHOpHapticControllerIf_EndLogForce((IntPtr) _thisArray[phSceneIf.sceneForStep]);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHOpHapticControllerIf_EndLogForce((IntPtr) _thisArray[phSceneIf.sceneForGet]);
				}
			}
		} else {
	    SprExport.Spr_PHOpHapticControllerIf_EndLogForce((IntPtr) _thisArray[0]);
		}
		throw new InvalidOperationException();
	}
	public void setC_ObstacleRadius(float r) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHOpHapticControllerIf_setC_ObstacleRadius((IntPtr) _thisArray[phSceneIf.sceneForStep], (float) r);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHOpHapticControllerIf_setC_ObstacleRadius((IntPtr) _thisArray[phSceneIf.sceneForGet], (float) r);
				}
			}
		} else {
	    SprExport.Spr_PHOpHapticControllerIf_setC_ObstacleRadius((IntPtr) _thisArray[0], (float) r);
		}
		throw new InvalidOperationException();
	}
	public Vec3f GetUserPos() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHOpHapticControllerIf_GetUserPos((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new Vec3f(ptr, true);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHOpHapticControllerIf_GetUserPos((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new Vec3f(ptr, true);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHOpHapticControllerIf_GetUserPos((IntPtr) _thisArray[0]);
            return new Vec3f(ptr, true);
		}
		throw new InvalidOperationException();
	}
	public Vec3f GetHCPosition() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHOpHapticControllerIf_GetHCPosition((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new Vec3f(ptr, true);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHOpHapticControllerIf_GetHCPosition((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new Vec3f(ptr, true);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHOpHapticControllerIf_GetHCPosition((IntPtr) _thisArray[0]);
            return new Vec3f(ptr, true);
		}
		throw new InvalidOperationException();
	}
	public void SetHCPosition(Vec3f pos) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHOpHapticControllerIf_SetHCPosition((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) pos);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHOpHapticControllerIf_SetHCPosition((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) pos);
				}
			}
		} else {
	    SprExport.Spr_PHOpHapticControllerIf_SetHCPosition((IntPtr) _thisArray[0], (IntPtr) pos);
		}
		throw new InvalidOperationException();
	}
	public void SetHCPose(Posef pose) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHOpHapticControllerIf_SetHCPose((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) pose);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHOpHapticControllerIf_SetHCPose((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) pose);
				}
			}
		} else {
	    SprExport.Spr_PHOpHapticControllerIf_SetHCPose((IntPtr) _thisArray[0], (IntPtr) pose);
		}
		throw new InvalidOperationException();
	}
	public Posef GetHCPose() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHOpHapticControllerIf_GetHCPose((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new Posef(ptr, true);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHOpHapticControllerIf_GetHCPose((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new Posef(ptr, true);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHOpHapticControllerIf_GetHCPose((IntPtr) _thisArray[0]);
            return new Posef(ptr, true);
		}
		throw new InvalidOperationException();
	}
	public float GetC_ObstacleRadius() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    float result = (float) SprExport.Spr_PHOpHapticControllerIf_GetC_ObstacleRadius((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    float result = (float) SprExport.Spr_PHOpHapticControllerIf_GetC_ObstacleRadius((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    float result = (float) SprExport.Spr_PHOpHapticControllerIf_GetC_ObstacleRadius((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public Vec3f GetCurrentOutputForce() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHOpHapticControllerIf_GetCurrentOutputForce((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new Vec3f(ptr, true);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHOpHapticControllerIf_GetCurrentOutputForce((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new Vec3f(ptr, true);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHOpHapticControllerIf_GetCurrentOutputForce((IntPtr) _thisArray[0]);
            return new Vec3f(ptr, true);
		}
		throw new InvalidOperationException();
	}
    }
    public partial class PHOpHapticRendererIf : SceneObjectIf {
	public PHOpHapticRendererIf() { _thisArray[0] = SprExport.Spr_new_PHOpHapticRendererIf(); _flag = true; }
	public PHOpHapticRendererIf(IntPtr ptr) : base(ptr) {}
	public PHOpHapticRendererIf(IntPtr ptr, bool flag) : base(ptr, flag) {}
	public static implicit operator PHOpHapticRendererIf(CsCastObject target) {
		return (target._info.Inherit(PHOpHapticRendererIf.GetIfInfoStatic()) ? new PHOpHapticRendererIf(target._thisArray[0], target._flag) : null);
	}
	~PHOpHapticRendererIf() { if (_flag) { SprExport.Spr_delete_PHOpHapticRendererIf(_thisArray[0]); _flag = false; } }
        public override string ToString() {
            IntPtr ptr = SprExport.Spr_PHOpHapticRendererIf_ToString((IntPtr) _thisArray[0]);
            string bstr = Marshal.PtrToStringBSTR(ptr);
            SprExport.Spr_PHOpHapticRendererIf_FreeString((IntPtr) ptr);
            return bstr;
        }
	public IfInfo GetIfInfo() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHOpHapticRendererIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new IfInfo(ptr);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHOpHapticRendererIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new IfInfo(ptr);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHOpHapticRendererIf_GetIfInfo((IntPtr) _thisArray[0]);
            return new IfInfo(ptr);
		}
		throw new InvalidOperationException();
	}
	public static IfInfo GetIfInfoStatic() {
	    IntPtr ptr = SprExport.Spr_PHOpHapticRendererIf_GetIfInfoStatic();
            return new IfInfo(ptr);
	}
	public void SetRigid(bool set) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHOpHapticRendererIf_SetRigid((IntPtr) _thisArray[phSceneIf.sceneForStep], (bool) set);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHOpHapticRendererIf_SetRigid((IntPtr) _thisArray[phSceneIf.sceneForGet], (bool) set);
				}
			}
		} else {
	    SprExport.Spr_PHOpHapticRendererIf_SetRigid((IntPtr) _thisArray[0], (bool) set);
		}
		throw new InvalidOperationException();
	}
	public bool IsRigid() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    char ret = SprExport.Spr_PHOpHapticRendererIf_IsRigid((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return (ret == 0) ? false : true;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    char ret = SprExport.Spr_PHOpHapticRendererIf_IsRigid((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return (ret == 0) ? false : true;
				}
			}
		} else {
	    char ret = SprExport.Spr_PHOpHapticRendererIf_IsRigid((IntPtr) _thisArray[0]);
	    return (ret == 0) ? false : true;
		}
		throw new InvalidOperationException();
	}
    }
    public partial class PHOpAnimationIf : SceneObjectIf {
	public PHOpAnimationIf() { _thisArray[0] = SprExport.Spr_new_PHOpAnimationIf(); _flag = true; }
	public PHOpAnimationIf(IntPtr ptr) : base(ptr) {}
	public PHOpAnimationIf(IntPtr ptr, bool flag) : base(ptr, flag) {}
	public static implicit operator PHOpAnimationIf(CsCastObject target) {
		return (target._info.Inherit(PHOpAnimationIf.GetIfInfoStatic()) ? new PHOpAnimationIf(target._thisArray[0], target._flag) : null);
	}
	~PHOpAnimationIf() { if (_flag) { SprExport.Spr_delete_PHOpAnimationIf(_thisArray[0]); _flag = false; } }
        public override string ToString() {
            IntPtr ptr = SprExport.Spr_PHOpAnimationIf_ToString((IntPtr) _thisArray[0]);
            string bstr = Marshal.PtrToStringBSTR(ptr);
            SprExport.Spr_PHOpAnimationIf_FreeString((IntPtr) ptr);
            return bstr;
        }
	public IfInfo GetIfInfo() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHOpAnimationIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new IfInfo(ptr);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHOpAnimationIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new IfInfo(ptr);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHOpAnimationIf_GetIfInfo((IntPtr) _thisArray[0]);
            return new IfInfo(ptr);
		}
		throw new InvalidOperationException();
	}
	public static IfInfo GetIfInfoStatic() {
	    IntPtr ptr = SprExport.Spr_PHOpAnimationIf_GetIfInfoStatic();
            return new IfInfo(ptr);
	}
	public void AddAnimationP(int objIndex, int pIndex, Vec3f start, Vec3f end, float totalTime) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHOpAnimationIf_AddAnimationP((IntPtr) _thisArray[phSceneIf.sceneForStep], (int) objIndex, (int) pIndex, (IntPtr) start, (IntPtr) end, (float) totalTime);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHOpAnimationIf_AddAnimationP((IntPtr) _thisArray[phSceneIf.sceneForGet], (int) objIndex, (int) pIndex, (IntPtr) start, (IntPtr) end, (float) totalTime);
				}
			}
		} else {
	    SprExport.Spr_PHOpAnimationIf_AddAnimationP((IntPtr) _thisArray[0], (int) objIndex, (int) pIndex, (IntPtr) start, (IntPtr) end, (float) totalTime);
		}
		throw new InvalidOperationException();
	}
	public void AddAnimationP(int objIndex, int pIndex, Vec3f force, float totalTime) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHOpAnimationIf_AddAnimationP_1((IntPtr) _thisArray[phSceneIf.sceneForStep], (int) objIndex, (int) pIndex, (IntPtr) force, (float) totalTime);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHOpAnimationIf_AddAnimationP_1((IntPtr) _thisArray[phSceneIf.sceneForGet], (int) objIndex, (int) pIndex, (IntPtr) force, (float) totalTime);
				}
			}
		} else {
	    SprExport.Spr_PHOpAnimationIf_AddAnimationP_1((IntPtr) _thisArray[0], (int) objIndex, (int) pIndex, (IntPtr) force, (float) totalTime);
		}
		throw new InvalidOperationException();
	}
	public void AnimationStep(CsObject opEngine) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHOpAnimationIf_AnimationStep((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) opEngine);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHOpAnimationIf_AnimationStep((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) opEngine);
				}
			}
		} else {
	    SprExport.Spr_PHOpAnimationIf_AnimationStep((IntPtr) _thisArray[0], (IntPtr) opEngine);
		}
		throw new InvalidOperationException();
	}
	public void AnimationIntergration(CsObject opEngine) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHOpAnimationIf_AnimationIntergration((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) opEngine);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHOpAnimationIf_AnimationIntergration((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) opEngine);
				}
			}
		} else {
	    SprExport.Spr_PHOpAnimationIf_AnimationIntergration((IntPtr) _thisArray[0], (IntPtr) opEngine);
		}
		throw new InvalidOperationException();
	}
    }
    public partial class PHOpSpHashColliAgentIf : ObjectIf {
	public PHOpSpHashColliAgentIf() { _thisArray[0] = SprExport.Spr_new_PHOpSpHashColliAgentIf(); _flag = true; }
	public PHOpSpHashColliAgentIf(IntPtr ptr) : base(ptr) {}
	public PHOpSpHashColliAgentIf(IntPtr ptr, bool flag) : base(ptr, flag) {}
	public static implicit operator PHOpSpHashColliAgentIf(CsCastObject target) {
		return (target._info.Inherit(PHOpSpHashColliAgentIf.GetIfInfoStatic()) ? new PHOpSpHashColliAgentIf(target._thisArray[0], target._flag) : null);
	}
	~PHOpSpHashColliAgentIf() { if (_flag) { SprExport.Spr_delete_PHOpSpHashColliAgentIf(_thisArray[0]); _flag = false; } }
        public override string ToString() {
            IntPtr ptr = SprExport.Spr_PHOpSpHashColliAgentIf_ToString((IntPtr) _thisArray[0]);
            string bstr = Marshal.PtrToStringBSTR(ptr);
            SprExport.Spr_PHOpSpHashColliAgentIf_FreeString((IntPtr) ptr);
            return bstr;
        }
	public IfInfo GetIfInfo() {
	    IntPtr ptr = SprExport.Spr_PHOpSpHashColliAgentIf_GetIfInfo((IntPtr) _thisArray[0]);
            return new IfInfo(ptr);
	}
	public static IfInfo GetIfInfoStatic() {
	    IntPtr ptr = SprExport.Spr_PHOpSpHashColliAgentIf_GetIfInfoStatic();
            return new IfInfo(ptr);
	}
	public void SetCollisionCstrStiffness(float alpha) {
	    SprExport.Spr_PHOpSpHashColliAgentIf_SetCollisionCstrStiffness((IntPtr) _thisArray[0], (float) alpha);
	}
	public float GetCollisionCstrStiffness() {
	    float result = (float) SprExport.Spr_PHOpSpHashColliAgentIf_GetCollisionCstrStiffness((IntPtr) _thisArray[0]);
	    return result;
	}
	public void EnableCollisionDetection(bool able) {
	    SprExport.Spr_PHOpSpHashColliAgentIf_EnableCollisionDetection((IntPtr) _thisArray[0], (bool) able);
	}
	public void EnableCollisionDetection() {
	    SprExport.Spr_PHOpSpHashColliAgentIf_EnableCollisionDetection_1((IntPtr) _thisArray[0]);
	}
	public void Initial(float cellSize, CDBounds bounds) {
	    SprExport.Spr_PHOpSpHashColliAgentIf_Initial((IntPtr) _thisArray[0], (float) cellSize, (IntPtr) bounds);
	}
	public void OpCollisionProcedure(int myTimeStamp) {
	    SprExport.Spr_PHOpSpHashColliAgentIf_OpCollisionProcedure((IntPtr) _thisArray[0], (int) myTimeStamp);
	}
	public void OpCollisionProcedure() {
	    SprExport.Spr_PHOpSpHashColliAgentIf_OpCollisionProcedure_1((IntPtr) _thisArray[0]);
	}
	public void OpDirCollision() {
	    SprExport.Spr_PHOpSpHashColliAgentIf_OpDirCollision((IntPtr) _thisArray[0]);
	}
	public void AddContactPlane(Vec3f planeP, Vec3f planeN) {
	    SprExport.Spr_PHOpSpHashColliAgentIf_AddContactPlane((IntPtr) _thisArray[0], (IntPtr) planeP, (IntPtr) planeN);
	}
	public bool IsCollisionEnabled() {
	    char ret = SprExport.Spr_PHOpSpHashColliAgentIf_IsCollisionEnabled((IntPtr) _thisArray[0]);
	    return (ret == 0) ? false : true;
	}
	public void SetIsDirCollision(bool flag) {
	    SprExport.Spr_PHOpSpHashColliAgentIf_SetIsDirCollision((IntPtr) _thisArray[0], (bool) flag);
	}
	public bool GetIsDirCollision() {
	    char ret = SprExport.Spr_PHOpSpHashColliAgentIf_GetIsDirCollision((IntPtr) _thisArray[0]);
	    return (ret == 0) ? false : true;
	}
	public void SetDebugMode(bool flag) {
	    SprExport.Spr_PHOpSpHashColliAgentIf_SetDebugMode((IntPtr) _thisArray[0], (bool) flag);
	}
	public bool GetDebugMode() {
	    char ret = SprExport.Spr_PHOpSpHashColliAgentIf_GetDebugMode((IntPtr) _thisArray[0]);
	    return (ret == 0) ? false : true;
	}
    }
    public partial class PHRayIf : SceneObjectIf {
	public PHRayIf() { _thisArray[0] = SprExport.Spr_new_PHRayIf(); _flag = true; }
	public PHRayIf(IntPtr ptr) : base(ptr) {}
	public PHRayIf(IntPtr ptr, bool flag) : base(ptr, flag) {}
	public static implicit operator PHRayIf(CsCastObject target) {
		return (target._info.Inherit(PHRayIf.GetIfInfoStatic()) ? new PHRayIf(target._thisArray[0], target._flag) : null);
	}
	~PHRayIf() { if (_flag) { SprExport.Spr_delete_PHRayIf(_thisArray[0]); _flag = false; } }
        public override string ToString() {
            IntPtr ptr = SprExport.Spr_PHRayIf_ToString((IntPtr) _thisArray[0]);
            string bstr = Marshal.PtrToStringBSTR(ptr);
            SprExport.Spr_PHRayIf_FreeString((IntPtr) ptr);
            return bstr;
        }
	public IfInfo GetIfInfo() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHRayIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new IfInfo(ptr);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHRayIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new IfInfo(ptr);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHRayIf_GetIfInfo((IntPtr) _thisArray[0]);
            return new IfInfo(ptr);
		}
		throw new InvalidOperationException();
	}
	public static IfInfo GetIfInfoStatic() {
	    IntPtr ptr = SprExport.Spr_PHRayIf_GetIfInfoStatic();
            return new IfInfo(ptr);
	}
	public Vec3d GetOrigin() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHRayIf_GetOrigin((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new Vec3d(ptr, true);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHRayIf_GetOrigin((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new Vec3d(ptr, true);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHRayIf_GetOrigin((IntPtr) _thisArray[0]);
            return new Vec3d(ptr, true);
		}
		throw new InvalidOperationException();
	}
	public void SetOrigin(Vec3d ori) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHRayIf_SetOrigin((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) ori);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHRayIf_SetOrigin((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) ori);
				}
			}
		} else {
	    SprExport.Spr_PHRayIf_SetOrigin((IntPtr) _thisArray[0], (IntPtr) ori);
		}
		throw new InvalidOperationException();
	}
	public Vec3d GetDirection() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHRayIf_GetDirection((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new Vec3d(ptr, true);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHRayIf_GetDirection((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new Vec3d(ptr, true);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHRayIf_GetDirection((IntPtr) _thisArray[0]);
            return new Vec3d(ptr, true);
		}
		throw new InvalidOperationException();
	}
	public void SetDirection(Vec3d dir) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHRayIf_SetDirection((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) dir);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHRayIf_SetDirection((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) dir);
				}
			}
		} else {
	    SprExport.Spr_PHRayIf_SetDirection((IntPtr) _thisArray[0], (IntPtr) dir);
		}
		throw new InvalidOperationException();
	}
	public void Apply() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHRayIf_Apply((IntPtr) _thisArray[phSceneIf.sceneForStep]);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHRayIf_Apply((IntPtr) _thisArray[phSceneIf.sceneForGet]);
				}
			}
		} else {
	    SprExport.Spr_PHRayIf_Apply((IntPtr) _thisArray[0]);
		}
		throw new InvalidOperationException();
	}
	public int NHits() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    int result = (int) SprExport.Spr_PHRayIf_NHits((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    int result = (int) SprExport.Spr_PHRayIf_NHits((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    int result = (int) SprExport.Spr_PHRayIf_NHits((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public arraywrapper_PHRaycastHit GetHits() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHRayIf_GetHits((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new arraywrapper_PHRaycastHit(ptr);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHRayIf_GetHits((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new arraywrapper_PHRaycastHit(ptr);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHRayIf_GetHits((IntPtr) _thisArray[0]);
            return new arraywrapper_PHRaycastHit(ptr);
		}
		throw new InvalidOperationException();
	}
	public arraywrapper_PHRaycastHit GetNearest() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHRayIf_GetNearest((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new arraywrapper_PHRaycastHit(ptr);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHRayIf_GetNearest((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new arraywrapper_PHRaycastHit(ptr);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHRayIf_GetNearest((IntPtr) _thisArray[0]);
            return new arraywrapper_PHRaycastHit(ptr);
		}
		throw new InvalidOperationException();
	}
	public arraywrapper_PHRaycastHit GetDynamicalNearest() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHRayIf_GetDynamicalNearest((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new arraywrapper_PHRaycastHit(ptr);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHRayIf_GetDynamicalNearest((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new arraywrapper_PHRaycastHit(ptr);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHRayIf_GetDynamicalNearest((IntPtr) _thisArray[0]);
            return new arraywrapper_PHRaycastHit(ptr);
		}
		throw new InvalidOperationException();
	}
    }
    public partial class PHSceneIf : SceneIf {
	public PHSceneIf() { _thisArray[0] = SprExport.Spr_new_PHSceneIf(); _flag = true; }
	public PHSceneIf(IntPtr ptr) : base(ptr) {}
	public PHSceneIf(IntPtr ptr, bool flag) : base(ptr, flag) {}
	public static implicit operator PHSceneIf(CsCastObject target) {
		return (target._info.Inherit(PHSceneIf.GetIfInfoStatic()) ? new PHSceneIf(target._thisArray[0], target._flag) : null);
	}
	~PHSceneIf() { if (_flag) { SprExport.Spr_delete_PHSceneIf(_thisArray[0]); _flag = false; } }
        public override string ToString() {
            IntPtr ptr = SprExport.Spr_PHSceneIf_ToString((IntPtr) _thisArray[0]);
            string bstr = Marshal.PtrToStringBSTR(ptr);
            SprExport.Spr_PHSceneIf_FreeString((IntPtr) ptr);
            return bstr;
        }
	public IfInfo GetIfInfo() {
	    IntPtr ptr = SprExport.Spr_PHSceneIf_GetIfInfo((IntPtr) _thisArray[0]);
            return new IfInfo(ptr);
	}
	public static IfInfo GetIfInfoStatic() {
	    IntPtr ptr = SprExport.Spr_PHSceneIf_GetIfInfoStatic();
            return new IfInfo(ptr);
	}
	public PHSdkIf GetSdk() {
	    IntPtr ptr = SprExport.Spr_PHSceneIf_GetSdk((IntPtr) _thisArray[0]);
            if (ptr == IntPtr.Zero) { return null; } 
            PHSdkIf obj = new PHSdkIf(ptr);
            return obj;
	}
	public PHSolidIf CreateSolid(PHSolidDesc desc) {
	    IntPtr ptr = SprExport.Spr_PHSceneIf_CreateSolid((IntPtr) _thisArray[0], (IntPtr) desc);
            if (ptr == IntPtr.Zero) { return null; } 
            PHSolidIf obj = new PHSolidIf(ptr);
            if (obj.GetIfInfo() == PHHapticPointerIf.GetIfInfoStatic()) { return new PHHapticPointerIf(ptr); }
            return obj;
	}
	public PHSolidIf CreateSolid() {
	    IntPtr ptr = SprExport.Spr_PHSceneIf_CreateSolid_1((IntPtr) _thisArray[0]);
            if (ptr == IntPtr.Zero) { return null; } 
            PHSolidIf obj = new PHSolidIf(ptr);
            if (obj.GetIfInfo() == PHHapticPointerIf.GetIfInfoStatic()) { return new PHHapticPointerIf(ptr); }
            return obj;
	}
	public int NSolids() {
	    int result = (int) SprExport.Spr_PHSceneIf_NSolids((IntPtr) _thisArray[0]);
	    return result;
	}
	public PHSolidIf GetSolid(int idx) {
	    IntPtr ptr = SprExport.Spr_PHSceneIf_GetSolid((IntPtr) _thisArray[0], (int) idx);
            if (ptr == IntPtr.Zero) { return null; } 
            PHSolidIf obj = new PHSolidIf(ptr);
            if (obj.GetIfInfo() == PHHapticPointerIf.GetIfInfoStatic()) { return new PHHapticPointerIf(ptr); }
            return obj;
	}
	public int GetSolidIndex(PHSolidIf s) {
	    int result = (int) SprExport.Spr_PHSceneIf_GetSolidIndex((IntPtr) _thisArray[0], (IntPtr) s);
	    return result;
	}
	public PHSolidIf GetSolids() {
	    IntPtr ptr = SprExport.Spr_PHSceneIf_GetSolids((IntPtr) _thisArray[0]);
            if (ptr == IntPtr.Zero) { return null; } 
            PHSolidIf obj = new PHSolidIf(ptr);
            if (obj.GetIfInfo() == PHHapticPointerIf.GetIfInfoStatic()) { return new PHHapticPointerIf(ptr); }
            return obj;
	}
	public int NSolidPairs() {
	    int result = (int) SprExport.Spr_PHSceneIf_NSolidPairs((IntPtr) _thisArray[0]);
	    return result;
	}
	public PHSolidPairForLCPIf GetSolidPair(int i, int j) {
	    IntPtr ptr = SprExport.Spr_PHSceneIf_GetSolidPair((IntPtr) _thisArray[0], (int) i, (int) j);
            if (ptr == IntPtr.Zero) { return null; } 
            PHSolidPairForLCPIf obj = new PHSolidPairForLCPIf(ptr);
            return obj;
	}
	public PHSolidPairForLCPIf GetSolidPair(PHSolidIf lhs, PHSolidIf rhs, bool bSwap) {
	    IntPtr ptr = SprExport.Spr_PHSceneIf_GetSolidPair_1((IntPtr) _thisArray[0], (IntPtr) lhs, (IntPtr) rhs, (bool) bSwap);
            if (ptr == IntPtr.Zero) { return null; } 
            PHSolidPairForLCPIf obj = new PHSolidPairForLCPIf(ptr);
            return obj;
	}
	public void SetContactMode(PHSolidIf lhs, PHSolidIf rhs, PHSceneDesc.ContactMode mode) {
	    SprExport.Spr_PHSceneIf_SetContactMode((IntPtr) _thisArray[0], (IntPtr) lhs, (IntPtr) rhs, (int) mode);
	}
	public void SetContactMode(PHSolidIf lhs, PHSolidIf rhs) {
	    SprExport.Spr_PHSceneIf_SetContactMode_1((IntPtr) _thisArray[0], (IntPtr) lhs, (IntPtr) rhs);
	}
	public void SetContactMode(PHSolidIf group, ulong length, PHSceneDesc.ContactMode mode) {
	    SprExport.Spr_PHSceneIf_SetContactMode_2((IntPtr) _thisArray[0], (IntPtr) group, (ulong) length, (int) mode);
	}
	public void SetContactMode(PHSolidIf group, ulong length) {
	    SprExport.Spr_PHSceneIf_SetContactMode_3((IntPtr) _thisArray[0], (IntPtr) group, (ulong) length);
	}
	public void SetContactMode(PHSolidIf solid, PHSceneDesc.ContactMode mode) {
	    SprExport.Spr_PHSceneIf_SetContactMode_4((IntPtr) _thisArray[0], (IntPtr) solid, (int) mode);
	}
	public void SetContactMode(PHSolidIf solid) {
	    SprExport.Spr_PHSceneIf_SetContactMode_5((IntPtr) _thisArray[0], (IntPtr) solid);
	}
	public void SetContactMode(PHSceneDesc.ContactMode mode) {
	    SprExport.Spr_PHSceneIf_SetContactMode_6((IntPtr) _thisArray[0], (int) mode);
	}
	public void SetContactMode() {
	    SprExport.Spr_PHSceneIf_SetContactMode_7((IntPtr) _thisArray[0]);
	}
	public PHJointIf CreateJoint(PHSolidIf lhs, PHSolidIf rhs, IfInfo ii, PHJointDesc desc) {
	    IntPtr ptr = SprExport.Spr_PHSceneIf_CreateJoint((IntPtr) _thisArray[0], (IntPtr) lhs, (IntPtr) rhs, (IntPtr) ii, (IntPtr) desc);
            if (ptr == IntPtr.Zero) { return null; } 
            PHJointIf obj = new PHJointIf(ptr);
            if (obj.GetIfInfo() == PH1DJointIf.GetIfInfoStatic()) { return new PH1DJointIf(ptr); }
            if (obj.GetIfInfo() == PHBallJointIf.GetIfInfoStatic()) { return new PHBallJointIf(ptr); }
            if (obj.GetIfInfo() == PHFixJointIf.GetIfInfoStatic()) { return new PHFixJointIf(ptr); }
            if (obj.GetIfInfo() == PHSpringIf.GetIfInfoStatic()) { return new PHSpringIf(ptr); }
            if (obj.GetIfInfo() == PHMateIf.GetIfInfoStatic()) { return new PHMateIf(ptr); }
            if (obj.GetIfInfo() == PHHingeJointIf.GetIfInfoStatic()) { return new PHHingeJointIf(ptr); }
            if (obj.GetIfInfo() == PHSliderJointIf.GetIfInfoStatic()) { return new PHSliderJointIf(ptr); }
            if (obj.GetIfInfo() == PHPathJointIf.GetIfInfoStatic()) { return new PHPathJointIf(ptr); }
            if (obj.GetIfInfo() == PHGenericJointIf.GetIfInfoStatic()) { return new PHGenericJointIf(ptr); }
            if (obj.GetIfInfo() == PHPointToPointMateIf.GetIfInfoStatic()) { return new PHPointToPointMateIf(ptr); }
            if (obj.GetIfInfo() == PHPointToLineMateIf.GetIfInfoStatic()) { return new PHPointToLineMateIf(ptr); }
            if (obj.GetIfInfo() == PHPointToPlaneMateIf.GetIfInfoStatic()) { return new PHPointToPlaneMateIf(ptr); }
            if (obj.GetIfInfo() == PHLineToLineMateIf.GetIfInfoStatic()) { return new PHLineToLineMateIf(ptr); }
            if (obj.GetIfInfo() == PHPlaneToPlaneMateIf.GetIfInfoStatic()) { return new PHPlaneToPlaneMateIf(ptr); }
            return obj;
	}
	public int NJoints() {
	    int result = (int) SprExport.Spr_PHSceneIf_NJoints((IntPtr) _thisArray[0]);
	    return result;
	}
	public PHJointIf GetJoint(int i) {
	    IntPtr ptr = SprExport.Spr_PHSceneIf_GetJoint((IntPtr) _thisArray[0], (int) i);
            if (ptr == IntPtr.Zero) { return null; } 
            PHJointIf obj = new PHJointIf(ptr);
            if (obj.GetIfInfo() == PH1DJointIf.GetIfInfoStatic()) { return new PH1DJointIf(ptr); }
            if (obj.GetIfInfo() == PHBallJointIf.GetIfInfoStatic()) { return new PHBallJointIf(ptr); }
            if (obj.GetIfInfo() == PHFixJointIf.GetIfInfoStatic()) { return new PHFixJointIf(ptr); }
            if (obj.GetIfInfo() == PHSpringIf.GetIfInfoStatic()) { return new PHSpringIf(ptr); }
            if (obj.GetIfInfo() == PHMateIf.GetIfInfoStatic()) { return new PHMateIf(ptr); }
            if (obj.GetIfInfo() == PHHingeJointIf.GetIfInfoStatic()) { return new PHHingeJointIf(ptr); }
            if (obj.GetIfInfo() == PHSliderJointIf.GetIfInfoStatic()) { return new PHSliderJointIf(ptr); }
            if (obj.GetIfInfo() == PHPathJointIf.GetIfInfoStatic()) { return new PHPathJointIf(ptr); }
            if (obj.GetIfInfo() == PHGenericJointIf.GetIfInfoStatic()) { return new PHGenericJointIf(ptr); }
            if (obj.GetIfInfo() == PHPointToPointMateIf.GetIfInfoStatic()) { return new PHPointToPointMateIf(ptr); }
            if (obj.GetIfInfo() == PHPointToLineMateIf.GetIfInfoStatic()) { return new PHPointToLineMateIf(ptr); }
            if (obj.GetIfInfo() == PHPointToPlaneMateIf.GetIfInfoStatic()) { return new PHPointToPlaneMateIf(ptr); }
            if (obj.GetIfInfo() == PHLineToLineMateIf.GetIfInfoStatic()) { return new PHLineToLineMateIf(ptr); }
            if (obj.GetIfInfo() == PHPlaneToPlaneMateIf.GetIfInfoStatic()) { return new PHPlaneToPlaneMateIf(ptr); }
            return obj;
	}
	public int NContacts() {
	    int result = (int) SprExport.Spr_PHSceneIf_NContacts((IntPtr) _thisArray[0]);
	    return result;
	}
	public PHContactPointIf GetContact(int i) {
	    IntPtr ptr = SprExport.Spr_PHSceneIf_GetContact((IntPtr) _thisArray[0], (int) i);
            if (ptr == IntPtr.Zero) { return null; } 
            PHContactPointIf obj = new PHContactPointIf(ptr);
            return obj;
	}
	public int NFemMeshes() {
	    int result = (int) SprExport.Spr_PHSceneIf_NFemMeshes((IntPtr) _thisArray[0]);
	    return result;
	}
	public PHFemMeshIf GetFemMesh(int i) {
	    IntPtr ptr = SprExport.Spr_PHSceneIf_GetFemMesh((IntPtr) _thisArray[0], (int) i);
            if (ptr == IntPtr.Zero) { return null; } 
            PHFemMeshIf obj = new PHFemMeshIf(ptr);
            if (obj.GetIfInfo() == PHFemMeshThermoIf.GetIfInfoStatic()) { return new PHFemMeshThermoIf(ptr); }
            return obj;
	}
	public int NFemMeshesNew() {
	    int result = (int) SprExport.Spr_PHSceneIf_NFemMeshesNew((IntPtr) _thisArray[0]);
	    return result;
	}
	public PHFemMeshNewIf GetFemMeshNew(int i) {
	    IntPtr ptr = SprExport.Spr_PHSceneIf_GetFemMeshNew((IntPtr) _thisArray[0], (int) i);
            if (ptr == IntPtr.Zero) { return null; } 
            PHFemMeshNewIf obj = new PHFemMeshNewIf(ptr);
            return obj;
	}
	public PHRootNodeIf CreateRootNode(PHSolidIf root, PHRootNodeDesc desc) {
	    IntPtr ptr = SprExport.Spr_PHSceneIf_CreateRootNode((IntPtr) _thisArray[0], (IntPtr) root, (IntPtr) desc);
            if (ptr == IntPtr.Zero) { return null; } 
            PHRootNodeIf obj = new PHRootNodeIf(ptr);
            return obj;
	}
	public PHRootNodeIf CreateRootNode(PHSolidIf root) {
	    IntPtr ptr = SprExport.Spr_PHSceneIf_CreateRootNode_1((IntPtr) _thisArray[0], (IntPtr) root);
            if (ptr == IntPtr.Zero) { return null; } 
            PHRootNodeIf obj = new PHRootNodeIf(ptr);
            return obj;
	}
	public int NRootNodes() {
	    int result = (int) SprExport.Spr_PHSceneIf_NRootNodes((IntPtr) _thisArray[0]);
	    return result;
	}
	public PHRootNodeIf GetRootNode(int i) {
	    IntPtr ptr = SprExport.Spr_PHSceneIf_GetRootNode((IntPtr) _thisArray[0], (int) i);
            if (ptr == IntPtr.Zero) { return null; } 
            PHRootNodeIf obj = new PHRootNodeIf(ptr);
            return obj;
	}
	public PHTreeNodeIf CreateTreeNode(PHTreeNodeIf parent, PHSolidIf child, PHTreeNodeDesc desc) {
	    IntPtr ptr = SprExport.Spr_PHSceneIf_CreateTreeNode((IntPtr) _thisArray[0], (IntPtr) parent, (IntPtr) child, (IntPtr) desc);
            if (ptr == IntPtr.Zero) { return null; } 
            PHTreeNodeIf obj = new PHTreeNodeIf(ptr);
            if (obj.GetIfInfo() == PHRootNodeIf.GetIfInfoStatic()) { return new PHRootNodeIf(ptr); }
            if (obj.GetIfInfo() == PHTreeNode1DIf.GetIfInfoStatic()) { return new PHTreeNode1DIf(ptr); }
            if (obj.GetIfInfo() == PHBallJointNodeIf.GetIfInfoStatic()) { return new PHBallJointNodeIf(ptr); }
            if (obj.GetIfInfo() == PHFixJointNodeIf.GetIfInfoStatic()) { return new PHFixJointNodeIf(ptr); }
            if (obj.GetIfInfo() == PHHingeJointNodeIf.GetIfInfoStatic()) { return new PHHingeJointNodeIf(ptr); }
            if (obj.GetIfInfo() == PHSliderJointNodeIf.GetIfInfoStatic()) { return new PHSliderJointNodeIf(ptr); }
            if (obj.GetIfInfo() == PHPathJointNodeIf.GetIfInfoStatic()) { return new PHPathJointNodeIf(ptr); }
            if (obj.GetIfInfo() == PHGenericJointNodeIf.GetIfInfoStatic()) { return new PHGenericJointNodeIf(ptr); }
            return obj;
	}
	public PHTreeNodeIf CreateTreeNode(PHTreeNodeIf parent, PHSolidIf child) {
	    IntPtr ptr = SprExport.Spr_PHSceneIf_CreateTreeNode_1((IntPtr) _thisArray[0], (IntPtr) parent, (IntPtr) child);
            if (ptr == IntPtr.Zero) { return null; } 
            PHTreeNodeIf obj = new PHTreeNodeIf(ptr);
            if (obj.GetIfInfo() == PHRootNodeIf.GetIfInfoStatic()) { return new PHRootNodeIf(ptr); }
            if (obj.GetIfInfo() == PHTreeNode1DIf.GetIfInfoStatic()) { return new PHTreeNode1DIf(ptr); }
            if (obj.GetIfInfo() == PHBallJointNodeIf.GetIfInfoStatic()) { return new PHBallJointNodeIf(ptr); }
            if (obj.GetIfInfo() == PHFixJointNodeIf.GetIfInfoStatic()) { return new PHFixJointNodeIf(ptr); }
            if (obj.GetIfInfo() == PHHingeJointNodeIf.GetIfInfoStatic()) { return new PHHingeJointNodeIf(ptr); }
            if (obj.GetIfInfo() == PHSliderJointNodeIf.GetIfInfoStatic()) { return new PHSliderJointNodeIf(ptr); }
            if (obj.GetIfInfo() == PHPathJointNodeIf.GetIfInfoStatic()) { return new PHPathJointNodeIf(ptr); }
            if (obj.GetIfInfo() == PHGenericJointNodeIf.GetIfInfoStatic()) { return new PHGenericJointNodeIf(ptr); }
            return obj;
	}
	public PHRootNodeIf CreateTreeNodes(PHSolidIf solid) {
	    IntPtr ptr = SprExport.Spr_PHSceneIf_CreateTreeNodes((IntPtr) _thisArray[0], (IntPtr) solid);
            if (ptr == IntPtr.Zero) { return null; } 
            PHRootNodeIf obj = new PHRootNodeIf(ptr);
            return obj;
	}
	public PHGearIf CreateGear(PH1DJointIf lhs, PH1DJointIf rhs, PHGearDesc desc) {
	    IntPtr ptr = SprExport.Spr_PHSceneIf_CreateGear((IntPtr) _thisArray[0], (IntPtr) lhs, (IntPtr) rhs, (IntPtr) desc);
            if (ptr == IntPtr.Zero) { return null; } 
            PHGearIf obj = new PHGearIf(ptr);
            return obj;
	}
	public PHGearIf CreateGear(PH1DJointIf lhs, PH1DJointIf rhs) {
	    IntPtr ptr = SprExport.Spr_PHSceneIf_CreateGear_1((IntPtr) _thisArray[0], (IntPtr) lhs, (IntPtr) rhs);
            if (ptr == IntPtr.Zero) { return null; } 
            PHGearIf obj = new PHGearIf(ptr);
            return obj;
	}
	public int NGears() {
	    int result = (int) SprExport.Spr_PHSceneIf_NGears((IntPtr) _thisArray[0]);
	    return result;
	}
	public PHGearIf GetGear(int i) {
	    IntPtr ptr = SprExport.Spr_PHSceneIf_GetGear((IntPtr) _thisArray[0], (int) i);
            if (ptr == IntPtr.Zero) { return null; } 
            PHGearIf obj = new PHGearIf(ptr);
            return obj;
	}
	public PHPathIf CreatePath(PHPathDesc desc) {
	    IntPtr ptr = SprExport.Spr_PHSceneIf_CreatePath((IntPtr) _thisArray[0], (IntPtr) desc);
            if (ptr == IntPtr.Zero) { return null; } 
            PHPathIf obj = new PHPathIf(ptr);
            return obj;
	}
	public PHPathIf CreatePath() {
	    IntPtr ptr = SprExport.Spr_PHSceneIf_CreatePath_1((IntPtr) _thisArray[0]);
            if (ptr == IntPtr.Zero) { return null; } 
            PHPathIf obj = new PHPathIf(ptr);
            return obj;
	}
	public int NPaths() {
	    int result = (int) SprExport.Spr_PHSceneIf_NPaths((IntPtr) _thisArray[0]);
	    return result;
	}
	public PHPathIf GetPath(int i) {
	    IntPtr ptr = SprExport.Spr_PHSceneIf_GetPath((IntPtr) _thisArray[0], (int) i);
            if (ptr == IntPtr.Zero) { return null; } 
            PHPathIf obj = new PHPathIf(ptr);
            return obj;
	}
	public PHRayIf CreateRay(PHRayDesc desc) {
	    IntPtr ptr = SprExport.Spr_PHSceneIf_CreateRay((IntPtr) _thisArray[0], (IntPtr) desc);
            if (ptr == IntPtr.Zero) { return null; } 
            PHRayIf obj = new PHRayIf(ptr);
            return obj;
	}
	public PHRayIf CreateRay() {
	    IntPtr ptr = SprExport.Spr_PHSceneIf_CreateRay_1((IntPtr) _thisArray[0]);
            if (ptr == IntPtr.Zero) { return null; } 
            PHRayIf obj = new PHRayIf(ptr);
            return obj;
	}
	public int NRays() {
	    int result = (int) SprExport.Spr_PHSceneIf_NRays((IntPtr) _thisArray[0]);
	    return result;
	}
	public PHRayIf GetRay(int i) {
	    IntPtr ptr = SprExport.Spr_PHSceneIf_GetRay((IntPtr) _thisArray[0], (int) i);
            if (ptr == IntPtr.Zero) { return null; } 
            PHRayIf obj = new PHRayIf(ptr);
            return obj;
	}
	public bool SetPosesOfJointedSolids(PHSolidIf base_) {
	    char ret = SprExport.Spr_PHSceneIf_SetPosesOfJointedSolids((IntPtr) _thisArray[0], (IntPtr) base_);
	    return (ret == 0) ? false : true;
	}
	public PHIKActuatorIf CreateIKActuator(IfInfo ii, PHIKActuatorDesc desc) {
	    IntPtr ptr = SprExport.Spr_PHSceneIf_CreateIKActuator((IntPtr) _thisArray[0], (IntPtr) ii, (IntPtr) desc);
            if (ptr == IntPtr.Zero) { return null; } 
            PHIKActuatorIf obj = new PHIKActuatorIf(ptr);
            if (obj.GetIfInfo() == PHIKBallActuatorIf.GetIfInfoStatic()) { return new PHIKBallActuatorIf(ptr); }
            if (obj.GetIfInfo() == PHIKHingeActuatorIf.GetIfInfoStatic()) { return new PHIKHingeActuatorIf(ptr); }
            if (obj.GetIfInfo() == PHIKSpringActuatorIf.GetIfInfoStatic()) { return new PHIKSpringActuatorIf(ptr); }
            return obj;
	}
	public PHIKActuatorIf CreateIKActuator(IfInfo ii) {
	    IntPtr ptr = SprExport.Spr_PHSceneIf_CreateIKActuator_1((IntPtr) _thisArray[0], (IntPtr) ii);
            if (ptr == IntPtr.Zero) { return null; } 
            PHIKActuatorIf obj = new PHIKActuatorIf(ptr);
            if (obj.GetIfInfo() == PHIKBallActuatorIf.GetIfInfoStatic()) { return new PHIKBallActuatorIf(ptr); }
            if (obj.GetIfInfo() == PHIKHingeActuatorIf.GetIfInfoStatic()) { return new PHIKHingeActuatorIf(ptr); }
            if (obj.GetIfInfo() == PHIKSpringActuatorIf.GetIfInfoStatic()) { return new PHIKSpringActuatorIf(ptr); }
            return obj;
	}
	public int NIKActuators() {
	    int result = (int) SprExport.Spr_PHSceneIf_NIKActuators((IntPtr) _thisArray[0]);
	    return result;
	}
	public PHIKActuatorIf GetIKActuator(int i) {
	    IntPtr ptr = SprExport.Spr_PHSceneIf_GetIKActuator((IntPtr) _thisArray[0], (int) i);
            if (ptr == IntPtr.Zero) { return null; } 
            PHIKActuatorIf obj = new PHIKActuatorIf(ptr);
            if (obj.GetIfInfo() == PHIKBallActuatorIf.GetIfInfoStatic()) { return new PHIKBallActuatorIf(ptr); }
            if (obj.GetIfInfo() == PHIKHingeActuatorIf.GetIfInfoStatic()) { return new PHIKHingeActuatorIf(ptr); }
            if (obj.GetIfInfo() == PHIKSpringActuatorIf.GetIfInfoStatic()) { return new PHIKSpringActuatorIf(ptr); }
            return obj;
	}
	public PHIKEndEffectorIf CreateIKEndEffector(PHIKEndEffectorDesc desc) {
	    IntPtr ptr = SprExport.Spr_PHSceneIf_CreateIKEndEffector((IntPtr) _thisArray[0], (IntPtr) desc);
            if (ptr == IntPtr.Zero) { return null; } 
            PHIKEndEffectorIf obj = new PHIKEndEffectorIf(ptr);
            return obj;
	}
	public PHIKEndEffectorIf CreateIKEndEffector() {
	    IntPtr ptr = SprExport.Spr_PHSceneIf_CreateIKEndEffector_1((IntPtr) _thisArray[0]);
            if (ptr == IntPtr.Zero) { return null; } 
            PHIKEndEffectorIf obj = new PHIKEndEffectorIf(ptr);
            return obj;
	}
	public int NIKEndEffectors() {
	    int result = (int) SprExport.Spr_PHSceneIf_NIKEndEffectors((IntPtr) _thisArray[0]);
	    return result;
	}
	public PHIKEndEffectorIf GetIKEndEffector(int i) {
	    IntPtr ptr = SprExport.Spr_PHSceneIf_GetIKEndEffector((IntPtr) _thisArray[0], (int) i);
            if (ptr == IntPtr.Zero) { return null; } 
            PHIKEndEffectorIf obj = new PHIKEndEffectorIf(ptr);
            return obj;
	}
	public int NSkeletons() {
	    int result = (int) SprExport.Spr_PHSceneIf_NSkeletons((IntPtr) _thisArray[0]);
	    return result;
	}
	public PHSkeletonIf GetSkeleton(int i) {
	    IntPtr ptr = SprExport.Spr_PHSceneIf_GetSkeleton((IntPtr) _thisArray[0], (int) i);
            if (ptr == IntPtr.Zero) { return null; } 
            PHSkeletonIf obj = new PHSkeletonIf(ptr);
            return obj;
	}
	public PHSkeletonIf CreateSkeleton(PHSkeletonDesc desc) {
	    IntPtr ptr = SprExport.Spr_PHSceneIf_CreateSkeleton((IntPtr) _thisArray[0], (IntPtr) desc);
            if (ptr == IntPtr.Zero) { return null; } 
            PHSkeletonIf obj = new PHSkeletonIf(ptr);
            return obj;
	}
	public PHSkeletonIf CreateSkeleton() {
	    IntPtr ptr = SprExport.Spr_PHSceneIf_CreateSkeleton_1((IntPtr) _thisArray[0]);
            if (ptr == IntPtr.Zero) { return null; } 
            PHSkeletonIf obj = new PHSkeletonIf(ptr);
            return obj;
	}
	public double GetTimeStep() {
	    double result = (double) SprExport.Spr_PHSceneIf_GetTimeStep((IntPtr) _thisArray[0]);
	    return result;
	}
	public double GetTimeStepInv() {
	    double result = (double) SprExport.Spr_PHSceneIf_GetTimeStepInv((IntPtr) _thisArray[0]);
	    return result;
	}
	public void SetTimeStep(double dt) {
	    SprExport.Spr_PHSceneIf_SetTimeStep((IntPtr) _thisArray[0], (double) dt);
	}
	public double GetHapticTimeStep() {
	    double result = (double) SprExport.Spr_PHSceneIf_GetHapticTimeStep((IntPtr) _thisArray[0]);
	    return result;
	}
	public void SetHapticTimeStep(double dt) {
	    SprExport.Spr_PHSceneIf_SetHapticTimeStep((IntPtr) _thisArray[0], (double) dt);
	}
	public uint GetCount() {
	    uint result = (uint) SprExport.Spr_PHSceneIf_GetCount((IntPtr) _thisArray[0]);
	    return result;
	}
	public void SetCount(uint count) {
	    SprExport.Spr_PHSceneIf_SetCount((IntPtr) _thisArray[0], (uint) count);
	}
	public void SetGravity(Vec3d accel) {
	    SprExport.Spr_PHSceneIf_SetGravity((IntPtr) _thisArray[0], (IntPtr) accel);
	}
	public Vec3d GetGravity() {
	    IntPtr ptr = SprExport.Spr_PHSceneIf_GetGravity((IntPtr) _thisArray[0]);
            return new Vec3d(ptr, true);
	}
	public void SetAirResistanceRateForVelocity(double rate) {
	    SprExport.Spr_PHSceneIf_SetAirResistanceRateForVelocity((IntPtr) _thisArray[0], (double) rate);
	}
	public void SetAirResistanceRateForAngularVelocity(double rate) {
	    SprExport.Spr_PHSceneIf_SetAirResistanceRateForAngularVelocity((IntPtr) _thisArray[0], (double) rate);
	}
	public double GetAirResistanceRateForVelocity() {
	    double result = (double) SprExport.Spr_PHSceneIf_GetAirResistanceRateForVelocity((IntPtr) _thisArray[0]);
	    return result;
	}
	public double GetAirResistanceRateForAngularVelocity() {
	    double result = (double) SprExport.Spr_PHSceneIf_GetAirResistanceRateForAngularVelocity((IntPtr) _thisArray[0]);
	    return result;
	}
	public void SetContactTolerance(double tol) {
	    SprExport.Spr_PHSceneIf_SetContactTolerance((IntPtr) _thisArray[0], (double) tol);
	}
	public double GetContactTolerance() {
	    double result = (double) SprExport.Spr_PHSceneIf_GetContactTolerance((IntPtr) _thisArray[0]);
	    return result;
	}
	public void SetImpactThreshold(double vth) {
	    SprExport.Spr_PHSceneIf_SetImpactThreshold((IntPtr) _thisArray[0], (double) vth);
	}
	public double GetImpactThreshold() {
	    double result = (double) SprExport.Spr_PHSceneIf_GetImpactThreshold((IntPtr) _thisArray[0]);
	    return result;
	}
	public void SetFrictionThreshold(double vth) {
	    SprExport.Spr_PHSceneIf_SetFrictionThreshold((IntPtr) _thisArray[0], (double) vth);
	}
	public double GetFrictionThreshold() {
	    double result = (double) SprExport.Spr_PHSceneIf_GetFrictionThreshold((IntPtr) _thisArray[0]);
	    return result;
	}
	public void SetMaxVelocity(double vmax) {
	    SprExport.Spr_PHSceneIf_SetMaxVelocity((IntPtr) _thisArray[0], (double) vmax);
	}
	public double GetMaxVelocity() {
	    double result = (double) SprExport.Spr_PHSceneIf_GetMaxVelocity((IntPtr) _thisArray[0]);
	    return result;
	}
	public void SetMaxAngularVelocity(double wmax) {
	    SprExport.Spr_PHSceneIf_SetMaxAngularVelocity((IntPtr) _thisArray[0], (double) wmax);
	}
	public double GetMaxAngularVelocity() {
	    double result = (double) SprExport.Spr_PHSceneIf_GetMaxAngularVelocity((IntPtr) _thisArray[0]);
	    return result;
	}
	public void SetMaxForce(double fmax) {
	    SprExport.Spr_PHSceneIf_SetMaxForce((IntPtr) _thisArray[0], (double) fmax);
	}
	public double GetMaxForce() {
	    double result = (double) SprExport.Spr_PHSceneIf_GetMaxForce((IntPtr) _thisArray[0]);
	    return result;
	}
	public void SetMaxMoment(double tmax) {
	    SprExport.Spr_PHSceneIf_SetMaxMoment((IntPtr) _thisArray[0], (double) tmax);
	}
	public double GetMaxMoment() {
	    double result = (double) SprExport.Spr_PHSceneIf_GetMaxMoment((IntPtr) _thisArray[0]);
	    return result;
	}
	public void SetMaxDeltaPosition(double dpmax) {
	    SprExport.Spr_PHSceneIf_SetMaxDeltaPosition((IntPtr) _thisArray[0], (double) dpmax);
	}
	public double GetMaxDeltaPosition() {
	    double result = (double) SprExport.Spr_PHSceneIf_GetMaxDeltaPosition((IntPtr) _thisArray[0]);
	    return result;
	}
	public void SetMaxDeltaOrientation(double dqmax) {
	    SprExport.Spr_PHSceneIf_SetMaxDeltaOrientation((IntPtr) _thisArray[0], (double) dqmax);
	}
	public double GetMaxDeltaOrientation() {
	    double result = (double) SprExport.Spr_PHSceneIf_GetMaxDeltaOrientation((IntPtr) _thisArray[0]);
	    return result;
	}
	public int GetLCPSolver() {
	    int result = (int) SprExport.Spr_PHSceneIf_GetLCPSolver((IntPtr) _thisArray[0]);
	    return result;
	}
	public void SetLCPSolver(int method) {
	    SprExport.Spr_PHSceneIf_SetLCPSolver((IntPtr) _thisArray[0], (int) method);
	}
	public int GetNumIteration() {
	    int result = (int) SprExport.Spr_PHSceneIf_GetNumIteration((IntPtr) _thisArray[0]);
	    return result;
	}
	public void SetNumIteration(int n) {
	    SprExport.Spr_PHSceneIf_SetNumIteration((IntPtr) _thisArray[0], (int) n);
	}
	public void SetStateMode(bool bConstraints) {
	    SprExport.Spr_PHSceneIf_SetStateMode((IntPtr) _thisArray[0], (bool) bConstraints);
	}
	public void EnableContactDetection(bool enable) {
	    SprExport.Spr_PHSceneIf_EnableContactDetection((IntPtr) _thisArray[0], (bool) enable);
	}
	public bool IsContactDetectionEnabled() {
	    char ret = SprExport.Spr_PHSceneIf_IsContactDetectionEnabled((IntPtr) _thisArray[0]);
	    return (ret == 0) ? false : true;
	}
	public void EnableCCD(bool enable) {
	    SprExport.Spr_PHSceneIf_EnableCCD((IntPtr) _thisArray[0], (bool) enable);
	}
	public bool IsCCDEnabled() {
	    char ret = SprExport.Spr_PHSceneIf_IsCCDEnabled((IntPtr) _thisArray[0]);
	    return (ret == 0) ? false : true;
	}
	public void SetBroadPhaseMode(int mode) {
	    SprExport.Spr_PHSceneIf_SetBroadPhaseMode((IntPtr) _thisArray[0], (int) mode);
	}
	public int GetBroadPhaseMode() {
	    int result = (int) SprExport.Spr_PHSceneIf_GetBroadPhaseMode((IntPtr) _thisArray[0]);
	    return result;
	}
	public void SetContactDetectionRange(Vec3f center, Vec3f extent, int nx, int ny, int nz) {
	    SprExport.Spr_PHSceneIf_SetContactDetectionRange((IntPtr) _thisArray[0], (IntPtr) center, (IntPtr) extent, (int) nx, (int) ny, (int) nz);
	}
	public void SetMaterialBlending(int mode) {
	    SprExport.Spr_PHSceneIf_SetMaterialBlending((IntPtr) _thisArray[0], (int) mode);
	}
	public void Step() {
	    SprExport.Spr_PHSceneIf_Step((IntPtr) _thisArray[0]);
	}
	public void ClearForce() {
	    SprExport.Spr_PHSceneIf_ClearForce((IntPtr) _thisArray[0]);
	}
	public void GenerateForce() {
	    SprExport.Spr_PHSceneIf_GenerateForce((IntPtr) _thisArray[0]);
	}
	public void Integrate() {
	    SprExport.Spr_PHSceneIf_Integrate((IntPtr) _thisArray[0]);
	}
	public void IntegratePart1() {
	    SprExport.Spr_PHSceneIf_IntegratePart1((IntPtr) _thisArray[0]);
	}
	public void IntegratePart2() {
	    SprExport.Spr_PHSceneIf_IntegratePart2((IntPtr) _thisArray[0]);
	}
	public void Clear() {
	    SprExport.Spr_PHSceneIf_Clear((IntPtr) _thisArray[0]);
	}
	public int NEngines() {
	    int result = (int) SprExport.Spr_PHSceneIf_NEngines((IntPtr) _thisArray[0]);
	    return result;
	}
	public PHEngineIf GetEngine(int i) {
	    IntPtr ptr = SprExport.Spr_PHSceneIf_GetEngine((IntPtr) _thisArray[0], (int) i);
            if (ptr == IntPtr.Zero) { return null; } 
            PHEngineIf obj = new PHEngineIf(ptr);
            if (obj.GetIfInfo() == PHConstraintEngineIf.GetIfInfoStatic()) { return new PHConstraintEngineIf(ptr); }
            if (obj.GetIfInfo() == PHGravityEngineIf.GetIfInfoStatic()) { return new PHGravityEngineIf(ptr); }
            if (obj.GetIfInfo() == PHPenaltyEngineIf.GetIfInfoStatic()) { return new PHPenaltyEngineIf(ptr); }
            if (obj.GetIfInfo() == PHIKEngineIf.GetIfInfoStatic()) { return new PHIKEngineIf(ptr); }
            if (obj.GetIfInfo() == PHFemEngineIf.GetIfInfoStatic()) { return new PHFemEngineIf(ptr); }
            if (obj.GetIfInfo() == PHOpEngineIf.GetIfInfoStatic()) { return new PHOpEngineIf(ptr); }
            if (obj.GetIfInfo() == PHHapticEngineIf.GetIfInfoStatic()) { return new PHHapticEngineIf(ptr); }
            return obj;
	}
	public PHConstraintEngineIf GetConstraintEngine() {
	    IntPtr ptr = SprExport.Spr_PHSceneIf_GetConstraintEngine((IntPtr) _thisArray[0]);
            if (ptr == IntPtr.Zero) { return null; } 
            PHConstraintEngineIf obj = new PHConstraintEngineIf(ptr);
            return obj;
	}
	public PHGravityEngineIf GetGravityEngine() {
	    IntPtr ptr = SprExport.Spr_PHSceneIf_GetGravityEngine((IntPtr) _thisArray[0]);
            if (ptr == IntPtr.Zero) { return null; } 
            PHGravityEngineIf obj = new PHGravityEngineIf(ptr);
            return obj;
	}
	public PHPenaltyEngineIf GetPenaltyEngine() {
	    IntPtr ptr = SprExport.Spr_PHSceneIf_GetPenaltyEngine((IntPtr) _thisArray[0]);
            if (ptr == IntPtr.Zero) { return null; } 
            PHPenaltyEngineIf obj = new PHPenaltyEngineIf(ptr);
            return obj;
	}
	public PHIKEngineIf GetIKEngine() {
	    IntPtr ptr = SprExport.Spr_PHSceneIf_GetIKEngine((IntPtr) _thisArray[0]);
            if (ptr == IntPtr.Zero) { return null; } 
            PHIKEngineIf obj = new PHIKEngineIf(ptr);
            return obj;
	}
	public PHFemEngineIf GetFemEngine() {
	    IntPtr ptr = SprExport.Spr_PHSceneIf_GetFemEngine((IntPtr) _thisArray[0]);
            if (ptr == IntPtr.Zero) { return null; } 
            PHFemEngineIf obj = new PHFemEngineIf(ptr);
            return obj;
	}
	public PHHapticEngineIf GetHapticEngine() {
	    IntPtr ptr = SprExport.Spr_PHSceneIf_GetHapticEngine((IntPtr) _thisArray[0]);
            if (ptr == IntPtr.Zero) { return null; } 
            PHHapticEngineIf obj = new PHHapticEngineIf(ptr);
            return obj;
	}
	public PHOpEngineIf GetOpEngine() {
	    IntPtr ptr = SprExport.Spr_PHSceneIf_GetOpEngine((IntPtr) _thisArray[0]);
            if (ptr == IntPtr.Zero) { return null; } 
            PHOpEngineIf obj = new PHOpEngineIf(ptr);
            return obj;
	}
	public PHOpSpHashColliAgentIf GetOpColliAgent() {
	    IntPtr ptr = SprExport.Spr_PHSceneIf_GetOpColliAgent((IntPtr) _thisArray[0]);
            if (ptr == IntPtr.Zero) { return null; } 
            PHOpSpHashColliAgentIf obj = new PHOpSpHashColliAgentIf(ptr);
            return obj;
	}
	public PHHapticPointerIf CreateHapticPointer() {
	    IntPtr ptr = SprExport.Spr_PHSceneIf_CreateHapticPointer((IntPtr) _thisArray[0]);
            if (ptr == IntPtr.Zero) { return null; } 
            PHHapticPointerIf obj = new PHHapticPointerIf(ptr);
            return obj;
	}
	public void StepHapticLoop() {
	    SprExport.Spr_PHSceneIf_StepHapticLoop((IntPtr) _thisArray[0]);
	}
	public void StepHapticSync() {
	    SprExport.Spr_PHSceneIf_StepHapticSync((IntPtr) _thisArray[0]);
	}
    }
    public partial class PHSdkIf : SdkIf {
	public PHSdkIf() { _thisArray[0] = SprExport.Spr_new_PHSdkIf(); _flag = true; }
	public PHSdkIf(IntPtr ptr) : base(ptr) {}
	public PHSdkIf(IntPtr ptr, bool flag) : base(ptr, flag) {}
	public static implicit operator PHSdkIf(CsCastObject target) {
		return (target._info.Inherit(PHSdkIf.GetIfInfoStatic()) ? new PHSdkIf(target._thisArray[0], target._flag) : null);
	}
	~PHSdkIf() { if (_flag) { SprExport.Spr_delete_PHSdkIf(_thisArray[0]); _flag = false; } }
        public override string ToString() {
            IntPtr ptr = SprExport.Spr_PHSdkIf_ToString((IntPtr) _thisArray[0]);
            string bstr = Marshal.PtrToStringBSTR(ptr);
            SprExport.Spr_PHSdkIf_FreeString((IntPtr) ptr);
            return bstr;
        }
	public IfInfo GetIfInfo() {
	    IntPtr ptr = SprExport.Spr_PHSdkIf_GetIfInfo((IntPtr) _thisArray[0]);
            return new IfInfo(ptr);
	}
	public static IfInfo GetIfInfoStatic() {
	    IntPtr ptr = SprExport.Spr_PHSdkIf_GetIfInfoStatic();
            return new IfInfo(ptr);
	}
	public PHSceneIf CreateScene(PHSceneDesc desc) {
	    IntPtr ptr = SprExport.Spr_PHSdkIf_CreateScene((IntPtr) _thisArray[0], (IntPtr) desc);
            if (ptr == IntPtr.Zero) { return null; } 
            PHSceneIf obj = new PHSceneIf(ptr);
            return obj;
	}
	public PHSceneIf CreateScene() {
	    IntPtr ptr = SprExport.Spr_PHSdkIf_CreateScene_1((IntPtr) _thisArray[0]);
            if (ptr == IntPtr.Zero) { return null; } 
            PHSceneIf obj = new PHSceneIf(ptr);
            return obj;
	}
	public int NScene() {
	    int result = (int) SprExport.Spr_PHSdkIf_NScene((IntPtr) _thisArray[0]);
	    return result;
	}
	public PHSceneIf GetScene(int i) {
	    IntPtr ptr = SprExport.Spr_PHSdkIf_GetScene((IntPtr) _thisArray[0], (int) i);
            if (ptr == IntPtr.Zero) { return null; } 
            PHSceneIf obj = new PHSceneIf(ptr);
            return obj;
	}
	public void MergeScene(PHSceneIf scene0, PHSceneIf scene1) {
	    SprExport.Spr_PHSdkIf_MergeScene((IntPtr) _thisArray[0], (IntPtr) scene0, (IntPtr) scene1);
	}
	public CDShapeIf CreateShape(IfInfo ii, CDShapeDesc desc) {
	    IntPtr ptr = SprExport.Spr_PHSdkIf_CreateShape((IntPtr) _thisArray[0], (IntPtr) ii, (IntPtr) desc);
            if (ptr == IntPtr.Zero) { return null; } 
            CDShapeIf obj = new CDShapeIf(ptr);
            return obj;
	}
	public int NShape() {
	    int result = (int) SprExport.Spr_PHSdkIf_NShape((IntPtr) _thisArray[0]);
	    return result;
	}
	public CDShapeIf GetShape(int i) {
	    IntPtr ptr = SprExport.Spr_PHSdkIf_GetShape((IntPtr) _thisArray[0], (int) i);
            if (ptr == IntPtr.Zero) { return null; } 
            CDShapeIf obj = new CDShapeIf(ptr);
            return obj;
	}
	public static PHSdkIf CreateSdk(PHSdkDesc desc) {
	    IntPtr ptr = SprExport.Spr_PHSdkIf_CreateSdk((IntPtr) desc);
            if (ptr == IntPtr.Zero) { return null; } 
            PHSdkIf obj = new PHSdkIf(ptr);
            return obj;
	}
	public static PHSdkIf CreateSdk() {
	    IntPtr ptr = SprExport.Spr_PHSdkIf_CreateSdk_1();
            if (ptr == IntPtr.Zero) { return null; } 
            PHSdkIf obj = new PHSdkIf(ptr);
            return obj;
	}
	public static void RegisterSdk() {
	    SprExport.Spr_PHSdkIf_RegisterSdk();
	}
    }
    public partial class PHBoneIf : SceneObjectIf {
	public PHBoneIf() { _thisArray[0] = SprExport.Spr_new_PHBoneIf(); _flag = true; }
	public PHBoneIf(IntPtr ptr) : base(ptr) {}
	public PHBoneIf(IntPtr ptr, bool flag) : base(ptr, flag) {}
	public static implicit operator PHBoneIf(CsCastObject target) {
		return (target._info.Inherit(PHBoneIf.GetIfInfoStatic()) ? new PHBoneIf(target._thisArray[0], target._flag) : null);
	}
	~PHBoneIf() { if (_flag) { SprExport.Spr_delete_PHBoneIf(_thisArray[0]); _flag = false; } }
        public override string ToString() {
            IntPtr ptr = SprExport.Spr_PHBoneIf_ToString((IntPtr) _thisArray[0]);
            string bstr = Marshal.PtrToStringBSTR(ptr);
            SprExport.Spr_PHBoneIf_FreeString((IntPtr) ptr);
            return bstr;
        }
	public IfInfo GetIfInfo() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHBoneIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new IfInfo(ptr);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHBoneIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new IfInfo(ptr);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHBoneIf_GetIfInfo((IntPtr) _thisArray[0]);
            return new IfInfo(ptr);
		}
		throw new InvalidOperationException();
	}
	public static IfInfo GetIfInfoStatic() {
	    IntPtr ptr = SprExport.Spr_PHBoneIf_GetIfInfoStatic();
            return new IfInfo(ptr);
	}
	public void SetSolid(PHSolidIf solid) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHBoneIf_SetSolid((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) solid);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHBoneIf_SetSolid((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) solid);
				}
			}
		} else {
	    SprExport.Spr_PHBoneIf_SetSolid((IntPtr) _thisArray[0], (IntPtr) solid);
		}
		throw new InvalidOperationException();
	}
	public PHSolidIf GetSolid() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHBoneIf_GetSolid((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            if (ptr == IntPtr.Zero) { return null; } 
            PHSolidIf obj = new PHSolidIf(ptr);
            if (obj.GetIfInfo() == PHHapticPointerIf.GetIfInfoStatic()) { return new PHHapticPointerIf(ptr); }
            return obj;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHBoneIf_GetSolid((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            if (ptr == IntPtr.Zero) { return null; } 
            PHSolidIf obj = new PHSolidIf(ptr);
            if (obj.GetIfInfo() == PHHapticPointerIf.GetIfInfoStatic()) { return new PHHapticPointerIf(ptr); }
            return obj;
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHBoneIf_GetSolid((IntPtr) _thisArray[0]);
            if (ptr == IntPtr.Zero) { return null; } 
            PHSolidIf obj = new PHSolidIf(ptr);
            if (obj.GetIfInfo() == PHHapticPointerIf.GetIfInfoStatic()) { return new PHHapticPointerIf(ptr); }
            return obj;
		}
		throw new InvalidOperationException();
	}
	public void SetProxySolid(PHSolidIf solid) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHBoneIf_SetProxySolid((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) solid);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHBoneIf_SetProxySolid((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) solid);
				}
			}
		} else {
	    SprExport.Spr_PHBoneIf_SetProxySolid((IntPtr) _thisArray[0], (IntPtr) solid);
		}
		throw new InvalidOperationException();
	}
	public PHSolidIf GetProxySolid() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHBoneIf_GetProxySolid((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            if (ptr == IntPtr.Zero) { return null; } 
            PHSolidIf obj = new PHSolidIf(ptr);
            if (obj.GetIfInfo() == PHHapticPointerIf.GetIfInfoStatic()) { return new PHHapticPointerIf(ptr); }
            return obj;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHBoneIf_GetProxySolid((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            if (ptr == IntPtr.Zero) { return null; } 
            PHSolidIf obj = new PHSolidIf(ptr);
            if (obj.GetIfInfo() == PHHapticPointerIf.GetIfInfoStatic()) { return new PHHapticPointerIf(ptr); }
            return obj;
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHBoneIf_GetProxySolid((IntPtr) _thisArray[0]);
            if (ptr == IntPtr.Zero) { return null; } 
            PHSolidIf obj = new PHSolidIf(ptr);
            if (obj.GetIfInfo() == PHHapticPointerIf.GetIfInfoStatic()) { return new PHHapticPointerIf(ptr); }
            return obj;
		}
		throw new InvalidOperationException();
	}
	public void SetJoint(PHJointIf joint) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHBoneIf_SetJoint((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) joint);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHBoneIf_SetJoint((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) joint);
				}
			}
		} else {
	    SprExport.Spr_PHBoneIf_SetJoint((IntPtr) _thisArray[0], (IntPtr) joint);
		}
		throw new InvalidOperationException();
	}
	public PHJointIf GetJoint() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHBoneIf_GetJoint((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            if (ptr == IntPtr.Zero) { return null; } 
            PHJointIf obj = new PHJointIf(ptr);
            if (obj.GetIfInfo() == PH1DJointIf.GetIfInfoStatic()) { return new PH1DJointIf(ptr); }
            if (obj.GetIfInfo() == PHBallJointIf.GetIfInfoStatic()) { return new PHBallJointIf(ptr); }
            if (obj.GetIfInfo() == PHFixJointIf.GetIfInfoStatic()) { return new PHFixJointIf(ptr); }
            if (obj.GetIfInfo() == PHSpringIf.GetIfInfoStatic()) { return new PHSpringIf(ptr); }
            if (obj.GetIfInfo() == PHMateIf.GetIfInfoStatic()) { return new PHMateIf(ptr); }
            if (obj.GetIfInfo() == PHHingeJointIf.GetIfInfoStatic()) { return new PHHingeJointIf(ptr); }
            if (obj.GetIfInfo() == PHSliderJointIf.GetIfInfoStatic()) { return new PHSliderJointIf(ptr); }
            if (obj.GetIfInfo() == PHPathJointIf.GetIfInfoStatic()) { return new PHPathJointIf(ptr); }
            if (obj.GetIfInfo() == PHGenericJointIf.GetIfInfoStatic()) { return new PHGenericJointIf(ptr); }
            if (obj.GetIfInfo() == PHPointToPointMateIf.GetIfInfoStatic()) { return new PHPointToPointMateIf(ptr); }
            if (obj.GetIfInfo() == PHPointToLineMateIf.GetIfInfoStatic()) { return new PHPointToLineMateIf(ptr); }
            if (obj.GetIfInfo() == PHPointToPlaneMateIf.GetIfInfoStatic()) { return new PHPointToPlaneMateIf(ptr); }
            if (obj.GetIfInfo() == PHLineToLineMateIf.GetIfInfoStatic()) { return new PHLineToLineMateIf(ptr); }
            if (obj.GetIfInfo() == PHPlaneToPlaneMateIf.GetIfInfoStatic()) { return new PHPlaneToPlaneMateIf(ptr); }
            return obj;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHBoneIf_GetJoint((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            if (ptr == IntPtr.Zero) { return null; } 
            PHJointIf obj = new PHJointIf(ptr);
            if (obj.GetIfInfo() == PH1DJointIf.GetIfInfoStatic()) { return new PH1DJointIf(ptr); }
            if (obj.GetIfInfo() == PHBallJointIf.GetIfInfoStatic()) { return new PHBallJointIf(ptr); }
            if (obj.GetIfInfo() == PHFixJointIf.GetIfInfoStatic()) { return new PHFixJointIf(ptr); }
            if (obj.GetIfInfo() == PHSpringIf.GetIfInfoStatic()) { return new PHSpringIf(ptr); }
            if (obj.GetIfInfo() == PHMateIf.GetIfInfoStatic()) { return new PHMateIf(ptr); }
            if (obj.GetIfInfo() == PHHingeJointIf.GetIfInfoStatic()) { return new PHHingeJointIf(ptr); }
            if (obj.GetIfInfo() == PHSliderJointIf.GetIfInfoStatic()) { return new PHSliderJointIf(ptr); }
            if (obj.GetIfInfo() == PHPathJointIf.GetIfInfoStatic()) { return new PHPathJointIf(ptr); }
            if (obj.GetIfInfo() == PHGenericJointIf.GetIfInfoStatic()) { return new PHGenericJointIf(ptr); }
            if (obj.GetIfInfo() == PHPointToPointMateIf.GetIfInfoStatic()) { return new PHPointToPointMateIf(ptr); }
            if (obj.GetIfInfo() == PHPointToLineMateIf.GetIfInfoStatic()) { return new PHPointToLineMateIf(ptr); }
            if (obj.GetIfInfo() == PHPointToPlaneMateIf.GetIfInfoStatic()) { return new PHPointToPlaneMateIf(ptr); }
            if (obj.GetIfInfo() == PHLineToLineMateIf.GetIfInfoStatic()) { return new PHLineToLineMateIf(ptr); }
            if (obj.GetIfInfo() == PHPlaneToPlaneMateIf.GetIfInfoStatic()) { return new PHPlaneToPlaneMateIf(ptr); }
            return obj;
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHBoneIf_GetJoint((IntPtr) _thisArray[0]);
            if (ptr == IntPtr.Zero) { return null; } 
            PHJointIf obj = new PHJointIf(ptr);
            if (obj.GetIfInfo() == PH1DJointIf.GetIfInfoStatic()) { return new PH1DJointIf(ptr); }
            if (obj.GetIfInfo() == PHBallJointIf.GetIfInfoStatic()) { return new PHBallJointIf(ptr); }
            if (obj.GetIfInfo() == PHFixJointIf.GetIfInfoStatic()) { return new PHFixJointIf(ptr); }
            if (obj.GetIfInfo() == PHSpringIf.GetIfInfoStatic()) { return new PHSpringIf(ptr); }
            if (obj.GetIfInfo() == PHMateIf.GetIfInfoStatic()) { return new PHMateIf(ptr); }
            if (obj.GetIfInfo() == PHHingeJointIf.GetIfInfoStatic()) { return new PHHingeJointIf(ptr); }
            if (obj.GetIfInfo() == PHSliderJointIf.GetIfInfoStatic()) { return new PHSliderJointIf(ptr); }
            if (obj.GetIfInfo() == PHPathJointIf.GetIfInfoStatic()) { return new PHPathJointIf(ptr); }
            if (obj.GetIfInfo() == PHGenericJointIf.GetIfInfoStatic()) { return new PHGenericJointIf(ptr); }
            if (obj.GetIfInfo() == PHPointToPointMateIf.GetIfInfoStatic()) { return new PHPointToPointMateIf(ptr); }
            if (obj.GetIfInfo() == PHPointToLineMateIf.GetIfInfoStatic()) { return new PHPointToLineMateIf(ptr); }
            if (obj.GetIfInfo() == PHPointToPlaneMateIf.GetIfInfoStatic()) { return new PHPointToPlaneMateIf(ptr); }
            if (obj.GetIfInfo() == PHLineToLineMateIf.GetIfInfoStatic()) { return new PHLineToLineMateIf(ptr); }
            if (obj.GetIfInfo() == PHPlaneToPlaneMateIf.GetIfInfoStatic()) { return new PHPlaneToPlaneMateIf(ptr); }
            return obj;
		}
		throw new InvalidOperationException();
	}
	public void SetParent(PHBoneIf parent) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHBoneIf_SetParent((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) parent);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHBoneIf_SetParent((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) parent);
				}
			}
		} else {
	    SprExport.Spr_PHBoneIf_SetParent((IntPtr) _thisArray[0], (IntPtr) parent);
		}
		throw new InvalidOperationException();
	}
	public PHBoneIf GetParent() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHBoneIf_GetParent((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            if (ptr == IntPtr.Zero) { return null; } 
            PHBoneIf obj = new PHBoneIf(ptr);
            return obj;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHBoneIf_GetParent((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            if (ptr == IntPtr.Zero) { return null; } 
            PHBoneIf obj = new PHBoneIf(ptr);
            return obj;
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHBoneIf_GetParent((IntPtr) _thisArray[0]);
            if (ptr == IntPtr.Zero) { return null; } 
            PHBoneIf obj = new PHBoneIf(ptr);
            return obj;
		}
		throw new InvalidOperationException();
	}
	public void SetLength(double length) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHBoneIf_SetLength((IntPtr) _thisArray[phSceneIf.sceneForStep], (double) length);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHBoneIf_SetLength((IntPtr) _thisArray[phSceneIf.sceneForGet], (double) length);
				}
			}
		} else {
	    SprExport.Spr_PHBoneIf_SetLength((IntPtr) _thisArray[0], (double) length);
		}
		throw new InvalidOperationException();
	}
	public void SetDirection(Vec3d dir) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHBoneIf_SetDirection((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) dir);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHBoneIf_SetDirection((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) dir);
				}
			}
		} else {
	    SprExport.Spr_PHBoneIf_SetDirection((IntPtr) _thisArray[0], (IntPtr) dir);
		}
		throw new InvalidOperationException();
	}
	public void SetPosition(Vec3d pos) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    SprExport.Spr_PHBoneIf_SetPosition((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) pos);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    SprExport.Spr_PHBoneIf_SetPosition((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) pos);
				}
			}
		} else {
	    SprExport.Spr_PHBoneIf_SetPosition((IntPtr) _thisArray[0], (IntPtr) pos);
		}
		throw new InvalidOperationException();
	}
    }
    public partial class PHSkeletonIf : SceneObjectIf {
	public PHSkeletonIf() { _thisArray[0] = SprExport.Spr_new_PHSkeletonIf(); _flag = true; }
	public PHSkeletonIf(IntPtr ptr) : base(ptr) {}
	public PHSkeletonIf(IntPtr ptr, bool flag) : base(ptr, flag) {}
	public static implicit operator PHSkeletonIf(CsCastObject target) {
		return (target._info.Inherit(PHSkeletonIf.GetIfInfoStatic()) ? new PHSkeletonIf(target._thisArray[0], target._flag) : null);
	}
	~PHSkeletonIf() { if (_flag) { SprExport.Spr_delete_PHSkeletonIf(_thisArray[0]); _flag = false; } }
        public override string ToString() {
            IntPtr ptr = SprExport.Spr_PHSkeletonIf_ToString((IntPtr) _thisArray[0]);
            string bstr = Marshal.PtrToStringBSTR(ptr);
            SprExport.Spr_PHSkeletonIf_FreeString((IntPtr) ptr);
            return bstr;
        }
	public IfInfo GetIfInfo() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHSkeletonIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForStep]);
            return new IfInfo(ptr);
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHSkeletonIf_GetIfInfo((IntPtr) _thisArray[phSceneIf.sceneForGet]);
            return new IfInfo(ptr);
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHSkeletonIf_GetIfInfo((IntPtr) _thisArray[0]);
            return new IfInfo(ptr);
		}
		throw new InvalidOperationException();
	}
	public static IfInfo GetIfInfoStatic() {
	    IntPtr ptr = SprExport.Spr_PHSkeletonIf_GetIfInfoStatic();
            return new IfInfo(ptr);
	}
	public int NBones() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    int result = (int) SprExport.Spr_PHSkeletonIf_NBones((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    int result = (int) SprExport.Spr_PHSkeletonIf_NBones((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    int result = (int) SprExport.Spr_PHSkeletonIf_NBones((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
	public PHBoneIf GetBone(int i) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHSkeletonIf_GetBone((IntPtr) _thisArray[phSceneIf.sceneForStep], (int) i);
            if (ptr == IntPtr.Zero) { return null; } 
            PHBoneIf obj = new PHBoneIf(ptr);
            return obj;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHSkeletonIf_GetBone((IntPtr) _thisArray[phSceneIf.sceneForGet], (int) i);
            if (ptr == IntPtr.Zero) { return null; } 
            PHBoneIf obj = new PHBoneIf(ptr);
            return obj;
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHSkeletonIf_GetBone((IntPtr) _thisArray[0], (int) i);
            if (ptr == IntPtr.Zero) { return null; } 
            PHBoneIf obj = new PHBoneIf(ptr);
            return obj;
		}
		throw new InvalidOperationException();
	}
	public PHBoneIf CreateBone(PHBoneIf parent, PHBoneDesc desc) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHSkeletonIf_CreateBone((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) parent, (IntPtr) desc);
            if (ptr == IntPtr.Zero) { return null; } 
            PHBoneIf obj = new PHBoneIf(ptr);
            return obj;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHSkeletonIf_CreateBone((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) parent, (IntPtr) desc);
            if (ptr == IntPtr.Zero) { return null; } 
            PHBoneIf obj = new PHBoneIf(ptr);
            return obj;
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHSkeletonIf_CreateBone((IntPtr) _thisArray[0], (IntPtr) parent, (IntPtr) desc);
            if (ptr == IntPtr.Zero) { return null; } 
            PHBoneIf obj = new PHBoneIf(ptr);
            return obj;
		}
		throw new InvalidOperationException();
	}
	public PHBoneIf CreateBone(PHBoneIf parent) {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    IntPtr ptr = SprExport.Spr_PHSkeletonIf_CreateBone_1((IntPtr) _thisArray[phSceneIf.sceneForStep], (IntPtr) parent);
            if (ptr == IntPtr.Zero) { return null; } 
            PHBoneIf obj = new PHBoneIf(ptr);
            return obj;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    IntPtr ptr = SprExport.Spr_PHSkeletonIf_CreateBone_1((IntPtr) _thisArray[phSceneIf.sceneForGet], (IntPtr) parent);
            if (ptr == IntPtr.Zero) { return null; } 
            PHBoneIf obj = new PHBoneIf(ptr);
            return obj;
				}
			}
		} else {
	    IntPtr ptr = SprExport.Spr_PHSkeletonIf_CreateBone_1((IntPtr) _thisArray[0], (IntPtr) parent);
            if (ptr == IntPtr.Zero) { return null; } 
            PHBoneIf obj = new PHBoneIf(ptr);
            return obj;
		}
		throw new InvalidOperationException();
	}
	public float GetGrabStrength() {
		PHSceneIf phSceneIf = GetCSPHSceneIf();
		if (phSceneIf.multiThreadMode) {;
			var currentThread = Thread.CurrentThread;
			if (currentThread == phSceneIf.stepThread) {
	    float result = (float) SprExport.Spr_PHSkeletonIf_GetGrabStrength((IntPtr) _thisArray[phSceneIf.sceneForStep]);
	    return result;
			} else if (currentThread == phSceneIf.subThread) {
				lock (phSceneIf.phSceneLock) {
					phSceneIf.isGetFunctionCalledInSubThread = true;
	    float result = (float) SprExport.Spr_PHSkeletonIf_GetGrabStrength((IntPtr) _thisArray[phSceneIf.sceneForGet]);
	    return result;
				}
			}
		} else {
	    float result = (float) SprExport.Spr_PHSkeletonIf_GetGrabStrength((IntPtr) _thisArray[0]);
	    return result;
		}
		throw new InvalidOperationException();
	}
    }
	public partial class IfInfoToCsType {
		public static Dictionary<IntPtr, Type> mapPhysics = new Dictionary<IntPtr, Type>() {
			{PHEngineIf.GetIfInfoStatic(), typeof(PHEngineIf)},
			{PHConstraintEngineIf.GetIfInfoStatic(), typeof(PHConstraintEngineIf)},
			{PHGravityEngineIf.GetIfInfoStatic(), typeof(PHGravityEngineIf)},
			{PHPenaltyEngineIf.GetIfInfoStatic(), typeof(PHPenaltyEngineIf)},
			{PHIKEngineIf.GetIfInfoStatic(), typeof(PHIKEngineIf)},
			{PHFemEngineIf.GetIfInfoStatic(), typeof(PHFemEngineIf)},
			{PHOpEngineIf.GetIfInfoStatic(), typeof(PHOpEngineIf)},
			{PHFemMeshIf.GetIfInfoStatic(), typeof(PHFemMeshIf)},
			{PHFemMeshThermoIf.GetIfInfoStatic(), typeof(PHFemMeshThermoIf)},
			{PHFemMeshNewIf.GetIfInfoStatic(), typeof(PHFemMeshNewIf)},
			{PHFemBaseIf.GetIfInfoStatic(), typeof(PHFemBaseIf)},
			{PHFemVibrationIf.GetIfInfoStatic(), typeof(PHFemVibrationIf)},
			{PHFemThermoIf.GetIfInfoStatic(), typeof(PHFemThermoIf)},
			{PHFemPorousWOMoveIf.GetIfInfoStatic(), typeof(PHFemPorousWOMoveIf)},
			{PHFrameIf.GetIfInfoStatic(), typeof(PHFrameIf)},
			{PHBodyIf.GetIfInfoStatic(), typeof(PHBodyIf)},
			{PHSolidIf.GetIfInfoStatic(), typeof(PHSolidIf)},
			{PHShapePairForLCPIf.GetIfInfoStatic(), typeof(PHShapePairForLCPIf)},
			{PHSolidPairIf.GetIfInfoStatic(), typeof(PHSolidPairIf)},
			{PHSolidPairForLCPIf.GetIfInfoStatic(), typeof(PHSolidPairForLCPIf)},
			{PHHapticPointerIf.GetIfInfoStatic(), typeof(PHHapticPointerIf)},
			{PHShapePairForHapticIf.GetIfInfoStatic(), typeof(PHShapePairForHapticIf)},
			{PHSolidPairForHapticIf.GetIfInfoStatic(), typeof(PHSolidPairForHapticIf)},
			{PHHapticEngineIf.GetIfInfoStatic(), typeof(PHHapticEngineIf)},
			{PHIKEndEffectorIf.GetIfInfoStatic(), typeof(PHIKEndEffectorIf)},
			{PHIKActuatorIf.GetIfInfoStatic(), typeof(PHIKActuatorIf)},
			{PHIKBallActuatorIf.GetIfInfoStatic(), typeof(PHIKBallActuatorIf)},
			{PHIKHingeActuatorIf.GetIfInfoStatic(), typeof(PHIKHingeActuatorIf)},
			{PHIKSpringActuatorIf.GetIfInfoStatic(), typeof(PHIKSpringActuatorIf)},
			{PHConstraintIf.GetIfInfoStatic(), typeof(PHConstraintIf)},
			{PHConstraintsIf.GetIfInfoStatic(), typeof(PHConstraintsIf)},
			{PHContactPointIf.GetIfInfoStatic(), typeof(PHContactPointIf)},
			{PHJointIf.GetIfInfoStatic(), typeof(PHJointIf)},
			{PH1DJointIf.GetIfInfoStatic(), typeof(PH1DJointIf)},
			{PHHingeJointIf.GetIfInfoStatic(), typeof(PHHingeJointIf)},
			{PHSliderJointIf.GetIfInfoStatic(), typeof(PHSliderJointIf)},
			{PHPathIf.GetIfInfoStatic(), typeof(PHPathIf)},
			{PHPathJointIf.GetIfInfoStatic(), typeof(PHPathJointIf)},
			{PHGenericJointIf.GetIfInfoStatic(), typeof(PHGenericJointIf)},
			{PHBallJointIf.GetIfInfoStatic(), typeof(PHBallJointIf)},
			{PHFixJointIf.GetIfInfoStatic(), typeof(PHFixJointIf)},
			{PHSpringIf.GetIfInfoStatic(), typeof(PHSpringIf)},
			{PHMateIf.GetIfInfoStatic(), typeof(PHMateIf)},
			{PHPointToPointMateIf.GetIfInfoStatic(), typeof(PHPointToPointMateIf)},
			{PHPointToLineMateIf.GetIfInfoStatic(), typeof(PHPointToLineMateIf)},
			{PHPointToPlaneMateIf.GetIfInfoStatic(), typeof(PHPointToPlaneMateIf)},
			{PHLineToLineMateIf.GetIfInfoStatic(), typeof(PHLineToLineMateIf)},
			{PHPlaneToPlaneMateIf.GetIfInfoStatic(), typeof(PHPlaneToPlaneMateIf)},
			{PHTreeNodeIf.GetIfInfoStatic(), typeof(PHTreeNodeIf)},
			{PHRootNodeIf.GetIfInfoStatic(), typeof(PHRootNodeIf)},
			{PHTreeNode1DIf.GetIfInfoStatic(), typeof(PHTreeNode1DIf)},
			{PHHingeJointNodeIf.GetIfInfoStatic(), typeof(PHHingeJointNodeIf)},
			{PHSliderJointNodeIf.GetIfInfoStatic(), typeof(PHSliderJointNodeIf)},
			{PHPathJointNodeIf.GetIfInfoStatic(), typeof(PHPathJointNodeIf)},
			{PHGenericJointNodeIf.GetIfInfoStatic(), typeof(PHGenericJointNodeIf)},
			{PHBallJointNodeIf.GetIfInfoStatic(), typeof(PHBallJointNodeIf)},
			{PHFixJointNodeIf.GetIfInfoStatic(), typeof(PHFixJointNodeIf)},
			{PHGearIf.GetIfInfoStatic(), typeof(PHGearIf)},
			{PH1DJointLimitIf.GetIfInfoStatic(), typeof(PH1DJointLimitIf)},
			{PHBallJointLimitIf.GetIfInfoStatic(), typeof(PHBallJointLimitIf)},
			{PHBallJointConeLimitIf.GetIfInfoStatic(), typeof(PHBallJointConeLimitIf)},
			{PHBallJointSplineLimitIf.GetIfInfoStatic(), typeof(PHBallJointSplineLimitIf)},
			{PHBallJointIndependentLimitIf.GetIfInfoStatic(), typeof(PHBallJointIndependentLimitIf)},
			{PH1DJointMotorIf.GetIfInfoStatic(), typeof(PH1DJointMotorIf)},
			{PH1DJointNonLinearMotorIf.GetIfInfoStatic(), typeof(PH1DJointNonLinearMotorIf)},
			{PHHuman1DJointResistanceIf.GetIfInfoStatic(), typeof(PHHuman1DJointResistanceIf)},
			{PHBallJointMotorIf.GetIfInfoStatic(), typeof(PHBallJointMotorIf)},
			{PHBallJointNonLinearMotorIf.GetIfInfoStatic(), typeof(PHBallJointNonLinearMotorIf)},
			{PHHumanBallJointResistanceIf.GetIfInfoStatic(), typeof(PHHumanBallJointResistanceIf)},
			{PHSpringMotorIf.GetIfInfoStatic(), typeof(PHSpringMotorIf)},
			{PHOpObjIf.GetIfInfoStatic(), typeof(PHOpObjIf)},
			{PHOpParticleIf.GetIfInfoStatic(), typeof(PHOpParticleIf)},
			{PHOpGroupIf.GetIfInfoStatic(), typeof(PHOpGroupIf)},
			{PHOpHapticControllerIf.GetIfInfoStatic(), typeof(PHOpHapticControllerIf)},
			{PHOpHapticRendererIf.GetIfInfoStatic(), typeof(PHOpHapticRendererIf)},
			{PHOpAnimationIf.GetIfInfoStatic(), typeof(PHOpAnimationIf)},
			{PHOpSpHashColliAgentIf.GetIfInfoStatic(), typeof(PHOpSpHashColliAgentIf)},
			{PHRayIf.GetIfInfoStatic(), typeof(PHRayIf)},
			{PHSceneIf.GetIfInfoStatic(), typeof(PHSceneIf)},
			{PHSdkIf.GetIfInfoStatic(), typeof(PHSdkIf)},
			{PHBoneIf.GetIfInfoStatic(), typeof(PHBoneIf)},
			{PHSkeletonIf.GetIfInfoStatic(), typeof(PHSkeletonIf)},
		};
	}
}
